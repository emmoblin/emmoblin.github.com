
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Emmoblin Blog</title>
  <meta name="author" content="emmoblin">

  
  <meta name="description" content="">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://emmoblin.github.com">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/bootstrap/bootstrap.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/bootstrap/responsive.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/syntax/syntax.css" media="screen, projection" rel="stylesheet" type="text/css">
  <style type="text/css">
    body {
      padding-bottom: 40px;
    }
    h1 {
      margin-bottom: 15px;
    }
    img {
      max-width: 100%;
    }
    .sharing, .meta, .pager {
      margin: 20px 0px 20px 0px;
    }
    .page-footer p {
      text-align: center;
    }
  </style>
  <script src="/javascripts/libs/jquery.js"></script>
  <script src="/javascripts/libs/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/bootstrap.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Emmoblin Blog" type="application/atom+xml">
  
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34538597-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><div class="navbar">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>

      <a class="brand" href="/">Emmoblin Blog</a>

      <div class="nav-collapse">
        <ul class="nav">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>


        <ul class="nav pull-right" data-subscription="rss">
          <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
          
        </ul>

        
          <form class="pull-right navbar-search" action="http://google.com/search" method="get">
            <fieldset role="search">
              <input type="hidden" name="q" value="site:emmoblin.github.com" />
              <input class="search-query" type="text" name="q" results="0" placeholder="Search"/>
            </fieldset>
          </form>
        
      </div>
    </div>
  </div>
</div>
</nav>
  <div class="container">
    <div class="row-fluid">
      <div class="span9">
  
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2013/02/19/ssh-tunnel/">Ssh隧道技术</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-19T00:00:00+08:00" pubdate data-updated="true">2013年02月19日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">ssh隧道技术</a>
<ul>
<li><a href="#sec-1-1">什么情况下使用隧道</a></li>
<li><a href="#sec-1-2">建立本地隧道</a>
<ul>
<li><a href="#sec-1-2-1">通过SSH隧道建立SOCKS服务器</a></li>
</ul>
</li>
<li><a href="#sec-1-3">建立远程SSH隧道</a></li>
<li><a href="#sec-1-4">一些技巧</a>
<ul>
<li><a href="#sec-1-4-1">检查隧道状态</a></li>
<li><a href="#sec-1-4-2">如何将端口绑定到外部地址上</a></li>
<li><a href="#sec-1-4-3">自动连接和防断线脚本</a></li>
</ul>
</li>
<li><a href="#sec-1-5">动态域名</a></li>
<li><a href="#sec-1-6">参考</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/19/ssh-tunnel/">ssh隧道技术</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">什么情况下使用隧道</h3>
<div class="outline-text-3" id="text-1-1">

<ol>
<li>公司为了防止我们用XX软件封锁了它的端口或者服务器地址。<br/>
</li>
<li>nat穿越，或者叫ssh反向隧道访问内网的pc，比如：在家里访问我在公司的电脑。<br/>
</li>
</ol>


<p><br/>
通过在外网一个ssh服务器做代理，实现穿越功能。<br/>
我主要使用第二种功能，在家里访问公司的电脑。可以远程办公了。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">建立本地隧道</h3>
<div class="outline-text-3" id="text-1-2">

<p>建立本地隧道实现第一种隧道模式。<br/>
假设内网机子A要访问C，但被拒绝了，这样可以通过中间的B建立ssh本地隧道实现A-B-C的访问。<br/>
实际上这种一般不太常用，毕竟有很多代理服务器都可以方便实现代理功能。<br/>
</p>
<p><br/>
在A上执行：<br/>
</p>
<p><br/>
<pre class="src src-sh">ssh -N -f -L 2121:C:21 B
ftp localhost:2121 <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">&#29616;&#22312;&#35775;&#38382;&#26412;&#22320;2121&#31471;&#21475;&#65292;&#23601;&#33021;&#36830;&#25509;C&#30340;21&#31471;&#21475;&#20102;</span>
</pre>


这里我们用到了SSH客户端的三个参数:<br/>
-N 告诉SSH客户端，这个连接不需要执行任何命令。仅仅做端口转发<br/>
-f 告诉SSH客户端在后台运行<br/>
-L 做本地映射端口，被冒号分割的三个部分含义分别是<br/>
需要使用的本地端口号<br/>
需要访问的目标机器IP地址（IP: 234.234.234.234）<br/>
需要访问的目标机器端口（端口: 21)<br/>
最后一个参数是我们用来建立隧道的中间机器的IP地址(IP: 123.123.123.123)<br/>
</p>
<p><br/>
我们再重复一下-L参数的行为。<br/>
-L X:Y:Z 将IP为Y的机器的Z端口通过中间服务器映射到本地机器的X端口。<br/>
</p>
<p><br/>
在这条命令成功执行之后，我们已经具有绕过公司防火墙的能力，并且成功访问到了我们喜欢的一个FTP服务器了。<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">通过SSH隧道建立SOCKS服务器</h4>
<div class="outline-text-4" id="text-1-2-1">

<p>如果我们需要借助一台中间服务器访问很多资源，一个个映射显然不是高明的办法。<br/>
幸好，SSH客户端为我们提供了通过SSH隧道建立SOCKS服务器的功能。<br/>
</p>
<p><br/>
通过下面的命令我们可以建立一个通过123.123.123.123的SOCKS服务器。<br/>
ssh -N -f -D 0.0.0.0:1080 123.123.123.123 # 将端口绑定在0.0.0.0上<br/>
通过SSH建立的SOCKS服务器使用的是SOCKS5协议，在为应用程序设置SOCKS代理的时候要特别注意。<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">建立远程SSH隧道</h3>
<div class="outline-text-3" id="text-1-3">

<p>现象我想在家里访问公司内网的电脑，这时从外到内访问显然是不行的，但从公司内往外访问是正常的。<br/>
所以就是用远程ssh隧道，先通过内网ssh到B，然后通过访问B的端口就可以访问内网的A了。<br/>
</p>
<p><br/>
在A上执行：<br/>
<code>ssh -N -f -R 2222:127.0.0.1:22 B</code><br/>
现在，在B机器上我们用下面的命令就可以登陆公司的A机器了。<br/>
<code>ssh -p 2222 localhost</code><br/>
</p>
<p><br/>
我们现在重点说说参数-R。该参数的三个部分的含义分别是:<br/>
远程机器使用的端口（2222）<br/>
需要映射的内部机器的IP地址(127.0.0.1)<br/>
需要映射的内部机器的端口(22)<br/>
例如：-R X:Y:Z 就是把我们内部的Y机器的Z端口映射到远程机器的X端口上。<br/>
</p>
<p><br/>
实际上这里所说的本地隧道和远程隧道(-L,-R),实际上指的是ssh代理listen的端口在本地还是在远端。<br/>
如果在本地listen就是本地隧道，如果要是在远端listen一个端口就是远端隧道。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">一些技巧</h3>
<div class="outline-text-3" id="text-1-4">


</div>

<div id="outline-container-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">检查隧道状态</h4>
<div class="outline-text-4" id="text-1-4-1">

<p>有些时候隧道会因为一些原因通信不畅而卡死，例如：由于传输数据量太大，被路由器带入stalled状态。这种时候，往往SSH客户端并不退出，而是卡死在那里。一种应对方法是，使用SSH客户端的ServerAliveInterval和ServerAliveCountMax选项。ServerAliveInterval会在隧道无通信后的一段设置好的时间后发送一个请求给服务器要求服务器响应。如果服务器在ServerAliveCountMax次请求后都没能响应，那么SSH客户端就自动断开连接并退出，将控制权交给你的监控程序。这两个选项的设置方法分别是在ssh时加入-o ServerAliveInterval=n和-o ServerAliveCountMax=m。其中n, m可以自行定义。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">如何将端口绑定到外部地址上</h4>
<div class="outline-text-4" id="text-1-4-2">

<p>使用上面的方法，映射的端口只能绑定在127.0.0.1这个接口上。也就是说，只能被本机自己访问到。如何才能让其他机器访问这个端口呢？我们可以把这个映射的端口绑定在0.0.0.0的接口上，方法是加上参数-b 0.0.0.0。同时还需要打开SSH服务器端的一个选项－GatewayPorts。默认情况下它应当是被打开的。如果被关闭的话，可以在/etc/sshd_config中修改GatewayPorts no为GatewayPorts yes来打开它。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4-3" class="outline-4">
<h4 id="sec-1-4-3">自动连接和防断线脚本</h4>
<div class="outline-text-4" id="text-1-4-3">

<p>Linux平台ssh默认不支持把密码作为参数，不过有sshpass可以搞定<br/>
</p>
<p><br/>
<a href="http://sourceforge.net/projects/sshpass/files/latest/download">http://sourceforge.net/projects/sshpass/files/latest/download</a><br/>
</p>
<p><br/>
下载，解压，编译，把可执行文件拷贝到合适的目录，执行命令格式如下：<br/>
</p>
<p><br/>
<code>sshpass -p "password" ssh -D 7070 user@serverip</code><br/>
</p>
<p><br/>
貌似ubuntu下可以直接apt-get install sshpass<br/>
</p>
<p><br/>
然后写脚本autossh.sh，内容如下：<br/>
</p>
<p><br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">!/bin/</span><span style="color: #0000ff;">bash</span>
<span style="color: #0000ff;">while</span> [ <span style="color: #00bfff;">''</span> == <span style="color: #00bfff;">''</span> ]
<span style="color: #0000ff;">do</span>
 <span style="color: #ff1493;">ssh_d_process_num</span>=<span style="color: #ff00ff;">`ps aux|grep -E 'ssh \-' |grep -v grep |wc -l`</span>
 <span style="color: #0000ff;">if</span> [ <span style="color: #00bfff;">"$ssh_d_process_num"</span> == <span style="color: #00bfff;">"0"</span> ]; <span style="color: #0000ff;">then</span>
  /home/user/sshpass -p <span style="color: #00bfff;">"password"</span> ssh -D 7070 user@ServerIP &amp;
 <span style="color: #0000ff;">fi</span>

 sleep 300
<span style="color: #0000ff;">done</span>
</pre>


执行一下这个脚本就可以了。sleep 300代表300秒查看一次，可以根据需要调整。<br/>
</p></div>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">动态域名</h3>
<div class="outline-text-3" id="text-1-5">

<p>花生壳linux程序下载地址：<br/>
<a href="http://www.oray.com/peanuthull/download_linux.php">http://www.oray.com/peanuthull/download\_linux.php</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">参考</h3>
<div class="outline-text-3" id="text-1-6">

<p><a href="http://blog.creke.net/722.html">http://blog.creke.net/722.html</a><br/>
</p></div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2013/02/17/ipv6-nat-map66/">IPv6 NAT MAP66</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-17T00:00:00+08:00" pubdate data-updated="true">2013年02月17日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">IPv6 NAT MAP66</a>
<ul>
<li><a href="#sec-1-1">相关的RFC</a></li>
<li><a href="#sec-1-2">IPv6子网和NAT的关系</a></li>
<li><a href="#sec-1-3">checksum无关性和自动转换</a></li>
<li><a href="#sec-1-4">Linux上的MAP66</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/17/ipv6-nat-map66/">IPv6 NAT MAP66</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">相关的RFC</h3>
<div class="outline-text-3" id="text-1-1">

<p>RFC6296的标题是IPv6-to-IPv6 Network Prefix Translation，描述了IPv6下的NAT的实现要点，给出了一个合理的建议，<br/>
既保持了IP的无方向性，又可以满足NAT的语义，这就是IPv6之NAT stateless的缘由，你不能再指望像IPv4的NAT那样只需要配置一条rule，然后反方向的rule动态生成，<br/>
IPv6情况下，两个方向的rule都需要你自己手工来配置。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">IPv6子网和NAT的关系</h3>
<div class="outline-text-3" id="text-1-2">

<p>IP地址可以划分为几个段，包括网络前缀，子网标识，主机标识，这在IPv4和IPv6中没有什么不同。<br/>
IPv4的NAT为了节约IP地址，也就是说，可供映射的IP地址pool中的地址小于或者远远小于其内部主机的数量，因此很有可能多个内部主机被映射成了同一个外部IP地址，<br/>
这如何来区分它们，因此不得不引入诸如第四层协议，端口等信息了，也就是我们熟知的五元组信息，因此IPv4的NAT实现大多数都是基于五元组流的，这样就保证了内核保持的NAT信息项的唯一性，同时也引入了很多副作用。<br/>
</p>
<p><br/>
IPv6地址持有将近128位可随意调配的位，鉴于地址空间的庞大，一般的单位都会被分配到一个拥有很大量地址的网段，<br/>
此网段拥有足够多的地址来和内网主机进行一一映射，也就是说可用于映射的IP地址pool容量巨大无比，<br/>
关键是这个一一映射如何来保持，既然不想再使用非IP层的信息来保持信息，那就要用纯IP层的信息了，这样对上层影响最小。<br/>
对于IPv4，经典NAT使用了五元组来保持流标识信息，而对于IPv6，则更加绝妙，它利用(而不是使用)了checksum的算法，丝毫不管这个checksum是谁的checksum，因为它根本就不改变数据包的checksum&hellip;<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">checksum无关性和自动转换</h3>
<div class="outline-text-3" id="text-1-3">

<p>这个很好解释，考虑<br/>
a+b+c+d=X<br/>
其中X就是checksum，我们把a，b当成源IP地址的两部分，c，d当成目的IP地址的两部分，我们作源地址转换，将a和b都改变，比如a改变成了A，<br/>
试问将b改成多少才能保持checksum的值X不变，这其实很简单，就是一个简单的一元一次方程求解的问题。<br/>
IPv6的建议NAT实现也是这个原理，只不过上面的一元一次方程是实数域的，而这个是计算机布尔数域。<br/>
既然可以不触动第四层的checksum值，那么NAT对第四层协议的影响也就减小了，虽然它还是解决不了诸如ESP/AH等穿越NAT的问题。<br/>
基于以上算法，IPv6在做NAT的时候，在给定的子网网段内，可以自动生成一个新的IP地址供映射之用，从算法本身来看，冲突的可能性非常之小致于0，<br/>
上述的做法对于IPv4几乎是不可能的，因为IPv4地址空间太小了。<br/>
既然IPv6的NAT机制“自动”为一个连接选择了一个IP地址，那么当返回包到来的时候，如何来把地址转换回原来的呢？<br/>
我们知道，IPv6的NAT已经不再使用五元组来维护NAT映射信息，也不在内核维护这种信息，那么“转换回去”这件事就要完全靠算法本身了，<br/>
恰恰就是算法本身能将转换后的地址再转回原来的，其依据就是本小节最开始处给出的一元一次方程解的唯一性，<br/>
在IPv6的NAT实现中，算法只针对IP地址中16位的地址信息进行自动生成，而其它的则需要手工显式配置，<br/>
由于内网IPv6地址可以使用MAC地址映射成唯一的地址，由于一元一次方程解的唯一性，那么转换后的地址也是唯一的，将这一切反过来，最后还是能映射回原始的IP地址的。<br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">Linux上的MAP66</h3>
<div class="outline-text-3" id="text-1-4">

<p>Linux上，IPv6的NAT MAP66是一个基本遵循RFC6296建议的Linux实现，编译安装很简单，详见其README，和IPv4的iptables一样：<br/>
1.配置正向的转换规则，将源地址fdca:ffee:babe::/64网段的地址转换为2008:db8:1::/64网段的地址<br/>
<code>ip6tables -t mangle -A POSTROUTING -s fdca:ffee:babe::/64 -o eth2 -j MAP66--src-to 2008:db8:1::/64</code><br/>
可以看出，没有显式指定任何具体地址，类似IPv4的MASQUERADE和IPv4的IP Pool<br/>
2.配置反向包的转换规则，将正向包被转换过的地址再转换回去<br/>
<code>ip6tables -t mangle -A PREROUTING -d 2008:db8:1::/64 -i eth2 -j MAP66 --dst-to fdca:ffee:babe::/64</code><br/>
可以看出，也没有显式指定任何具体的地址，更值得一提的是，内核并不维护任何关于NAT映射的信息，因此MAP66也不再依赖ip(6)_conntrack。<br/>
</p></div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2013/02/14/goagent/">Goagent翻墙</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-14T00:00:00+08:00" pubdate data-updated="true">2013年02月14日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">安装</h3>
<div class="outline-text-3" id="text-1-1">

<p>安装最好直接看官网：<br/>
<a href="https://code.google.com/p/goagent/">https://code.google.com/p/goagent/</a><br/>
</p>
<p><br/>
不过为了自己方便，我也自己记录一下。<br/>
</p>
<p><br/>
在GAE注册一个appid，<a href="https://appengine.google.com/">https://appengine.google.com/</a><br/>
</p><ol>
<li>修改local\proxy.ini中的[gae]下的appid=你的appid<br/>
</li>
<li>双击server\uploader.bat(Mac/Linux上传方法请见FAQ)，上传成功后即可使用了(地址127.0.0.1:8087)<br/>
</li>
</ol>

<p>对于linux<br/>
在server目录下，python uploader.zip<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">安装python-gevent</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>参考：<a href="https://code.google.com/p/goagent/wiki/InstallGeventAndPyopensslOnUbuntu">https://code.google.com/p/goagent/wiki/InstallGeventAndPyopensslOnUbuntu</a><br/>
<code>sudo apt-get install  python-gevent</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">安装pyopenssl</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>这个一般都安装了<br/>
</p>
<p><br/>
<pre class="src src-sh">wget http://pypi.python.org/packages/source/p/pyOpenSSL/pyOpenSSL-0.13.tar.gz &amp;&amp; tar zxvf pyOpenSSL-0.13.tar.gz &amp;&amp; <span style="color: #a52a2a;">cd</span> pyOpenSSL-0.13 &amp;&amp; sudo python setup.py install
</pre>


</p></div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">Chrome下如何使用goagent</h3>
<div class="outline-text-3" id="text-1-2">

<p>Chrome可以安装switchysharp插件<br/>
然后导入local中的SwitchyOptions.bak配置文件，之后就可以选择自动切换模式，他会根据规则自动选择是否使用代理。<br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">有时goagent无法使用，解决办法</h3>
<div class="outline-text-3" id="text-1-3">

<p>可能是google_cn服务被屏蔽<br/>
我们可以在proxy.ini中将profile=google_cn改成google_hk<br/>
将[google_hk]段中的mode = http改为mode = https，重启goagent解决。<br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">遗留问题</h3>
<div class="outline-text-3" id="text-1-4">

<p>我现在使用的是2.1.12版本，发现的问题是google analytics总是提示cookiemismatch。<br/>
搜了半天也解决不了。<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2013/02/13/raid/">Raid介绍</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-13T00:00:00+08:00" pubdate data-updated="true">2013年02月13日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">raid介绍</a>
<ul>
<li><a href="#sec-1-1">关键技术</a>
<ul>
<li><a href="#sec-1-1-1">数据校验</a></li>
</ul>
</li>
<li><a href="#sec-1-2">可管理性</a></li>
<li><a href="#sec-1-3">RAID等级</a>
<ul>
<li><a href="#sec-1-3-1">RAID0</a></li>
<li><a href="#sec-1-3-2">RAID1</a></li>
<li><a href="#sec-1-3-3">RAID2</a></li>
<li><a href="#sec-1-3-4">RAID3</a></li>
<li><a href="#sec-1-3-5">RAID4</a></li>
<li><a href="#sec-1-3-6">RAID5</a></li>
<li><a href="#sec-1-3-7">RAID6</a></li>
<li><a href="#sec-1-3-8">RAID 组合等级</a></li>
</ul>
</li>
<li><a href="#sec-1-4">linux上创建raid5</a></li>
<li><a href="#sec-1-5">资料</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/13/raid/">raid介绍</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
RAID 的两个关键目标是提高数据可靠性和 I/O 性能。<br/>
通过把相同数据同时写入到多块磁盘（典型地如镜像），或者将计算的校验数据写入阵列中来获得冗余能力，当单块磁盘出现故障时可以保证不会导致数据丢失。有些 RAID 等级允许更多地 磁盘同时发生故障，比如 RAID6 ，可以是两块磁盘同时损坏。在这样的冗余机制下，可以用新磁盘替换故障磁盘， RAID 会自动根据剩余磁盘中的数据和校验数据重建丢失的数据，保证数据一致性和完整性。数据分散保存在 RAID 中的多个不同磁盘上，并发数据读写要大大优于单个磁盘，因此可以获得更高的聚合 I/O 带宽。当然，磁盘阵列会减少全体磁盘的总可用存储空间，牺牲空间换取更高的可靠性和性能。<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">关键技术</h3>
<div class="outline-text-3" id="text-1-1">

<p>RAID 中主要有三个关键概念和技术：镜像（ Mirroring ）、数据条带（ Data Stripping ）和数据校验（ Data parity ）<br/>
数据条带，将数据分片保存在多个不同的磁盘，多个数据分片共同组成一个完整数据副本，这与镜像的多个副本是不同的，它通常用于性能考虑。数据条带具有更高的并发粒度，当访问数据时，可以同时对位于不同磁盘上数据进行读写操作， 从而获得非常可观的 I/O 性能提升 。数据校验，利用冗余数据进行数据错误检测和修复，冗余数据通常采用海明码、异或操作等算法来计算获得。利用校验功能，可以很大程度上提高磁盘阵列的可靠性、鲁棒性和容错能力。不过，数据校验需要从多处读取数据并进行计算和对比，会影响系统性能。 不同等级的 RAID 采用一个或多个以上的三种技术，来获得不同的数据可靠性、可用性和 I/O 性能。<br/>
</p>
</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">数据校验</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>采用数据校验时， RAID 要在写入数据同时进行校验计算，并将得到的校验数据存储在 RAID 成员磁盘中。校验数据可以集中保存在某个磁盘或分散存储在多个不同磁盘中，甚至校验数据也可以分块，不同 RAID 等级实现各不相同。当其中一部分数据出错时，就可以对剩余数据和校验数据进行反校验计算重建丢失的数据。校验技术相对于镜像技术的优势在于节省大量开销，但由于每次数据读写都要进行大量的校验运算，对计算机的运算速度要求很高，必须使用硬件 RAID 控制器。在数据重建恢复方面，检验技术比镜像技术复杂得多且慢得多。<br/>
海明校验码和 异或校验是两种最为常用的 数据校验算法。海明校验码是由理查德 · 海明提出的，不仅能检测错误，还能给出错误位置并自动纠正。海明校验的基本思想是：将有效信息按照某种规律分成若干组，对每一个组作奇偶测试并安排一个校验位，从而能提供多位检错信息，以定位错误点并纠正。可见海明校验实质上是一种多重奇偶校验。异或校验通过异或逻辑运算产生，将一个有效信息与一个给定的初始值进行异或运算，会得到校验信息。如果有效信息出现错误，通过校验信息与初始值的异或运算能还原正确的有效信息。<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">可管理性</h3>
<div class="outline-text-3" id="text-1-2">

<p>实际上， RAID 是一种虚拟化技术，它对多个物理磁盘驱动器虚拟成一个大容量的逻辑驱动器。对于外部主机系统来说， RAID 是一个单一的、快速可靠的大容量磁盘驱动器。这样，用户就可以在这个虚拟驱动器上来组织和存储应用系统数据。 从用户应用角度看，可使存储系统简单易用，管理也很便利。 由于 RAID 内部完成了大量的存储管理工作，管理员只需要管理单个虚拟驱动器，可以节省大量的管理工作。 RAID 可以动态增减磁盘驱动器，可自动进行数据校验和数据重建，这些都可以 大大简化管理工作。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">RAID等级</h3>
<div class="outline-text-3" id="text-1-3">


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">RAID0</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>RAID0 是一种简单的、无数据校验的数据条带化技术。<br/>
RAID0 的性能在所有 RAID 等级中是最高的。<br/>
不提供数据冗余保护，一旦数据损坏，将无法恢复。 因此， RAID0 一般适用于对性能要求严格但对数据安全性和可靠性不高的应用，如视频、音频存储、临时数据缓存空间等。<br/>
<img src="/img/raid0.png"  alt="/img/raid0.png" /><br/>
</p></div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">RAID1</h4>
<div class="outline-text-4" id="text-1-3-2">

<p>RAID1 称为镜像，它将数据完全一致地分别写到工作磁盘和镜像 磁盘，它的磁盘空间利用率为 50%<br/>
RAID1 与 RAID0 刚好相反，是为了增强数据安全性使两块 磁盘数据呈现完全镜像，从而达到安全性好、技术简单、管理方便。 RAID1 拥有完全容错的能力.<br/>
<img src="/img/raid1.png"  alt="/img/raid1.png" /><br/>
</p></div>

</div>

<div id="outline-container-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">RAID2</h4>
<div class="outline-text-4" id="text-1-3-3">

<p>RAID2 称为纠错海明码磁盘阵列，其设计思想是利用海明码实现数据校验冗余。海明码是一种在原始数据中加入若干校验码来进行错误检测和纠正的编码技术，其中第 2n 位（ 1, 2, 4, 8, … ）是校验码，其他位置是数据码。因此在 RAID2 中，数据按位存储，每块磁盘存储一位数据编码，磁盘数量取决于所设定的数据存储宽度，可由用户设定。图 4 所示的为数据宽度为 4 的 RAID2 ，它需要 4 块数据磁盘和 3 块校验磁盘。如果是 64 位数据宽度，则需要 64 块 数据磁盘和 7 块校验磁盘。可见， RAID2 的数据宽度越大，存储空间利用率越高，但同时需要的磁盘数量也越多。<br/>
海明码自身具备纠错能力，因此 RAID2 可以在数据发生错误的情况下对纠正错误，保证数据的安全性。它的数据传输性能相当高，设计复杂性要低于后面介绍的 RAID3 、 RAID4 和 RAID5 。<br/>
但是，海明码的数据冗余开销太大，而且 RAID2 的数据输出性能受阵列中最慢磁盘驱动器的限制。<br/>
<img src="/img/raid2.png"  alt="/img/raid2.png" /><br/>
</p></div>

</div>

<div id="outline-container-1-3-4" class="outline-4">
<h4 id="sec-1-3-4">RAID3</h4>
<div class="outline-text-4" id="text-1-3-4">

<p>使用专用校验盘的并行访问阵列，它采用一个专用的磁盘作为校验盘，其余磁盘作为数据盘，数据按位可字节的方式交叉存储到各个数据盘中。 RAID3 至少需要三块磁盘，不同磁盘上同一带区的数据作 XOR 校验，校验值写入校验盘中。 RAID3 完好时读性能与 RAID0 完全一致，并行从多个磁盘条带读取数据，性能非常高，同时还提供了数据容错能力。<br/>
目前， RAID5 算法不断改进，在大数据量读取时能够模拟 RAID3 ，而且 RAID3 在出现坏盘时性能会大幅下降，因此常使用 RAID5 替代 RAID3 来运行具有持续性、高带宽、大量读写特征的应用。<br/>
<img src="/img/raid3.png"  alt="/img/raid3.png" /><br/>
</p></div>

</div>

<div id="outline-container-1-3-5" class="outline-4">
<h4 id="sec-1-3-5">RAID4</h4>
<div class="outline-text-4" id="text-1-3-5">

<p>RAID4 与 RAID3 的原理大致相同，区别在于条带化的方式不同。 RAID4按照块的方式来组织数据.<br/>
RAID4 提供了 非常好的读性能，但单一的校验盘往往成为系统性能的瓶颈。对于写操作， RAID4 只能一个磁盘一个磁盘地写，并且还要写入校验数据，因此写性能比较差。而且随着成员磁盘数量的增加，校验盘的系统瓶颈将更加突出。正是如上这些限制和不足， RAID4 在实际应用中很少见，主流存储产品也很少使用 RAID4 保护。<br/>
</p></div>

</div>

<div id="outline-container-1-3-6" class="outline-4">
<h4 id="sec-1-3-6">RAID5</h4>
<div class="outline-text-4" id="text-1-3-6">

<p>RAID5 应该是目前最常见的 RAID 等级，它的原理与 RAID4 相似，区别在于校验数据分布在阵列中的所有磁盘上，而没有采用专门的校验磁盘。对于数据和校验数据，它们的写操作可以同时发生在完全不同的磁盘上。因此， RAID5 不存在 RAID4 中的并发写操作时的校验盘性能瓶颈问题。另外， RAID5 还具备很好的扩展性。当阵列磁盘 数量增加时，并行操作量的能力也随之增长，可比 RAID4 支持更多的磁盘，从而拥有更高的容量以及更高的性能。<br/>
当一个数据盘损坏时，系统可以根据同一条带的其他数据块和对应的校验数据来重建损坏的数据。与其他 RAID 等级一样，重建数据时， RAID5 的性能会受到较大的影响。<br/>
RAID5 兼顾存储性能、数据安全和存储成本等各方面因素，它可以理解为 RAID0 和 RAID1 的折中方案，是目前综合性能最佳的数据保护解决方案。 RAID5 基本上可以满足大部分的存储应用需求，数据中心大多采用它作为应用数据的保护方案。<br/>
<img src="/img/raid5.png"  alt="/img/raid5.png" /><br/>
</p>
<p><br/>
有人可能担心RAID5的可靠性，我试过，稳定性很好，同步完成后，拷贝数据上去，然后，随意的掉电，RAID5 组上的数据都没事。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3-7" class="outline-4">
<h4 id="sec-1-3-7">RAID6</h4>
<div class="outline-text-4" id="text-1-3-7">

<p>前面所 述的各个 RAID 等级都只能保护因单个磁盘失效而造成的数据丢失。如果两个磁盘同时发生故障，数据将无法恢复。 RAID6 （如图 8 ）引入双重校验的概念，它可以保护阵列中同时出现两个磁盘失效时，阵列仍能够继续工作，不会发生数据丢失。<br/>
</p></div>

</div>

<div id="outline-container-1-3-8" class="outline-4">
<h4 id="sec-1-3-8">RAID 组合等级</h4>
<div class="outline-text-4" id="text-1-3-8">

<p>标准 RAID 等级各有优势和不足。自然地，我们想到把多个 RAID 等级组合起来，实现优势互补，弥补相互的不足，从而达到在性能、数据安全性等指标上更高的 RAID 系统。<br/>
实际得到较为广泛应用的只有 RAID01 和 RAID10 两个等级。<br/>
RAID01 兼备了 RAID0 和 RAID1 的优点，它先用两块磁盘建立镜像，然后再在镜像内部做条带化。 RAID01 的数据将同时写入到两个磁盘阵列中，如果其中一个阵列损坏，仍可继续工作，保证数据安全性的同时又提高了性能。 RAID01 和 RAID10 内部都含有 RAID1 模式，因此整体磁盘利用率均仅为 50% 。<br/>
<img src="/img/raid10.png"  alt="/img/raid10.png" /><br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">linux上创建raid5</h3>
<div class="outline-text-3" id="text-1-4">

<p>4个硬盘，每个硬盘都化分为一个区。<br/>
创建raid5<br/>
</p>
<p><br/>
<pre class="src src-sh">mdadm --create /dev/md0 --level=5 --raid-devices=3 --spare-devices=1 /dev/sd[a-d]1
</pre>

创建RAID设备名为md0, 级别为RAID 5，使用3个设备建立RAID,空余一个做备用。<br/>
可以看来做raid只需要分区，所以一个硬盘可以分为多个分区，不同分区作为不同的raid type。<br/>
</p>
<p><br/>
查看raid信息<br/>
</p>
<p><br/>
<pre class="src src-sh">mdadm --detail /dev/md0
</pre>


513984 blocks [2/2] [UU]<br/>
The second line gives us some more information about the device. [2/2] [UU] tells us both partitions are used.<br/>
</p>
<p><br/>
让RAID开机启动.配置RIAD配置文件<br/>
</p>
<p><br/>
<pre class="src src-sh">mdadm --detail --scan &gt; /etc/mdadm.conf
</pre>

修改下，格式，去掉devices后的=。<br/>
<code>devices /dev/sda1,/dev/sdb1,/dev/sdc1,/dev/sdd1</code><br/>
</p>
<p><br/>
如果其中某个硬盘坏了会怎么样呢?系统会自动停止这块硬盘的工作,然后让后备的那块硬盘顶上去工作。我们可以实验下.<br/>
</p>
<p><br/>
<pre class="src src-sh">mdadm /dev/md0 --fail /dev/sdc1
cat /proc/mdstat&#25110;&#32773;mdadm --detail
</pre>


删除一个硬盘<br/>
<code>mdadm /dev/md0 --remove /dev/sdc1</code><br/>
</p>
<p><br/>
添加一个硬盘<br/>
<code>mdadm /dev/md0 --add /dev/sdc1</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">资料</h3>
<div class="outline-text-3" id="text-1-5">

<p><a href="http://blog.csdn.net/liuben/article/details/4581970">http://blog.csdn.net/liuben/article/details/4581970</a><br/>
</p>
<p><br/>
ubuntu使用raid的一个例子：<br/>
<a href="http://www.dedoimedo.com/computers/linux-raid.html">http://www.dedoimedo.com/computers/linux-raid.html</a><br/>
</p></div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2013/02/13/openldap/">OpenLDAP介绍</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-13T00:00:00+08:00" pubdate data-updated="true">2013年02月13日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">OpenLDAP介绍</a>
<ul>
<li><a href="#sec-1-1">LDAP 入门</a></li>
<li><a href="#sec-1-2">LDAP 目录结构</a>
<ul>
<li><a href="#sec-1-2-1">DN</a></li>
<li><a href="#sec-1-2-2">组织单元</a></li>
<li><a href="#sec-1-2-3">个别项</a></li>
<li><a href="#sec-1-2-4">对象类objectclass</a></li>
</ul>
</li>
<li><a href="#sec-1-3">配置openLDAP</a>
<ul>
<li><a href="#sec-1-3-1">rootdn</a></li>
<li><a href="#sec-1-3-2">AC</a></li>
</ul>
</li>
<li><a href="#sec-1-4">插入数据</a>
<ul>
<li><a href="#sec-1-4-1">LDIF 方法</a></li>
</ul>
</li>
<li><a href="#sec-1-5">参考资料</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/13/openldap/">OpenLDAP介绍</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">LDAP 入门</h3>
<div class="outline-text-3" id="text-1-1">

<p>首字母缩略 LDAP 代表轻量级目录访问协议（Lightweight Directory Access Protocol）。<br/>
信息被集中存储在服务器上的 LDAP 目录中。LDAP 目录是一种数据库；然而，它不是关系数据库。<br/>
它的目录或数据库的结构与 UNIX 文件系统非常相似： <br/>
数据按层次存储；有“根”或“基本 DN”（专有名称，Distinguished Name）；<br/>
目录被进一步细分成组织单元（Organization Units 或 OU）；<br/>
在这些 OU 中是包含数据的项。<br/>
这种树-叶结构不仅使 LDAP 变得可扩展， 而且当进行简单的搜索或查询时，比传统的关系数据库更快。<br/>
</p>
<p><br/>
LDAP 目录几乎可以存储所有类型的数据：电子邮件地址、DNS 信息、NIS 映射、安全性密钥、联系人信息列表和计算机名等。<br/>
可以通过 ACL（访问控制表，Access Control List）来控制对目录的访问。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">LDAP 目录结构</h3>
<div class="outline-text-3" id="text-1-2">


</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">DN</h4>
<div class="outline-text-4" id="text-1-2-1">

<p>LDAP 目录树的“根”或顶部是基本 DN。基本 DN 通常有两种形式：organization=（例如，o=syroidmanor.com）， 或者从组织的 DNS 域组件派生的 DN（dc=syroidmanor,dc=com）。<br/>
</p></div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">组织单元</h4>
<div class="outline-text-4" id="text-1-2-2">

<p>在目录基本 DN 的下面是容器或组织单元（OU），它们从逻辑上对您的数据进行分隔或分组。<br/>
</p>
<p><br/>
<pre class="example">dc=foobar,dc=com
                ou=customers
                        ou=northamerica
                        ou=southamerica
                        ou=asia
                        ou=europe
</pre>

</p></div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">个别项</h4>
<div class="outline-text-4" id="text-1-2-3">

<p>项只是存储属性的地方。<br/>
属性是可用来将一种类型的信息存储在目录中的容器。<br/>
每个属性都有一种类型和一个或多个值。<br/>
LDAP 目录中的每个项都有唯一的 DN，每个 DN 都由两部分组成 ―“相对专有名称”（或 RDN）和对 LDAP 目录结构中存储记录的位置的引用。 几乎存储在 LDAP 目录中的所有数据都有一个唯一名称，这个名称通常存储在 cn 属性中。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">对象类objectclass</h4>
<div class="outline-text-4" id="text-1-2-4">

<p>对象类由 LDAP 目录使用来定义给定类型的对象可以有哪些属性。对象类还定义项必须有什么属性， 以及项可以有什么属性。所有对象类都从其父对象类继承需求，然后添加它们自己的需求。<br/>
对象类有五个组件：OID（对象标识）、唯一名称、父对象（SUP）、任何需要的属性（MUST）和 允许的属性列表（MAY）。<br/>
如：<br/>
</p>
<p><br/>
<pre class="example">objectclass ( 2.5.6.6 NAME 'person' SUP top STRUCTURAL
        MUST ( sn $ cn )
        MAY ( userPassword $ telephoneNumber $ seeAlso $ description ) )
</pre>


</p></div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">配置openLDAP</h3>
<div class="outline-text-3" id="text-1-3">


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">rootdn</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>rootdn 项控制谁可以对目录数据库进行写操作，以及他们要这样做所必须提供的密码。<br/>
您在 rootdn 项的 cn= 部分填充的任何项都是对数据库有完全读／写访问权的用户。<br/>
如果您打算存储在目录中的数据只有一点点机密性，则对密码进行散列处理。可以用 slappasswd 实用程序完成它，如下所示：<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">AC</h4>
<div class="outline-text-4" id="text-1-3-2">


<p><br/>
<pre class="example">access to dn=".*,dc=syroidmanor,dc=com" attr=userPassword
        by dn="cn=root,dc=syroidmanor,dc=com" write
        by self write
        by * auth
access to dn=".*,dc=syroidmanor,dc=com" attr=mail
        by dn="cn=root,dc=syroidmanor,dc=com" write
        by self write
        by * read
</pre>

上面的配置仅允许 userPassword 属性的所有者修改项，但仅当所有者提供他或她的优先密码时才允许进行修改。 在所有其它情况下，只能出于认证目的来访问该项，而不能查看它。 第二个 access to&hellip; 项允许用户修改自己的电子邮件地址<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">插入数据</h3>
<div class="outline-text-3" id="text-1-4">


</div>

<div id="outline-container-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">LDIF 方法</h4>
<div class="outline-text-4" id="text-1-4-1">


<p><br/>
<pre class="example">dn: uid=juser,ou=people,dc=syroidmanor,dc=com
uid: juser
cn: Joe User
givenname: Joe
sn: User
mail: juser@syroidmanor.com
objectClass: top
objectClass: mailRecipient
objectClass: person
objectClass: inetOrgPerson
</pre>




</p></div>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">参考资料</h3>
<div class="outline-text-3" id="text-1-5">

<ol>
<li><a href="http://www.ibm.com/developerworks/cn/education/linux/l-ldap/section2.html">构建基于 LDAP 的地址簿</a><br/>
</li>
</ol>

</div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2013/02/13/openfiler/">Openfiler 2.99创建raid</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-13T00:00:00+08:00" pubdate data-updated="true">2013年02月13日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">openfiler 2.99创建raid</a>
<ul>
<li><a href="#sec-1-1">创建raid5</a>
<ul>
<li><a href="#sec-1-1-1">设置gpt</a></li>
<li><a href="#sec-1-1-2">分区</a></li>
<li><a href="#sec-1-1-3">设置raid标记</a></li>
<li><a href="#sec-1-1-4">在web上创建raid</a></li>
<li><a href="#sec-1-1-5">扩展</a></li>
</ul>
</li>
<li><a href="#sec-1-2">如果web上无法识别raid盘</a></li>
<li><a href="#sec-1-3">测试速度</a></li>
<li><a href="#sec-1-4">优缺点</a></li>
<li><a href="#sec-1-5">资料</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/13/openfiler/">openfiler 2.99创建raid</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
有人可能担心RAID5的可靠性，我试过，稳定性很好，同步完成后，拷贝数据上去，然后，随意的掉电，RAID5 组上的数据都没事。<br/>
OpenFiler读写性能很好，随便调整一下就能达到RAID5 下写130MB/S和读220MB/S的成绩，这个远远超过了FREENas的成绩。<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">创建raid5</h3>
<div class="outline-text-3" id="text-1-1">

<p>一个磁盘用于安装系统，其他3块作为raid5.<br/>
进入root<br/>
</p>
</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">设置gpt</h4>
<div class="outline-text-4" id="text-1-1-1">


<p><br/>
<pre class="src src-sh">parted /dec/sdb
mklabel
gpt
</pre>


</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">分区</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>整个磁盘化为一个分区，<br/>
<code>mkpart primary 0 -0</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">设置raid标记</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>设置为raid分区<br/>
<code>set 1 raid on</code><br/>
</p>
<p><br/>
同样操作于<br/>
<code>select /dev/sdc</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">在web上创建raid</h4>
<div class="outline-text-4" id="text-1-1-4">

<p>Volumes &gt; Software RAID:<br/>
Create the software RAID 5 with sdb1, sdc1 and sdd1.<br/>
</p>
<p><br/>
Create the vg0 volume group with /dev/md0<br/>
Create the lv0 volume, using full space and XFS.<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-5" class="outline-4">
<h4 id="sec-1-1-5">扩展</h4>
<div class="outline-text-4" id="text-1-1-5">

<p>如果要再添加两块硬盘，<br/>
</p>
<p><br/>
<pre class="src src-sh">[root@localhost]# mdadm --add /dev/md0 /dev/sde1 add the two disks to /dev/md0
[root@localhost]# mdadm --add /dev/md0 /dev/sdf1

[root@localhost]# mdadm --grow /dev/md0 --raid-devices=5 set the RAID to use the two new disks

In the OpenFiler WEBinterface, Wait for /dev/md0 to be Clean and Synchronized, then:

[root@localhost]# pvresize /dev/md0 resize the physical volume /dev/md0
</pre>


In the OpenFiler WEBinterface &gt; Volumes &gt; Manage Volumes &gt; Edit properties of lv0 to use full capacity.<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">如果web上无法识别raid盘</h3>
<div class="outline-text-3" id="text-1-2">

<p>首先需要把/dev/md0  mklabel为gpt<br/>
然后分区，mkpart primary ext2 <br/>
设置lvm flag<br/>
<code>set 1 LVM on</code><br/>
</p>
<p><br/>
手动添加卷组：<br/>
<code>vgcreate VG1 /dev/md0</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">测试速度</h3>
<div class="outline-text-3" id="text-1-3">

<p><code>dd if=/dev/zero of=tmpfile bs=1M count=10000</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">优缺点</h3>
<div class="outline-text-3" id="text-1-4">

<p>优点：<br/>
</p>
<p><br/>
1、兼容性很好，几乎可以识别所有的常见硬件，哪怕识别不了也可以装个REDHAT的驱动，REDHAT的驱动几乎是每个厂商都会提供的，上面那台HP SERVER RAID卡就是装了READHAT的驱动搞定的；<br/>
</p>
<p><br/>
2、性能强大，支持网卡捆绑，上门的PC-SERVER通过网络访问，可以实现RAID5的245MB/S的读写速度，和本地盘没啥区别，要不是受制于HP PCSERVER网卡数量不够的限制，网络服务应该还能实现更高的速度，本地测试RAID5超过400MB/S的读写速度；<br/>
</p>
<p><br/>
3、支持卷管理功能，支持在线扩展功能，支持按用户空间限制配置；<br/>
</p>
<p><br/>
4、内部带OPENLDAP,用户的认证通过OPENLDAP认证，安全性很高；<br/>
</p>
<p><br/>
5、支持WEB管理和系统监控，管理方便。<br/>
</p>
<p><br/>
缺点：<br/>
</p>
<p><br/>
1、页面管理功能要是没用过肯定一头雾水，监控管理功能很一般，只能算有吧；<br/>
</p>
<p><br/>
2、用户认证使用OPENLDAP，配置麻烦，我折腾了一个小时才搞定；<br/>
</p>
<p><br/>
3、不支持BT电驴什么的，虽然可以安装但是无法和WEB页面集成，感觉还是很不爽<br/>
</p>
<p><br/>
4、不知道为何精简了RPM命令和yum命令，要在上面装点东西很麻烦，要先装RPM才能进行下面的工作。<br/>
应该是改为了conary。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">资料</h3>
<div class="outline-text-3" id="text-1-5">

<ol>
<li>LDAP设置<br/>
   <a href="http://www.njeit.cn/show.aspx?id=831&amp;cid=65">http://www.njeit.cn/show.aspx?id=831&amp;cid=65</a><br/>

<p><br/>
</p></li>
<li>创建iscsi <br/>
   <a href="http://wenku.baidu.com/view/b51fdeedf8c75fbfc77db202.html">http://wenku.baidu.com/view/b51fdeedf8c75fbfc77db202.html</a><br/>
</li>
</ol>

</div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2013/02/13/octopress-install/">Octopress安装和定制</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-13T00:00:00+08:00" pubdate data-updated="true">2013年02月13日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">octopress安装和定制</a>
<ul>
<li><a href="#sec-1-1">ruby安装</a>
<ul>
<li><a href="#sec-1-1-1">touble shot：</a>
<ul>
<li><a href="#sec-1-1-1-1">在zsh中，启动rbenv init -会提示错误</a></li>
<li><a href="#sec-1-1-1-2">安装ruby rehash</a></li>
<li><a href="#sec-1-1-1-3">openssl</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-1-2">安装octopress</a></li>
<li><a href="#sec-1-3">Deploying to Github Pages</a>
<ul>
<li><a href="#sec-1-3-1">gh-pages</a></li>
</ul>
</li>
<li><a href="#sec-1-4">重新安装octopress</a></li>
<li><a href="#sec-1-5">安装主题</a></li>
<li><a href="#sec-1-6">配置</a></li>
<li><a href="#sec-1-7">个性化定制</a>
<ul>
<li><a href="#sec-1-7-1">邮箱地址图片化</a></li>
<li><a href="#sec-1-7-2">about分页</a></li>
<li><a href="#sec-1-7-3">添加友情链接</a></li>
<li><a href="#sec-1-7-4">侧边栏添加Disqus评论</a></li>
<li><a href="#sec-1-7-5">增加一键分享</a></li>
<li><a href="#sec-1-7-6">参考资料</a></li>
</ul>
</li>
<li><a href="#sec-1-8">使用了org-jekyll.el</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/13/octopress-install/">octopress安装和定制</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">ruby安装</h3>
<div class="outline-text-3" id="text-1-1">

<p>参考：<a href="http://octopress.org/docs/setup/">http://octopress.org/docs/setup/</a><br/>
一个是rvm，rbenv<br/>
rvm是出现最早功能最强大，但是有点复杂。<br/>
rbenv是37sigle功能推出的，比较受欢迎。<br/>
</p>
<p><br/>
rvm安装：<br/>
<code>curl -L https://get.rvm.io | bash -s stable --ruby</code><br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">'[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; . "$HOME/.rvm/scripts/rvm" # Load RVM function'</span> &gt;&gt; ~/.bash_profile
<span style="color: #a52a2a;">source</span> ~/.bash_profile

<span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">If using Zsh do this instead</span>
<span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">'[[ -s $HOME/.rvm/scripts/rvm ]] &amp;&amp; source $HOME/.rvm/scripts/rvm'</span> &gt;&gt; ~/.zshrc
<span style="color: #a52a2a;">source</span> ~/.zshrc
</pre>


rbenv安装：<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #a52a2a;">cd</span>
git clone git://github.com/sstephenson/rbenv.git .rbenv
<span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">'export PATH="$HOME/.rbenv/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile
<span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">'eval "$(</span><span style="color: #ff00ff;">rbenv</span><span style="color: #00bfff;"> init -)"'</span> &gt;&gt; ~/.bash_profile
git clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
<span style="color: #a52a2a;">source</span> ~/.bash_profile
</pre>


</p>
</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">touble shot：</h4>
<div class="outline-text-4" id="text-1-1-1">


</div>

<div id="outline-container-1-1-1-1" class="outline-5">
<h5 id="sec-1-1-1-1">在zsh中，启动rbenv init -会提示错误</h5>
<div class="outline-text-5" id="text-1-1-1-1">

<p><code>$HOME/.rbenv/libexec/../completions/rbenv.bash:14: command not found: complete</code><br/>
修改为：<br/>
</p>
<p><br/>
<pre class="src src-bash">eval <span style="color: #00bfff;">"$(rbenv init - zsh)"</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-1-1-2" class="outline-5">
<h5 id="sec-1-1-1-2">安装ruby rehash</h5>
<div class="outline-text-5" id="text-1-1-1-2">


<p><br/>
<pre class="src src-bash">rbenv install 1.9.3-p0
rbenv global 1.9.3-p0
rbenv rehash
</pre>


关于为什么要做rehash，解释如下：<br/>
新装的gem（以前重没装过）一定要rehash在.rbenv/shims下生成可执行程序，像zsh要自动补全还需要 hash -r ．不过因为　rbenv init -　里会调用rbenv rehash，所有新开个窗口是不需要的．我的用法是bundler管理gemset，在~/.bundle/config里设置BUNDLE_PATH为vendor/bundle , 配合shell的一个小函数为常用命令添加alias，在发现Gemset的时候自动加上bundle exec ( rbenv.zsh )．通过bundler安装bundle exec执行是不需要rehash的。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-1-3" class="outline-5">
<h5 id="sec-1-1-1-3">openssl</h5>
<div class="outline-text-5" id="text-1-1-1-3">

<p>启动时提示：<br/>
<code>require’: cannot load such file – openssl (LoadError)</code><br/>
解决办法：<br/>
apt-get install libssl-dev<br/>
重新安装ruby<br/>
<code>rbenv install 1.9.3-p0</code><br/>
</p>
<p><br/>
</p></div>
</div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">安装octopress</h3>
<div class="outline-text-3" id="text-1-2">


<p><br/>
<pre class="src src-sh">git clone git://github.com/imathis/octopress.git octopress
<span style="color: #a52a2a;">cd</span> octopress    <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">If you use RVM, You'll be asked if you trust the .rvmrc file (say yes).</span>
ruby --version  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Should report Ruby 1.9.3</span>
</pre>


遇到的问题，安装后我clone了octopress然后执行gem但缺少zlib库。<br/>
解决办法：<br/>
</p>
<p><br/>
<pre class="src src-sh">sudo apt-get install zlib1g-dev
rvm reinstall 1.9.3 <span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">&#37325;&#26032;&#23433;&#35013;ruby</span>
</pre>


安装依赖：<br/>
</p>
<p><br/>
<pre class="src src-sh">gem install bundler
rbenv rehash    <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">If you use rbenv, rehash to be able to run the bundle command</span>
bundle install
</pre>


</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">Deploying to Github Pages</h3>
<div class="outline-text-3" id="text-1-3">

<p>参考：<a href="http://octopress.org/docs/deploying/github/">http://octopress.org/docs/deploying/github/</a><br/>
</p>
<p><br/>
<code>rake setup_github_pages</code><br/>
他会做几件事：<br/>
</p><ol>
<li>询问你的github url<br/>
</li>
<li>把当前origin rename为imathis/octopress<br/>
</li>
<li>把你的github pages作为default origin remote<br/>
</li>
<li>从当前master分支转为source分支<br/>
</li>
<li>把master分支设置为_deploy目录，用于发布页面<br/>
</li>
</ol>


<p><br/>
然后运行<br/>
</p>
<p><br/>
<pre class="src src-sh">rake generate
rake deploy
</pre>

这会生成website在_deploy目录，然后提交到github。<br/>
</p>
<p><br/>
然后提交source分支<br/>
</p>
<p><br/>
<pre class="src src-sh">git add .
git commit -m <span style="color: #00bfff;">'your message'</span>
git push origin source
</pre>


</p>
</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">gh-pages</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>还可以通过project pages页面来部署，这样你的页面的访问地址为：<br/>
<code>http://username.github.com/project</code><br/>
适用于多个工程的情况，每个工程一个站点。<br/>
实际上显示时，github会搜索你工程下的gh-pages分支，作为显示。<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">重新安装octopress</h3>
<div class="outline-text-3" id="text-1-4">


<p><br/>
</p>
<p><br/>
<pre class="src src-sh">git clone -b source git@github.com:username/username.github.com.git octopress <span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">&#19979;&#36733;source&#29256;&#26412;&#65288;&#29992;&#20110;&#32534;&#36753;&#65289;</span>
<span style="color: #a52a2a;">cd</span> octopress
git clone git@github.com:username/username.github.com.git _deploy <span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">&#19979;&#36733;_deploy&#29256;&#26412;&#65288;&#29992;&#20110;&#21457;&#24067;&#65289;</span>
bundle install
</pre>


我是升级的octopress，所以我还是需要重复之前的安装过程，需要安装ruby，gem，bunlder等。<br/>
然后执行<br/>
<code>rake setup_github_pages</code><br/>
</p>
<p><br/>
rake install[theme]<br/>
安装一个主题，把github上的source中_post目录cp过来，以及修改的插件等手工合并进来，然后使用git push -f 强行push的。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">安装主题</h3>
<div class="outline-text-3" id="text-1-5">

<p>下载后放到.themes目录下，然后执行对应主题的安装，如：<br/>
rake install[&#8216;bootstrap&#8217;]<br/>
rake generate<br/>
</p>
<p><br/>
rake install\[&#8216;blanket&#8217;\]<br/>
有一点不好的是，code区显示不完全。还是有点缺憾。<br/>
</p>
<p><br/>
我目前使用的是：<br/>
bootstrap-theme虽然使用了bootstrap，基石很强大，但调整的不好。<br/>
文章和文章之间没有隔离，不方便区分。<br/>
还有就是字体使用的是固定px，13px行间距是18px，为什么不用em呢？<br/>
我尝试修改sass中的basefont为1em，但整体显示就乱了，有的code无法显示，所以干脆先这么用这吧。<br/>
</p>
<p><br/>
<a href="http://octopressthemes.com/themes/">主题下载页</a><br/>
<a href="https://github.com/bkutil/bootstrap-theme">https://github.com/bkutil/bootstrap-theme</a><br/>
<a href="http://www.cnblogs.com/hangxin1940/archive/2012/03/19/2806438.html">重新安装octopress</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">配置</h3>
<div class="outline-text-3" id="text-1-6">

<p>date_format: &#8220;%Y年%m月%d日&#8221;<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">个性化定制</h3>
<div class="outline-text-3" id="text-1-7">


</div>

<div id="outline-container-1-7-1" class="outline-4">
<h4 id="sec-1-7-1">邮箱地址图片化</h4>
<div class="outline-text-4" id="text-1-7-1">

<p>很多博主都将邮箱地址转化成图片，目的是为了防止垃圾邮件，我也赶了一下时髦。<br/>
</p>
<p><br/>
邮箱地址生成图片的网址是：<br/>
</p>
<p><br/>
<a href="http://services.nexodyne.com/email/index.php">http://services.nexodyne.com/email/index.php</a><br/>
<a href="http://pic.sdodo.com/tool/mailpic/">http://pic.sdodo.com/tool/mailpic/</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7-2" class="outline-4">
<h4 id="sec-1-7-2">about分页</h4>
<div class="outline-text-4" id="text-1-7-2">

<p>在source下新建about目录，并在里面添加index.markdown文件。<br/>
编辑导航条source/_includes/custom/navigation.html<br/>
注意:index.markdown文件需要加上头，否则会找不到。<br/>
</p>
<p><br/>
在侧边栏中a天际about me<br/>
在custom/asides/about.html中添加About Me信息<br/>
</p>
<p><br/>
<pre class="src src-html">&lt;<span style="color: #a020f0;">section</span>&gt;
  &lt;<span style="color: #a020f0;">h1</span>&gt;<span style="color: #ff0000; font-weight: bold; text-decoration: underline;">About Me</span>&lt;/<span style="color: #a020f0;">h1</span>&gt;
  &lt;<span style="color: #a020f0;">p</span>&gt;&lt;<span style="color: #a020f0;">img</span> <span style="color: #ff1493;">src</span>=<span style="color: #00bfff;">"/images/about.jpg"</span>&gt;&lt;/<span style="color: #a020f0;">p</span>&gt;
  &lt;<span style="color: #a020f0;">p</span>&gt;some thing&lt;/<span style="color: #a020f0;">p</span>&gt;
  &lt;<span style="color: #a020f0;">p</span>&gt;&lt;<span style="color: #a020f0;">a</span> <span style="color: #ff1493;">href</span>=<span style="color: #00bfff;">"mailto:emmoblin@gmail.com"</span>&gt;&lt;<span style="color: #a020f0;">img</span> <span style="color: #ff1493;">src</span>=<span style="color: #00bfff;">"/images/my_email.png"</span> <span style="color: #ff1493;">alt</span>=<span style="color: #00bfff;">"emmoblin@gmail.com"</span>&gt;&lt;/<span style="color: #a020f0;">a</span>&gt;&lt;/<span style="color: #a020f0;">p</span>&gt;
&lt;/<span style="color: #a020f0;">section</span>&gt;
</pre>


</p></div>

</div>

<div id="outline-container-1-7-3" class="outline-4">
<h4 id="sec-1-7-3">添加友情链接</h4>
<div class="outline-text-4" id="text-1-7-3">

<p>在custom/asides/blog_link.html中添加友情链接<br/>
</p>
<p><br/>
<pre class="src src-html">  &lt;<span style="color: #a020f0;">h1</span>&gt;<span style="color: #ff0000; font-weight: bold; text-decoration: underline;">&#22823;&#29275;&#21338;&#23458;</span>&lt;/<span style="color: #a020f0;">h1</span>&gt;
  &lt;<span style="color: #a020f0;">ul</span>&gt;
    &lt;<span style="color: #a020f0;">li</span>&gt;
      &lt;<span style="color: #a020f0;">a</span> <span style="color: #ff1493;">href</span>=<span style="color: #00bfff;">"http://coolshell.cn/"</span>&gt;&#37239;&#22771;CoolShell&lt;/<span style="color: #a020f0;">a</span>&gt;
    &lt;/<span style="color: #a020f0;">li</span>&gt;
    &lt;<span style="color: #a020f0;">li</span>&gt;
      &lt;<span style="color: #a020f0;">a</span> <span style="color: #ff1493;">href</span>=<span style="color: #00bfff;">"http://mindhacks.cn/"</span>&gt;&#21016;&#26410;&#40527;MIND HACKS&lt;/<span style="color: #a020f0;">a</span>&gt;
    &lt;/<span style="color: #a020f0;">li</span>&gt;
    &lt;<span style="color: #a020f0;">li</span>&gt;
      &lt;<span style="color: #a020f0;">a</span> <span style="color: #ff1493;">href</span>=<span style="color: #00bfff;">"http://blog.codingnow.com/"</span>&gt;&#20113;&#39118;&lt;/<span style="color: #a020f0;">a</span>&gt;
    &lt;/<span style="color: #a020f0;">li</span>&gt;
    &lt;<span style="color: #a020f0;">li</span>&gt;
      &lt;<span style="color: #a020f0;">a</span> <span style="color: #ff1493;">href</span>=<span style="color: #00bfff;">"http://www.cnblogs.com/Solstice/"</span>&gt;&#38472;&#30805;&lt;/<span style="color: #a020f0;">a</span>&gt;
    &lt;/<span style="color: #a020f0;">li</span>&gt;
  &lt;/<span style="color: #a020f0;">ul</span>&gt;
&lt;/<span style="color: #a020f0;">section</span>&gt;
</pre>


</p></div>

</div>

<div id="outline-container-1-7-4" class="outline-4">
<h4 id="sec-1-7-4">侧边栏添加Disqus评论</h4>
<div class="outline-text-4" id="text-1-7-4">

<p>在custom/asides/recent_comment.html中添加Disqus评论<br/>
</p>
<p><br/>
<pre class="src src-html">&lt;<span style="color: #a020f0;">section</span>&gt;
  &lt;<span style="color: #a020f0;">h1</span>&gt;<span style="color: #ff0000; font-weight: bold; text-decoration: underline;">&#36817;&#26399;&#35780;&#35770;</span>&lt;/<span style="color: #a020f0;">h1</span>&gt;
&lt;<span style="color: #a020f0;">script</span> <span style="color: #ff1493;">type</span>=<span style="color: #00bfff;">"text/javascript"</span> <span style="color: #ff1493;">src</span>=<span style="color: #00bfff;">"http://emmoblin.disqus.com/combination_widget.js?num_items=5&amp;hide_mods=0&amp;color=blue&amp;default_tab=recent&amp;excerpt_length=200"</span>&gt;&lt;/<span style="color: #a020f0;">script</span>&gt;&lt;<span style="color: #a020f0;">a</span> <span style="color: #ff1493;">href</span>=<span style="color: #00bfff;">"http://disqus.com/"</span>&gt;Powered by Disqus&lt;/<span style="color: #a020f0;">a</span>&gt;
&lt;/<span style="color: #a020f0;">section</span>&gt;
</pre>

</p></div>

</div>

<div id="outline-container-1-7-5" class="outline-4">
<h4 id="sec-1-7-5">增加一键分享</h4>
<div class="outline-text-4" id="text-1-7-5">

<p>我目前使用的是bshare。<br/>
</p>
<p><br/>
在_config.yml中增加bshare: true。 在“source_includes\post”下的sharing.html中增加如下代码.<br/>
上述的代码由bshare产生，可以自己选择所需的外观。 这样，在每一篇文章的最下方会出现一个分享的小工具。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7-6" class="outline-4">
<h4 id="sec-1-7-6">参考资料</h4>
<div class="outline-text-4" id="text-1-7-6">

<p><a href="http://octopress.org/docs/theme/template/">定制修改页面</a><br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">使用了org-jekyll.el</h3>
<div class="outline-text-3" id="text-1-8">

<p>我是使用org-mode来管理笔记的，使用了org-jekyll插件来把org笔记转化为jekyll的格式。<br/>
首先通过C-c C-e 把整个project进行export，生成cache。<br/>
之后org-jekyll-export-blog，根据cache的内容生成对应的octopress文件。<br/>
org-jekyll是根据～/.org_timestamp/的cache生成的。所以先要export project，之后再用org-jekyll。<br/>
</p>
<p><br/>
org-jekyll-export-current-entry 使用时光标所在entry进行导出。<br/>
</p>
<p><br/>
所有source/_posts目录下的html都可以重新生成，注意有的时候格式不对，比如title中不能包含中文，<br/>
会导致rake genernate错误。<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2013/02/13/lvm/">LVM介绍</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-13T00:00:00+08:00" pubdate data-updated="true">2013年02月13日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">LVM介绍</a>
<ul>
<li><a href="#sec-1-1">LVM基本术语</a></li>
<li><a href="#sec-1-2">创建和管理lvm</a>
<ul>
<li><a href="#sec-1-2-1">分区</a></li>
<li><a href="#sec-1-2-2">创建物理卷</a></li>
<li><a href="#sec-1-2-3">创建卷组</a></li>
<li><a href="#sec-1-2-4">激活卷组</a></li>
<li><a href="#sec-1-2-5">添加新的物理卷到卷组中</a></li>
<li><a href="#sec-1-2-6">查看物理卷信息</a></li>
<li><a href="#sec-1-2-7">从卷组中删除一个物理卷</a></li>
<li><a href="#sec-1-2-8">创建逻辑卷</a></li>
<li><a href="#sec-1-2-9">创建文件系统</a></li>
<li><a href="#sec-1-2-10">删除一个逻辑卷</a></li>
<li><a href="#sec-1-2-11">扩展逻辑卷大小</a></li>
<li><a href="#sec-1-2-12">减少逻辑卷大小</a></li>
<li><a href="#sec-1-2-13">灵活</a></li>
</ul>
</li>
<li><a href="#sec-1-3">snapshot</a></li>
<li><a href="#sec-1-4">lvm常用管理工具：</a></li>
<li><a href="#sec-1-5">参考</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/13/lvm/">LVM介绍</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。通过LVM系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组（volumegroup），形成一个存储池。管理员可以在卷组上随意创建逻辑卷组（logicalvolumes），并进一步在逻辑卷组上创建文件系统。管理员通过LVM可以方便的调整存储卷组的大小，并且可以对磁盘存储按照组的方式进行命名、管理和分配。<br/>
而且当系统添加了新的磁盘，通过LVM管理员就不必将磁盘的文件移动到新的磁盘上以充分利用新的存储空间，而是直接扩展文件系统跨越磁盘即可。<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">LVM基本术语</h3>
<div class="outline-text-3" id="text-1-1">

<p>物理存储介质（The physical media）<br/>
这里指系统的存储设备：硬盘，如：/dev/hda1、/dev/sda等等，是存储系统最低层的存储单元。 <br/>
</p>
<p><br/>
物理卷PV（physical volume）<br/>
物理卷就是指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与LVM相关的管理参数。 <br/>
</p>
<p><br/>
卷组VG（Volume Group）<br/>
LVM卷组类似于非LVM系统中的物理硬盘，其由物理卷组成。可以在卷组上创建一个或多个“LVM分区”（逻辑卷），LVM卷组由一个或多个物理卷组成。 <br/>
</p>
<p><br/>
逻辑卷LV（logical volume）<br/>
LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上可以建立文件系统(比如/home或者/usr等)。 <br/>
</p>
<p><br/>
PE（physical extent）<br/>
每一个物理卷被划分为称为PE(Physical Extents)的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是可配置的，默认为4MB。 <br/>
</p>
<p><br/>
LE（logical extent）<br/>
逻辑卷也被划分为被称为LE(Logical Extents) 的可被寻址的基本单位。在同一个卷组中，LE的大小和PE是相同的，并且一一对应。<br/>
</p>
<p><br/>
<img src="/img/lvm_vg.jpg"  alt="/img/lvm_vg.jpg" /><br/>
</p>
<p><br/>
VGDA（卷组描述符区域）<br/>
和非 LVM 系统将包含分区信息的元数据保存在位于分区起始位置的分区表中一样，逻辑卷以及卷组相关的元数据被保存在位于物理卷起始处的 VGDA 中。VGDA 包括以下内容：PV 描述符、VG 描述符、LV 描述符、和一些 PE 描述符。系统启动 LVM 时激活 VG，并将 VGDA 加载至内存，来识别 LV 的实际物理存储位置。当系统进行 I/O 操作时，就会根据 VGDA 建立的映射机制来访问实际的物理位置。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">创建和管理lvm</h3>
<div class="outline-text-3" id="text-1-2">


</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">分区</h4>
<div class="outline-text-4" id="text-1-2-1">

<p>使用分区工具（如：fdisk等）创建LVM分区，方法和创建其他一般分区的方式是一样的，区别仅仅是LVM的分区类型为8e。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">创建物理卷</h4>
<div class="outline-text-4" id="text-1-2-2">

<p>创建物理卷的命令为pvcreate，利用该命令将希望添加到卷组的所有分区或者磁盘创建为物理卷。<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">pvcreate /dev/hda5</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">创建卷组</h4>
<div class="outline-text-4" id="text-1-2-3">

<p>创建卷组的命令为vgcreate，将使用pvcreate建立的物理卷创建为一个完整的卷组：<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">vgcreate web_document /dev/hda5 /dev/hdb</span>
</pre>

vgcreate在创建卷组 web_document 以外，还设置使用大小为4 MB的PE（默认为4MB），这表示卷组上创建的所有逻辑卷都以 4 MB 为增量单位来进行扩充或缩减。由于内核原因，PE大小决定了逻辑卷的最大大小，4 MB 的PE决定了单个逻辑卷最大容量为 256 GB，若希望使用大于256G的逻辑卷则创建卷组时指定更大的PE。PE大小范围为8 KB 到 512 MB，并且必须总是 2 的倍数（使用-s指定）<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">激活卷组</h4>
<div class="outline-text-4" id="text-1-2-4">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">vgchange -ay web_document</span>
</pre>

</p></div>

</div>

<div id="outline-container-1-2-5" class="outline-4">
<h4 id="sec-1-2-5">添加新的物理卷到卷组中</h4>
<div class="outline-text-4" id="text-1-2-5">

<p>当系统安装了新的磁盘并创建了新的物理卷，而要将其添加到已有卷组时，就需要使用vgextend命令：<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">vgextend web_document /dev/hdc1</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-2-6" class="outline-4">
<h4 id="sec-1-2-6">查看物理卷信息</h4>
<div class="outline-text-4" id="text-1-2-6">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">pvdisplay /dev/hda1</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-2-7" class="outline-4">
<h4 id="sec-1-2-7">从卷组中删除一个物理卷</h4>
<div class="outline-text-4" id="text-1-2-7">

<p>要从一个卷组中删除一个物理卷，首先要确认要删除的物理卷没有被任何逻辑卷正在使用.<br/>
如果某个物理卷正在被逻辑卷所使用，就需要将该物理卷的数据备份到其他地方，然后再删除。<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">vgreduce web_document /dev/hda1</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-2-8" class="outline-4">
<h4 id="sec-1-2-8">创建逻辑卷</h4>
<div class="outline-text-4" id="text-1-2-8">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">lvcreate -L1500 &#8211;n www1 web_document</span>
</pre>

该命令就在卷组web_document上创建名字为www1，大小为1500M的逻辑卷，并且设备入口为/dev/web_document/www1<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-9" class="outline-4">
<h4 id="sec-1-2-9">创建文件系统</h4>
<div class="outline-text-4" id="text-1-2-9">

<p>推荐使用reiserfs文件系统，来替代ext2和ext3<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-10" class="outline-4">
<h4 id="sec-1-2-10">删除一个逻辑卷</h4>
<div class="outline-text-4" id="text-1-2-10">

<p>删除逻辑卷以前首先需要将其卸载，然后删除：<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">umount /dev/web_document/www1</span>
<span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">lvremove /dev/web_document/www1</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-2-11" class="outline-4">
<h4 id="sec-1-2-11">扩展逻辑卷大小</h4>
<div class="outline-text-4" id="text-1-2-11">

<p>LVM提供了方便调整逻辑卷大小的能力，扩大为12G<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">lvextend -L12G /dev/web_document/www1</span>
&#22686;&#21152;1G
<span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">lvextend -L+1G /dev/web_document/www1</span>
</pre>


增加了逻辑卷的容量以后，就需要修改文件系统大小以实现利用扩充的空间。笔者推荐使用reiserfs文件系统来替代ext2或者ext3。因此这里仅仅讨论reiserfs的情况。Reiserfs文件工具提供了文件系统大小调整工具：resize_reiserfs。对于希望调整被加载的文件系统大小：<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">resize_reiserfs -f /dev/web_document/www1</span>
</pre>


对于使用ext2或ext3文件系统的用户可以考虑使用工具<br/>
ext2resize。<br/>
<a href="http://sourceforge.net/projects/ext2resize">http://sourceforge.net/projects/ext2resize</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-12" class="outline-4">
<h4 id="sec-1-2-12">减少逻辑卷大小</h4>
<div class="outline-text-4" id="text-1-2-12">

<p>使用lvreduce即可实现对逻辑卷的容量，同样需要首先将文件系统卸载：<br/>
要先减少文件系统，然后再减少逻辑卷<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">umount /data/wwwroot</span>
<span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">resize_reiserfs -s-2G /dev/web_document/www1</span>
<span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">lvreduce -L-2G /dev/web_document/www1</span>
<span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">mount -treiserfs /dev/web_document/www1 /data/wwwroot</span>
</pre>

</p></div>

</div>

<div id="outline-container-1-2-13" class="outline-4">
<h4 id="sec-1-2-13">灵活</h4>
<div class="outline-text-4" id="text-1-2-13">

<p>逻辑卷可以再组合成pv，和vg，再次进行lvm。<br/>
而且一个卷组可以跨多个磁盘。<br/>
如果想自己做实验可以自己创建空洞文件进行lvm练习。<br/>
</p>
<p><br/>
<pre class="src src-sh">dd <span style="color: #ff1493;">if</span>=/dev/zore <span style="color: #ff1493;">of</span>=./loop1.img <span style="color: #ff1493;">bs</span>=1G <span style="color: #ff1493;">count</span>=0 <span style="color: #ff1493;">seek</span>=100
</pre>

这就创建了一个100G的稀疏文件，文件大小是100G，但占用的空间是0.<br/>
然后使用losetup进行加载。就可以当/dev/loop0 磁盘使用了。<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">snapshot</h3>
<div class="outline-text-3" id="text-1-3">

<p>lvm可以创建镜像，创建时选择创建允许多大的空间用于记录变化。<br/>
创建镜像后实际上就是和原始lv独立，但如果原始lv删掉了，则所有的snap也就丢失了。<br/>
snap和原始lv都可以后续修改，而且snap可以和原始lv进行合并，使原始lv变为snap当前的样子。<br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">lvm常用管理工具：</h3>
<div class="outline-text-3" id="text-1-4">


<p><br/>
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left">功能</td><td class="left">物理卷</td><td class="left">卷组</td><td class="left">逻辑卷</td></tr>
<tr><td class="left">扫描</td><td class="left">pvscan</td><td class="left">vgscan</td><td class="left">lvscan</td></tr>
<tr><td class="left">查看</td><td class="left">pvdisplay</td><td class="left">vgdisplay</td><td class="left">lvdisplay</td></tr>
<tr><td class="left">新建</td><td class="left">pvcreat</td><td class="left">vgcreat</td><td class="left">lvcreat</td></tr>
<tr><td class="left">卸载</td><td class="left">pvremove</td><td class="left">vgremove</td><td class="left">lvremove</td></tr>
<tr><td class="left">增大</td><td class="left">无</td><td class="left">vgextend</td><td class="left">lvextend</td></tr>
<tr><td class="left">减小</td><td class="left">无</td><td class="left">vgreduce</td><td class="left">lvreduce</td></tr>
</tbody>
</table>


<p><br/>
lvs<br/>
pvs<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">参考</h3>
<div class="outline-text-3" id="text-1-5">

<p><a href="http://blog.csdn.net/steelren/article/details/1931363">http://blog.csdn.net/steelren/article/details/1931363</a><br/>
</p>
<p><br/>
LVM-HOWTO<br/>
<a href="http://tldp.org/HOWTO/LVM-HOWTO/">http://tldp.org/HOWTO/LVM-HOWTO/</a><br/>
</p>
<p><br/>
一些操作例子<br/>
<a href="http://sapling.me/unixlinux/lvm_howto.html">http://sapling.me/unixlinux/lvm\_howto.html</a><br/>
</p></div>
</div>
</div>
</div>
  
  


    </article>
  
  <ul class="pager">
    
    <li class="previous"><a href="/blog/page/2/">&larr; Older</a></li>
    
    <li><a href="/blog/archives">Blog Archives</a></li>
    
  </ul>
</div>
<aside class="sidebar-nav span3">
  
    <section>
  <h1>About Me</h1>
  <p><img src="/images/my_avatar.jpg"></p>
  <p>网络安全行业，喜欢折腾linux，emacs,虚拟化</p>
  <p>只要活着就要为理想而奋斗</p>
  <p><a href="mailto:emmoblin@gmail.com"><img src="/images/my_email.png" alt="emmoblin@gmail.com"></a></p>
</section>
<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/blog/categories/bodybuilding'>bodybuilding (1)</a></li><li><a href='/blog/categories/emacs'>emacs (2)</a></li><li><a href='/blog/categories/git'>git (2)</a></li><li><a href='/blog/categories/ipv6'>ipv6 (1)</a></li><li><a href='/blog/categories/kernel'>kernel (1)</a></li><li><a href='/blog/categories/ksplice'>ksplice (1)</a></li><li><a href='/blog/categories/linux'>linux (1)</a></li><li><a href='/blog/categories/linuxcmd'>linuxcmd (1)</a></li><li><a href='/blog/categories/lisp'>lisp (2)</a></li><li><a href='/blog/categories/lua'>lua (4)</a></li><li><a href='/blog/categories/markdown'>markdown (3)</a></li><li><a href='/blog/categories/nat'>nat (1)</a></li><li><a href='/blog/categories/netfilter'>netfilter (1)</a></li><li><a href='/blog/categories/octopress'>octopress (3)</a></li><li><a href='/blog/categories/open-sources'>open sources (1)</a></li><li><a href='/blog/categories/orgmode'>orgmode (1)</a></li><li><a href='/blog/categories/service'>service (1)</a></li><li><a href='/blog/categories/shell'>shell (2)</a></li><li><a href='/blog/categories/skill'>skill (1)</a></li><li><a href='/blog/categories/ssh'>ssh (1)</a></li><li><a href='/blog/categories/storage'>storage (3)</a></li><li><a href='/blog/categories/test'>test (1)</a></li><li><a href='/blog/categories/testunit'>testunit (3)</a></li><li><a href='/blog/categories/tools'>tools (5)</a></li><li><a href='/blog/categories/ubuntu'>ubuntu (3)</a></li><li><a href='/blog/categories/unittest'>unittest (3)</a></li></ul>
</section>

<section>
<h1>新浪微博</h1>
<ul id="weibo">
<li>
<iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" 
src="http://widget.weibo.com/weiboshow/index.php?
language=&
width=0&
height=550&
fansRow=2&
ptype=1&
speed=0&
skin=5&
isTitle=1&
noborder=1&
isWeibo=1&
isFans=0&
uid=1905507693&
verifier=e659651a&
dpc=1"></iframe>
</li>
</ul>
</section>

<section>
  <h1>近期评论</h1>
<script type="text/javascript" src="http://emmoblin.disqus.com/combination_widget.js?num_items=5&hide_mods=0&color=blue&default_tab=recent&excerpt_length=200"></script><a href="http://disqus.com/">Powered by Disqus</a>
</section>
<section class="well">
  <ul id="recent_posts" class="nav nav-list">
    <li class="nav-header">Recent Posts</li>
    
      <li class="post">
        <a href="/blog/2013/02/19/ssh-tunnel/">ssh隧道技术</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/02/17/ipv6-nat-map66/">IPv6 NAT MAP66</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/02/14/goagent/">goagent翻墙</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/02/13/raid/">raid介绍</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/02/13/openldap/">OpenLDAP介绍</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo" class="page-footer"><hr>
<p>
  Copyright &copy; 2013 - emmoblin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'emmoblin';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
