<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Emmoblin Blog]]></title>
  <link href="http://emmoblin.github.com/atom.xml" rel="self"/>
  <link href="http://emmoblin.github.com/"/>
  <updated>2013-02-13T01:27:12+08:00</updated>
  <id>http://emmoblin.github.com/</id>
  <author>
    <name><![CDATA[emmoblin]]></name>
    <email><![CDATA[emmoblin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[先衰竭训练法]]></title>
    <link href="http://emmoblin.github.com/blog/2013/02/12/xian-shuai-jie-xun-lian-fa/"/>
    <updated>2013-02-12T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/02/12/xian-shuai-jie-xun-lian-fa</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">先衰竭训练法</a>
<ul>
<li><a href="#sec-1-1">先衰竭训练法</a></li>
<li><a href="#sec-1-2">胸大肌的先衰竭训练法</a></li>
<li><a href="#sec-1-3">三角肌的先衰竭训练法：</a></li>
<li><a href="#sec-1-4">肱三头肌的先衰竭训练法</a></li>
<li><a href="#sec-1-5">竖脊肌（后腰）的先衰竭训练法</a></li>
<li><a href="#sec-1-6">大腿的先衰竭训练法</a></li>
<li><a href="#sec-1-7">背阔肌的先衰竭训练法</a></li>
<li><a href="#sec-1-8">总结</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/12/xian-shuai-jie-xun-lian-fa/">先衰竭训练法</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">先衰竭训练法</h3>
<div class="outline-text-3" id="text-1-1">

<p>先衰竭法是目前增大肌肉围径的有效方法。<br/>
其做法是要想发展那块肌肉，先选择只发展这块肌肉的局部肌肉练习来训练，做8-10次直到疲劳，使其衰竭，然后在3-5秒之内跑向另一器械，做一个以发展这块肌肉为主的综合肌肉群练习，用70％的重量做到极限，这样交替训练4组左右，肌肉会感受到极大的刺激。据研究，这样能有效地刺激肌肉生长，促进其发育。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">胸大肌的先衰竭训练法</h3>
<div class="outline-text-3" id="text-1-2">

<p>发达胸大肌的局部有效练习：仰卧飞鸟；<br/>
发达胸大肌综合肌群的练习：卧推（包括宽握、中握、窄握），它除了发展胸大肌外，还能发展肱三头肌、三角肌前部和前锯肌。<br/>
</p>
<p>  <br/>
先用只能举8-10次的重量做仰卧飞鸟练习，直到起不来，<br/>
紧接着跑到卧推架前用事先准备好的60-70％重量做卧推，尽力举次数，直到起不来算一组，<br/>
共做4组左右，累计总运动量为8组约50次左右。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">三角肌的先衰竭训练法：</h3>
<div class="outline-text-3" id="text-1-3">

<p>发达三角肌的局部肌肉练习：哑铃前平举 主要发展三角肌前束；哑铃侧平举主要发展三角肌中束；俯身后斜举主要发展三角肌后束。<br/>
发达三角肌的综合练习：颈后宽推，这个练习既能发展三角肌，还能发展肱三头肌，对胸大肌、前锯肌也有影响。<br/>
</p>
<p>  <br/>
为发达三角肌将这两个有效练习有机地结合在一起训练，其效果会更好。<br/>
每组动作：是先用只能平举8-10次的重量做哑铃来练习。直到起不来，紧接着跑到放置在另一侧的杠铃前，用做（70％），直到一个起不来算一大组，共做4大组。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">肱三头肌的先衰竭训练法</h3>
<div class="outline-text-3" id="text-1-4">

<p>发达肱三头肌的局部肌肉练习：各种臂屈伸，如颈后臂屈伸、弓身臂屈伸等<br/>
发达肱三头肌的综合练习：是窄卧推<br/>
</p>
<p> <br/>
先做颈后臂屈伸6-10次直到疲劳，然后迅速跑向深蹲架前拿起架上事先放好的杠铃（杠铃重量为自己最高重量的60-70％），<br/>
连续举直到起不来，这样两种练习算一大组，共做4大组，肱三头肌就会很胀，刺激很深。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">竖脊肌（后腰）的先衰竭训练法</h3>
<div class="outline-text-3" id="text-1-5">

<p>发达后腰竖脊肌的局部肌肉练习：负重山羊挺身<br/>
发达后腰竖脊肌的综合练习：弓身、屈腿硬拉等。<br/>
</p>
<p><br/>
<img src="http://emmoblin.github.com/img/shanyangtingshen.gif"  alt="/img/shanyangtingshen.gif" /><br/>
先在山羊上做负重挺身6-10次直到挺不起为止，紧接着跑向深蹲架前肩负杠铃做弓身练习（或做硬拉），直到疲劳。将这两个练习组合在一起训练4组，背肌就能得到很好的刺激。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">大腿的先衰竭训练法</h3>
<div class="outline-text-3" id="text-1-6">

<p>发达股四头肌的局部肌肉练习：负重腿屈伸<br/>
发达腿部肌肉的综合肌群练习：深蹲，<br/>
<img src="http://emmoblin.github.com/img/qutui.gif"  alt="/img/qutui.gif" /><br/>
</p>
<p><br/>
尽力做8次左右负重腿屈伸，紧接着做也尽力做6-8次深蹲，这样交叉轮换做8组（4大组）约50次，股四头肌就会因刺激较深而发胀。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">背阔肌的先衰竭训练法</h3>
<div class="outline-text-3" id="text-1-7">

<p>发达背阔肌的局部肌肉练习：宽握颈后引体向上<br/>
发达背阔肌的综合练习：坐姿划船<br/>
</p>
<p> <br/>
先宽握颈后引体向上10-15次直到拉不起为止，紧接着跑向做坐姿划船练习，直到疲劳。将这两个练习组合在一起训练4组，背阔肌就能得到很好的刺激。 <br/>
</p>
<p> <br/>
</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">总结</h3>
<div class="outline-text-3" id="text-1-8">

<p>先衰竭原理之所以先进，从理论上讲它符合极限负荷后的超量恢复的原则。<br/>
这是因为肌体精疲力竭地负荷之后，首先功能能力大大减退，紧接着在恢复防疲肌体由适应一提高，超过它原有的水平。<br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux_3g拨号]]></title>
    <link href="http://emmoblin.github.com/blog/2013/01/06/linux-g-dial/"/>
    <updated>2013-01-06T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/01/06/linux-g-dial</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">linux下3g网卡拨号</h3>
<div class="outline-text-3" id="text-1-1">

<p>需要安装的软件usb_modeswitch,wvdial<br/>
usb_modeswitch用于将usb3g转换为usb modem模式，这样才能拨号。最好到官网下载最新代码，包含的3g网卡类型会更全。最主要的就是usb_modeswitch_data。<br/>
<a href="http://www.draisberghof.de/usb_modeswitch/#download">http://www.draisberghof.de/usb\_modeswitch/#download</a><br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">安装usb_modeswitch_data</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>进入目录，执行<br/>
sudo make install<br/>
会安装对应的udev文件到/lib/udev/rules.d目录。<br/>
</p>
<p><br/>
不过我发现自动转换没有效果，暂时先不查了。<br/>
直接使用命令行转：<br/>
usb_modeswitch -c /etc/usb_modeswitch.conf<br/>
如果转换成功会出现/dev/ttyUSB0-3，dmesg也会有输出信息。<br/>
</p>
<p><br/>
usb_modeswitch.conf<br/>
</p>
<p><br/>
<pre class="example">######################################################## 
# ZTE A371B
#
# Contributor: Wang Lei

DefaultVendor= 0x19d2
DefaultProduct=0x0169

TargetVendor=  0x19d2
TargetProduct= 0x0170

MessageContent="5553424312345678000000000000061b000000020000000000000000000000"
NeedResponse=1
</pre>


</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">wvdial</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>这个难了，wvdial负责发送AT命令给usb modem，进行拨号。但不同的3g卡发送的指令也不一样。<br/>
我是在xp上安装了usb抓包软件，把xp上官方的3g拨号过程进行了抓包分析，提取出如下序列：<br/>
</p>
<p><br/>
</p>
<p><br/>
<pre class="example">[Dialer Defaults]
Init1 = AT
Init2 = AT+CIMI
Init3 = AT+CMEE=1
Init4 = ATE0
Init5 = AT+CFUN=1
Init6 = AT+CLCK="SC",2
Init7 = AT+cgdcont=1,"ip","CMNET"
Modem Type = USB Modem
Baud = 460800
New PPPD = yes
Modem = /dev/ttyUSB0
ISDN = 0
Phone = *98*1#
Password = any
Username = any
Stupid Mode = 1
</pre>



</p></div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">遇到的问题</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>我的x230上无线鼠标的usb接收器貌似总是捣乱，拔了接收器，换了个usb口插3g，就可以ok了。<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[fstab恢复]]></title>
    <link href="http://emmoblin.github.com/blog/2013/01/01/fstab-recover/"/>
    <updated>2013-01-01T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/01/01/fstab-recover</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">fstab恢复</h3>
<div class="outline-text-3" id="text-1-1">

<p>不小心配置fstab结果参数写错了，导致重启后无法挂载，系统进不去。<br/>
从grub进入recover模式，选择进入root。<br/>
但此时根文件系统挂载的是只读的，所以无法修改fstab。<br/>
重新挂载为rw就ok了，非常关键。<br/>
mount -n -o remount,rw /<br/>
之后就可以修改了fstab了。<br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git服务器开源软件]]></title>
    <link href="http://emmoblin.github.com/blog/2012/12/18/git-server/"/>
    <updated>2012-12-18T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/12/18/git-server</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">git服务器开源软件</a>
<ul>
<li><a href="#sec-1-1">在服务器上部署git</a>
<ul>
<li><a href="#sec-1-1-1">通过git账户访问</a></li>
<li><a href="#sec-1-1-2">gitweb</a></li>
<li><a href="#sec-1-1-3">repo</a></li>
<li><a href="#sec-1-1-4">代码抽取</a></li>
<li><a href="#sec-1-1-5">分支合并</a></li>
<li><a href="#sec-1-1-6">git submodule</a></li>
<li><a href="#sec-1-1-7">gitk</a></li>
<li><a href="#sec-1-1-8">git log &ndash;graph</a></li>
<li><a href="#sec-1-1-9">git help workflows</a></li>
</ul>
</li>
<li><a href="#sec-1-2">GITolite</a></li>
<li><a href="#sec-1-3">gerrit</a></li>
<li><a href="#sec-1-4">Jenkins</a></li>
<li><a href="#sec-1-5">git权限控制理解</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/12/18/git-server/">git服务器开源软件</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">在服务器上部署git</h3>
<div class="outline-text-3" id="text-1-1">

<p>git clone &ndash;bare my_project my_project.git<br/>
其实 clone 操作基本上相当于 git init 加 git fetch。<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">通过git账户访问</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>第二个办法是在主机上建立一个 git 账户，让每个需要写权限的人发送一个 SSH 公钥，然后将其加入 git 账户的~/.ssh/authorized_keys 文件。这样一来，所有人都将通过 git 账户访问主机。这丝毫不会影响提交的数据 — 访问主机用的身份不会影响提交对象的提交者信息。<br/>
</p>
<p><br/>
$ sudo adduser git<br/>
$ su git<br/>
$ cd<br/>
$ mkdir .ssh<br/>
</p>
<p><br/>
只要把它们逐个追加到 authorized_keys 文件尾部即可：<br/>
</p>
<p><br/>
$ cat <i>tmp/id_rsa.john.pub &gt;&gt; ~</i>.ssh/authorized_keys<br/>
$ cat <i>tmp/id_rsa.josie.pub &gt;&gt; ~</i>.ssh/authorized_keys<br/>
$ cat <i>tmp/id_rsa.jessica.pub &gt;&gt; ~</i>.ssh/authorized_keys<br/>
现在可以用 &ndash;bare 选项运行 git init 来建立一个裸仓库，这会初始化一个不包含工作目录的仓库。<br/>
</p>
<p><br/>
$ cd /opt/git<br/>
$ mkdir project.git<br/>
$ cd project.git<br/>
$ git &ndash;bare init<br/>
这时，Join，Josie 或者 Jessica 就可以把它加为远程仓库，推送一个分支，从而把第一个版本的项目文件上传到仓库里了。值得注意的是，每次添加一个新项目都需要通过 shell 登入主机并创建一个裸仓库目录。<br/>
$ cd myproject<br/>
$ git init<br/>
$ git add .<br/>
$ git commit -m &#8216;initial commit&#8217;<br/>
$ git remote add origin git@gitserver:/opt/git/project.git<br/>
$ git push origin master<br/>
作为一个额外的防范措施，你可以用 Git 自带的 git-shell 工具限制 git 用户的活动范围。只要把它设为git 用户登入的 shell，那么该用户就无法使用普通的 bash 或者 csh 什么的 shell 程序。编辑 /etc/passwd 文件：<br/>
</p>
<p><br/>
在其他人机子上可以直接clone<br/>
git clone git@gitserver:/opt/git/project.git<br/>
</p>
<p><br/>
$ sudo vim /etc/passwd<br/>
在文件末尾，你应该能找到类似这样的行：<br/>
</p>
<p><br/>
git:x:1000:1000::/home/git:/bin/sh<br/>
把 bin/sh 改为 /usr/bin/git-shell （或者用 which git-shell 查看它的实际安装路径）。该行修改后的样子如下：<br/>
</p>
<p><br/>
git:x:1000:1000::/home/git:/usr/bin/git-shell<br/>
</p>
<p><br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">gitweb</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>git自带的cgi脚本<br/>
git instaweb &ndash;httpd=lighttpd<br/>
</p>
<p> <br/>
</p></div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">repo</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>git仓库太大会导致git操作很慢，那么分成多个子项目，用repo来管理。<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">代码抽取</h4>
<div class="outline-text-4" id="text-1-1-4">

<p>git cherry-pick &lt;commit&gt;<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-5" class="outline-4">
<h4 id="sec-1-1-5">分支合并</h4>
<div class="outline-text-4" id="text-1-1-5">

<p>git merge<br/>
git rebase &lt;upstream&gt; [&lt;branch&gt;]<br/>
rebase 可以让你看起来是基于最新的代码实现的改动。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-6" class="outline-4">
<h4 id="sec-1-1-6">git submodule</h4>
<div class="outline-text-4" id="text-1-1-6">

<p>子模块允许你将一个git仓库当作另一个git仓库的子目录。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-7" class="outline-4">
<h4 id="sec-1-1-7">gitk</h4>
<div class="outline-text-4" id="text-1-1-7">

<p>安装apt-get install gitk<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-8" class="outline-4">
<h4 id="sec-1-1-8">git log &ndash;graph</h4>
<div class="outline-text-4" id="text-1-1-8">

<p>可以添加到git的配置文件中<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-9" class="outline-4">
<h4 id="sec-1-1-9">git help workflows</h4>
<div class="outline-text-4" id="text-1-1-9">

<p>查看推荐的工作流<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">GITolite</h3>
<div class="outline-text-3" id="text-1-2">

<p>Gitolite 是一款 Perl 语言开发的 Git 服务管理工具，通过公钥对用户进行认证，并能够通过配置文件对写操作进行基于分支和路径的的精细授权。GITolite 采用的是SSH协议，并需要使用公钥 验证。也就是说 GITolite会根据管理员预先定义好的设置，根据客户的SSH，对于来自不同客户端的请求进行权限控制，只读，或者读写，甚至于精确到某个文件夹，某个文件的权限。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">gerrit</h3>
<div class="outline-text-3" id="text-1-3">

<p>前面我们说到了对Gitolite是对于开发人员的一种授权，但一旦保证了授权，就能够保证版本库的稳定吗？如果获得授权的人乱搞代码，或者改错代码，那版本库照样会出现不稳定的情况的。就像前面在敏捷系列里面说到的一样，在代码改动之后，要引入code review (代码审阅，说code review 比较顺口，还是用code review吧)。在Clearcase条件下，code review是需要把别人的代码整进去版本库之后，再由code reviewer拿下来看的。于是在Google Android项目的开发过程当中，Google为GIT带来了又一个伟大的工具-Gerrit，也有人叫Gerrit2，因为现在用的Gerrit跟Google刚开始整的时候有很大的不同，我们暂且叫它Gerrit就可以。<br/>
Gerrit有两个很牛的功能，第一是权限管理，它提供了一个跟GITolite一样的功能，管理用户的读写权限。但它比GITolite好用，对权限的控制都在它提供的网页系统里面完成，不用push啥的！第二是Gerrit为GIT带来强制性的code review，除非你某某是管理员。任何的代码改动都需要有人approve之后，这个代码改动才有可能进入公共代码库，如果没有经过approve或者被人reject了，即使你已经push了五百年，这代码依旧进不了公共版本库。而且 相比起裸奔时代的code review，Gerrit提供一个在线review 的系统，所有的操作都在它提供的系统上面点点点就能搞定的。<br/>
首先我们来看看权限控制，Gerrit有10种不同的权限，其中有读写权限，code review的权限等等。每个权限的设置包括两部分：权限本身，以及权限授予的组。<br/>
</p>
<p><br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">Jenkins</h3>
<div class="outline-text-3" id="text-1-4">

<p>如果用了Gerrit，那么每一个代码改动都要经过code review approve 并且要验证。code review还好说，可验证就麻烦了。如果每个改动都要人手拿到本地，至少去确保能编译通过吧，那谁都会疯了的！！！话说IT人的精品特质之一就是懒，所以有繁琐的地方<br/>
 往往都会产生自动化 （这貌似也是工业能够向前发展，甚至于社会能够向前发展的一个因素哦，要发扬发扬）。Jenkins就应运而生了。<br/>
Jenkins， 曾用名Hudson，是基于Java开发的持续集成的工具。它能够自动监控到公共代码库的版本变更，并且执行我们预先定义好的动作。在动作完成之后，把动作执行的结果回传给有关部门！比如我们可以让Jenkins监听Gerrit上面的代码变更情况，看有没有人提出code review的请求。如果监听到请求，那么Jenkins就偷偷向Gerrit要那个人改了的代码，试着做一些编译以及单元测试。如果这人很牛叉，测试通过。那么Jenkins会告诉Gerrit ：“喂，这条友很牛哦，我向毛主席保证，TA的代码改动没有问题”，这时Gerrit就跑过去将这个review item的 verify设置为+1，如果不通过，那就铁面无私地给一个 verify-1.<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">git权限控制理解</h3>
<div class="outline-text-3" id="text-1-5">

<p>从技术上讲，git可能永远也做不到类似svn的路径授权(读权限)<br/>
如果允许按照路径授权，则各个克隆的关系不再是平等的，有的内容多有的内容少，分布式的理念被破坏。<br/>
git的授权模型只能实现非零即一的方式，要不拥有全部写权限，要不没有写权限。<br/>
要么拥有全部库的读权限，o要么禁用。<br/>
</p>
<p><br/>
看来git的保密性确实不好，要不一视同仁，大家都有全部代码，要不把代码分成多个库。<br/>
这样看来在公司内部使用git确实不太方便了。公司最基本的要求就是代码的保护。<br/>
</p>
<p><br/>
Git对于写操作可以精细到目录和分支级别（使用Gitolite作为服务器）， 但作为分布式版本库控制系统，在设计上只能实现版本库量子化的读授权。 即某用户对整个版本库要么都能读，要么对整个版本库都不能读。<br/>
</p>
<p><br/>
那么如何控制Git版本库的读授权呢？实际上Git可以通过子模组来实现细粒度的读授权。 即在项目需要精细授权的场合，将版本库拆分为多个Git版本库进行单独授权， 再使用子模组将多个版本库整合为一个。这个操作并不复杂，而且有助于实现项目的模块化。<br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[shell代码片段收集]]></title>
    <link href="http://emmoblin.github.com/blog/2012/12/05/shell-snippet-collect/"/>
    <updated>2012-12-05T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/12/05/shell-snippet-collect</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">shell代码片段收集</a>
<ul>
<li><a href="#sec-1-1">获取磁盘大小</a></li>
<li><a href="#sec-1-2">变为大写</a></li>
<li><a href="#sec-1-3">判断返回值</a></li>
<li><a href="#sec-1-4">提问</a></li>
<li><a href="#sec-1-5">for循环</a></li>
<li><a href="#sec-1-6">while and until</a></li>
<li><a href="#sec-1-7">case</a></li>
<li><a href="#sec-1-8">读取文件</a></li>
<li><a href="#sec-1-9">awk按域搜索的例子</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/12/05/shell-snippet-collect/">shell代码片段收集</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">获取磁盘大小</h3>
<div class="outline-text-3" id="text-1-1">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Return the size of the drive in MB</span>
get_drive_size () {
  <span style="color: #ff1493;">ldrive</span>=$<span style="color: #ff1493;">1</span>

  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Make sure you can print disk info using parted</span>
  parted --script /dev/$<span style="color: #ff1493;">ldrive</span> print &gt;/dev/null 2&gt;&amp;1

  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">If unable to read disk, it's likely it needs a disklabel</span>
  <span style="color: #0000ff;">if</span> [  <span style="color: #00bfff;">"$?"</span> != <span style="color: #00bfff;">"0"</span> ]; <span style="color: #0000ff;">then</span>
    <span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">"Creating a new disklabel on $ldrive"</span> &gt;&gt; $<span style="color: #ff1493;">INSTALL_LOG</span>
    <span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">"parted /dev/$ldrive mklabel msdos"</span> &gt;&gt; $<span style="color: #ff1493;">INSTALL_LOG</span>
    <span style="color: #ff1493;">output</span>=$(<span style="color: #ff00ff;">parted</span> -s /dev/$<span style="color: #ff1493;">ldrive</span> mklabel msdos)

    <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Get the drive size from parted</span>
    <span style="color: #ff1493;">lsize</span>=$(<span style="color: #ff00ff;">parted</span> -s /dev/$<span style="color: #ff1493;">ldrive</span> p | grep <span style="color: #00bfff;">"^Disk"</span> | awk <span style="color: #00bfff;">'{ print $3 }'</span>)

    <span style="color: #0000ff;">if</span> [ $(<span style="color: #ff00ff;">echo</span> $<span style="color: #ff1493;">lsize</span> | grep error) ]; <span style="color: #0000ff;">then</span>
      <span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">"Unable to read disk label.  Exiting."</span>
      <span style="color: #0000ff;">exit</span> 1
    <span style="color: #0000ff;">fi</span>
  <span style="color: #0000ff;">fi</span>

  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Get the drive size from parted</span>
  <span style="color: #ff1493;">lsize</span>=$(<span style="color: #ff00ff;">parted</span> -s /dev/$<span style="color: #ff1493;">ldrive</span> p | grep <span style="color: #00bfff;">"^Disk"</span> | awk <span style="color: #00bfff;">'{ print $3 }'</span>)
  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Get the reported units (mB, GB, kB)</span>
  <span style="color: #ff1493;">lmodifier</span>=$(<span style="color: #ff00ff;">echo</span> $<span style="color: #ff1493;">lsize</span> | sed <span style="color: #00bfff;">'s/[0-9\.]//g'</span>)
  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">remove the modifier</span>
  <span style="color: #ff1493;">lsize</span>=$(<span style="color: #ff00ff;">echo</span> $<span style="color: #ff1493;">lsize</span> | sed <span style="color: #00bfff;">'s/[a-z,A-Z]//g'</span>)
  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Remove any fractions</span>
  <span style="color: #ff1493;">lsize</span>=$(<span style="color: #ff00ff;">echo</span> $<span style="color: #ff1493;">lsize</span> | cut -f1 -d<span style="color: #00bfff;">'.'</span>)
  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Translate our size into mB if not there already</span>
  <span style="color: #0000ff;">if</span> [ $<span style="color: #ff1493;">lmodifier</span> = <span style="color: #00bfff;">"GB"</span> ]; <span style="color: #0000ff;">then</span> 
    <span style="color: #ff1493;">lsize</span>=$(($<span style="color: #ff1493;">lsize</span> * 1000))
  <span style="color: #0000ff;">elif</span> [ $<span style="color: #ff1493;">lmodifier</span> = <span style="color: #00bfff;">"kB"</span> ]; <span style="color: #0000ff;">then</span> 
    <span style="color: #ff1493;">lsize</span>=$(($<span style="color: #ff1493;">lsize</span> / 1000))
  <span style="color: #0000ff;">fi</span>

  <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">lsize</span>
}

</pre>


disk_size=`fdisk -l $CF | grep MB | cut -d&#8221;:&#8221; -f2 | cut -d &#8220;,&#8221; -f1| sed s/MB//g `<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">变为大写</h3>
<div class="outline-text-3" id="text-1-2">


<p><br/>
<pre class="src src-sh">upper_str()
{
        <span style="color: #ff1493;">upper</span>=<span style="color: #ff00ff;">`echo $1 | tr "[a-z]" "[A-Z]"`</span>
        <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">upper</span>
}
</pre>


</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">判断返回值</h3>
<div class="outline-text-3" id="text-1-3">


<p><br/>
<pre class="src src-sh"><span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">TOS_VERSION</span> | grep <span style="color: #00bfff;">"^3.3.016"</span> 
<span style="color: #0000ff;">if</span> [  $? != 0  ]
<span style="color: #0000ff;">then</span> 
        <span style="color: #ff1493;">VERSION_016</span>=<span style="color: #00bfff;">"false"</span>
<span style="color: #0000ff;">else</span>
        <span style="color: #ff1493;">VERSION_016</span>=<span style="color: #00bfff;">"true"</span>
<span style="color: #0000ff;">fi</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">提问</h3>
<div class="outline-text-3" id="text-1-4">


<p><br/>
<pre class="src src-sh">auto_echo <span style="color: #00bfff;">"Are you sure to begin[y/n]:"</span>
<span style="color: #0000ff;">while </span><span style="color: #a52a2a;">read</span> answer
<span style="color: #0000ff;">do</span>
<span style="color: #ff1493;">answer</span>=<span style="color: #ff00ff;">`upper_str $answer`</span>
<span style="color: #0000ff;">if</span> [ <span style="color: #00bfff;">"$answer"</span> = <span style="color: #00bfff;">"Y"</span> ] 
<span style="color: #0000ff;">then</span>
<span style="color: #0000ff;">break</span>
<span style="color: #0000ff;">elif</span> [ <span style="color: #00bfff;">"$answer"</span> = <span style="color: #00bfff;">"N"</span> ] 
<span style="color: #0000ff;">then</span>
write_free
<span style="color: #0000ff;">exit</span>
<span style="color: #0000ff;">fi</span>
auto_echo <span style="color: #00bfff;">"Are you sure to begin[y/n]:"</span>
<span style="color: #0000ff;">done</span>
</pre>

</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">for循环</h3>
<div class="outline-text-3" id="text-1-5">


<p><br/>
<pre class="src src-sh"><span style="color: #0000ff;">for</span> x<span style="color: #0000ff;"> in</span> /var/log/*
<span style="color: #0000ff;">do</span>
    <span style="color: #a52a2a;">echo</span> <span style="color: #ff00ff;">`basename $x`</span> is a file living<span style="color: #0000ff;"> in</span> /var/log
<span style="color: #0000ff;">done</span>
</pre>

</p>
<p> <br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">while and until</h3>
<div class="outline-text-3" id="text-1-6">


<p><br/>
<pre class="src src-sh"><span style="color: #ff1493;">myvar</span>=0
<span style="color: #0000ff;">while</span> [ $<span style="color: #ff1493;">myvar</span> -ne 10 ]
<span style="color: #0000ff;">do</span>
    <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">myvar</span>
    <span style="color: #ff1493;">myvar</span>=$(( $<span style="color: #ff1493;">myvar</span> + 1 ))
<span style="color: #0000ff;">done</span>


<span style="color: #ff1493;">myvar</span>=0
<span style="color: #0000ff;">until</span> [ $<span style="color: #ff1493;">myvar</span> -eq 10 ]
<span style="color: #0000ff;">do</span>
    <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">myvar</span>
    <span style="color: #ff1493;">myvar</span>=$(( $<span style="color: #ff1493;">myvar</span> + 1 ))
<span style="color: #0000ff;">done</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">case</h3>
<div class="outline-text-3" id="text-1-7">

<p>*$x为文件名，只获取文件的后缀，至于是为什么现在不明白? *<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #0000ff;">case</span> <span style="color: #00bfff;">"${x##*.}"</span><span style="color: #0000ff;"> in</span>
     gz)
           gzunpack ${<span style="color: #ff1493;">SROOT</span>}/${<span style="color: #ff1493;">x</span>}
           ;;
     bz2)
           bz2unpack ${<span style="color: #ff1493;">SROOT</span>}/${<span style="color: #ff1493;">x</span>}
           ;;
     *)
           <span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">"Archive format not recognized."</span>
           <span style="color: #0000ff;">exit</span>
           ;;
<span style="color: #0000ff;">esac</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">读取文件</h3>
<div class="outline-text-3" id="text-1-8">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">! /bin/</span><span style="color: #0000ff;">bash</span><span style="color: #8c8c8c; font-style: italic;">  </span>
<span style="color: #0000ff;">while </span><span style="color: #a52a2a;">read</span> LINE
<span style="color: #0000ff;">do</span>
        <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">LINE</span> 
<span style="color: #0000ff;">done</span> &lt; /etc/passwd
</pre>


</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">awk按域搜索的例子</h3>
<div class="outline-text-3" id="text-1-9">


<p><br/>
<pre class="src src-sh"><span style="color: #0000ff;">while </span><span style="color: #a52a2a;">read</span> line; 
        <span style="color: #0000ff;">do</span> cp aaaa $<span style="color: #ff1493;">line</span>;
<span style="color: #0000ff;">done</span> &lt;&lt; (awk <span style="color: #00bfff;">'{for(i=1; i &lt;= NF; ++i){if($i ~/^-l/){gsub("^-l","lib",$i); printf("%s.so\n", $i)}}}'</span> libso.txt  | sort -u)
</pre>

</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开源防火墙]]></title>
    <link href="http://emmoblin.github.com/blog/2012/11/17/opensources-firewall/"/>
    <updated>2012-11-17T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/11/17/opensources-firewall</id>
    <content type="html"><![CDATA[<div><div><p><br/>
要说免费使用的防火墙那多了，但都不开源，而我更喜欢开源的，能学到东西。<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">可下到源代码</h3>
<div class="outline-text-3" id="text-1-1">


</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">IPCop</h4>
<div class="outline-text-4" id="text-1-1-1">

<p><a href="http://sourceforge.net/projects/ipcop/develop">http://sourceforge.net/projects/ipcop/develop</a><br/>
可以下载源代码。<br/>
<code>svn co https://ipcop.svn.sourceforge.net/svnroot/ipcop ipcop</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">EFW</h4>
<div class="outline-text-4" id="text-1-1-2">

<p><a href="http://www.endian.com/">http://www.endian.com/</a><br/>
这个比较大，600M源码包，非常全。<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">Vyatta</h3>
<div class="outline-text-3" id="text-1-2">

<p>基于debian<br/>
<a href="http://www.vyatta.org/downloads">http://www.vyatta.org/downloads</a><br/>
目前这个是我发现的有专门针对虚拟化平台优化的版本。<br/>
<a href="http://www.vyatta.org/getting-started/how-to-install">http://www.vyatta.org/getting-started/how-to-install</a><br/>
</p>
<p><br/>
Installing Vyatta Core in a Virtualized Environment<br/>
If you’re deploying Vyatta Core on a hypervisor such as VMWare ESX/ESXi or Citrix XenServer, <br/>
you’ll want to use the Vyatta virtualization ISO (virt-ISO).<br/>
Similar to the LiveCD ISO, the virt-ISO provides a bootable ISO,<br/>
except it also includes virtual machine tools and other optimizations<br/>
to deliver the best possible experience for users running Vyatta on a virtual machine. <br/>
</p>
<p><br/>
Using the vSphere Client, create a new VM<br/>
</p><ul>
<li>Configuration: Custom<br/>
</li>
<li>Name: &#8220;vyatta&#8221;<br/>
</li>
<li>Datastore: default<br/>
</li>
<li>Virtual Machine Version: 7<br/>
</li>
<li>Guest OS: Linux/Other 2.6x Linux<br/>
</li>
<li>CPU: &#8220;1&#8221;<br/>
</li>
<li>Memory: &#8220;512&#8221;<br/>
</li>
<li>Network: &#8220;2&#8221; / vmxnet3<br/>
</li>
<li>SCSI Controller: default<br/>
</li>
<li>Select a Disk: default<br/>
</li>
<li>Create a Disk: &#8220;4&#8221;GB (thin provisioning and independent / persistent mode)<br/>
</li>
<li>Advanced Options: Enable &#8220;Support VMI Paravirtualization&#8221;<br/>
</li>
</ul>


<p>        <br/>
使用了<br/>
open-vm-tools<br/>
ec2-api-tools 是不是可以通过api来管理此虚拟机，或者获得性能等。ec2-api是什么东东？<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">获取源代码</h4>
<div class="outline-text-4" id="text-1-2-1">

<p><a href="http://www.vyatta.org/downloads/source-code">http://www.vyatta.org/downloads/source-code</a><br/>
</p>
<p><br/>
git clone <a href="http://git.vyatta.com/build-iso.git">http://git.vyatta.com/build-iso.git</a><br/>
cd build-iso<br/>
注意要先调整到一个分支或者tag<br/>
build-iso$ git branch &ndash;track &lt;branch&gt; origin/&lt;branch&gt;<br/>
build-iso$ git checkout &lt;branch&gt;<br/>
或者<br/>
git checkout tagv1<br/>
</p>
<p><br/>
获取子模块的代码<br/>
git submodule init<br/>
git submodule update pkgs/SUBMODULE<br/>
</p>
<p><br/>
克隆所有模块<br/>
git submodule update<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">install</h4>
<div class="outline-text-4" id="text-1-2-2">

<p>启动虚拟机,用缺省的用户名/密码 vyatta/vyatta登陆系统<br/>
install image 基于image安装，推荐,可以切换image<br/>
install system 基于disk安装，传统硬盘安装方式<br/>
</p>
<p><br/>
There are two types of installations that can be performed on a persistent device: <br/>
• Image-based install. The simplest, most flexible, and most powerful way to <br/>
install a Vyatta system is using a binary system image. With this method, you can <br/>
install multiple versions of the Vyatta system as images and switch between the <br/>
images simply and easily. You install the image from a LiveCD then you reboot <br/>
your system and it runs the image. <br/>
• Disk-based install. A disk-based install also installs from a LiveCD onto a <br/>
persistent device such as a hard disk partition. However, unlike an image-based <br/>
install, a disk-based install uses a traditional layout of files on the disk. <br/>
Additional system images may be added at a later time to a system created using <br/>
a disk-based install. <br/>
</p>
<p><br/>
nstall-image (is what I would suggest btw) is using squashfs and is capable of booting/running multiple images of versions<br/>
</p>
<p><br/>
真让我好找，找了一天，终于找到安装脚本了，在pkgs/vyatta-cfg-system<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">debian install</h4>
<div class="outline-text-4" id="text-1-2-3">

<p>这个貌似比较重要，vyatta之所以看不太明白，应该是对d-i不了解。<br/>
看看internal<br/>
<a href="http://d-i.alioth.debian.org/doc/internals/">http://d-i.alioth.debian.org/doc/internals/</a><br/>
</p></div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">配置ip</h4>
<div class="outline-text-4" id="text-1-2-4">

<p>vyatta@vyatta:~$ configure<br/>
vyatta@vyatta# set interfaces ethernet eth0 address 192.168.1.81/24<br/>
vyatta@vyatta# commit<br/>
vyatta@vyatta# exit<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-5" class="outline-4">
<h4 id="sec-1-2-5">启动webui</h4>
<div class="outline-text-4" id="text-1-2-5">

<p>vyatta@R1# set service https<br/>
不过需要商业版才能使用webui<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-6" class="outline-4">
<h4 id="sec-1-2-6">linux-image</h4>
<div class="outline-text-4" id="text-1-2-6">

<p>vyatta的内核配置<br/>
/home/liwei/work/src_analysis/tag_vyatta_src/pkgs/linux-image/debian/arch/i386/config.586-vyatta-virt<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[shell命令技巧收集]]></title>
    <link href="http://emmoblin.github.com/blog/2012/11/16/shell-skill/"/>
    <updated>2012-11-16T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/11/16/shell-skill</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">资料，有空在整理</h3>
<div class="outline-text-3" id="text-1-1">

<p>隆重推荐，one line command<br/>
<a href="http://www.catonmat.net/">http://www.catonmat.net/</a><br/>
</p>
<p><br/>
<a href="http://os.51cto.com/art/201008/222287.htm">http://os.51cto.com/art/201008/222287.htm</a><br/>
<a href="http://os.51cto.com/art/201008/222743.htm">http://os.51cto.com/art/201008/222743.htm</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">添加上一个命令的最后一个参数</h3>
<div class="outline-text-3" id="text-1-2">

<p>Alt .<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">字符串比较，注意要用引号</h3>
<div class="outline-text-3" id="text-1-3">

<p>字符串比较说明<br/>
大多数时候，虽然可以不使用括起字符串和字符串变量的双引号，但这并不是好主意。为什么呢？因为如果环境变量中恰巧有一个空格或制表键，bash 将无法分辨，从而无法正常工作。这里有一个错误的比较示例：<br/>
 if [ $myvar = &#8220;foo bar oni&#8221; ]<br/>
then <br/>
     echo &#8220;yes&#8221;<br/>
fi<br/>
</p>
<p><br/>
在上例中，如果 myvar 等于 &#8220;foo&#8221;，则代码将按预想工作，不进行打印。但是，如果 myvar 等于 &#8220;foo bar oni&#8221;，则代码将因以下错误失败：<br/>
 [: too many arguments<br/>
</p>
<p><br/>
在这种情况下，&#8221;$myvar&#8221;（等于 &#8220;foo bar oni&#8221;）中的空格迷惑了 bash。bash 扩展 &#8220;$myvar&#8221; 之后，代码如下：<br/>
 [ foo bar oni = &#8220;foo bar oni&#8221; ]<br/>
</p>
<p><br/>
因为环境变量没放在双引号中，所以 bash 认为方括号中的自变量过多。可以用双引号将字符串自变量括起来消除该问题。请记住，如果养成将所有字符串自变量用双引号括起的习惯，将除去很多类似的编程错误。&#8221;foo bar oni&#8221; 比较 应该写成：<br/>
if [ &#8220;$myvar&#8221; = &#8220;foo bar oni&#8221; ]<br/>
then <br/>
     echo &#8220;yes&#8221;<br/>
fi<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">算术表达式 $(( ))</h3>
<div class="outline-text-3" id="text-1-4">

<p> $ myvar=&#8221;56&#8221;<br/>
 $ echo $(( $myvar + 12 ))<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">名字空间，全局性</h3>
<div class="outline-text-3" id="text-1-5">

<p>在 bash 中，每当在函数内部创建环境变量，就将其添加到 全局名称空间。这意味着，该变量将重写函数之外的全局变量，并在函数退出之后继续存在<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">捕获脚本的输出 2&gt;&amp;1 | tee T型管道</h3>
<div class="outline-text-3" id="text-1-6">

<p>当显示正在生成的输出时，捕获每个脚本的输出 <br/>
如果脚本不能自动地将输出发送到文件的话，可以利用 Bash shell 的一些函数来捕获所执行脚本的输出，如：<br/>
./test-bucket-1  -s  2&gt;&amp;1  | tee test-bucket-1.out<br/>
</p>
<p><br/>
让我们来分析上面的命令：<br/>
&#8220;2&gt;&amp;1&#8221; 命令：<br/>
使用 &#8220;2&gt;&amp;1&#8221; 将标准错误重定向到标准输出。字符串 &#8220;2&gt;&amp;1&#8221; 表明任何错误都应送到标准输出，即 UNIX/Linux 下 2 的文件标识代表标准错误，而 1 的文件标识代表标准输出。如果不用此字符串，那么所捕捉到的仅仅是正确的信息，错误信息会被忽略。<br/>
管道 &#8220;|&#8221; 和 &#8220;tee&#8221; 命令：<br/>
UNIX/Linux 进程和简单的管道概念很相似。既然这样，可以做一个管道将期望脚本的输出作为管道的输入。下一个要决定的是如何处理管道所输出的内容。在这种情况下，我们会将它捕获到输出文件中，在此示例中将之称为 &#8220;test-bucket-1.out&#8221;。<br/>
但是，除了要捕获到输出结果外，我们还想监视脚本运行时产生的输出。为达到此目的，我们连接允许两件事同时进行的 &#8220;tee&#8221; （T- 形管道）：将输出结果放在文件中同时将输出结果显示在屏幕上。 其管道类似于：<br/>
process &ndash;&gt; T &mdash;&gt; output file<br/>
             V<br/>
           screen<br/>
</p>
<p><br/>
如果 只 想捕获输出结果而不想在屏幕上看到输出结果，那可以忽略多余的管道： ./test-bucket-1 -s 2&gt;&amp;1 &gt; test-bucket-1.out<br/>
假若这样，相类似的管道如下：<br/>
process &ndash;&gt; output file<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">产生随机数</h3>
<div class="outline-text-3" id="text-1-7">

<p>dd if=/dev/urandom count=1 2&gt; /dev/null | cksum | cut -f1 -d&#8221; &#8221; <br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">取得一些文件名称中的一部分名称</h3>
<div class="outline-text-3" id="text-1-8">

<p>interfaces=`ls session_* | sed &#8216;s/^session_//g&#8217; | sed &#8216;s//.log$//g&#8217;`<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">如何用bash从文件中读一行</h3>
<div class="outline-text-3" id="text-1-9">

<p>while read line<br/>
  do<br/>
  echo $line<br/>
done &lt; &#8220;$filename&#8221;<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10">如何用bash发现某些文件中是否没有包含string</h3>
<div class="outline-text-3" id="text-1-10">


<p><br/>
jsps=`find . -name &#8220;*.jsp&#8221;`<br/>
</p>
<p><br/>
for jsp in $jsps; do<br/>
    havegb=`grep gb2312 $jsp`<br/>
        [ ! -n &#8220;$havegb&#8221; ] &amp;&amp; echo $jsp<br/>
done<br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[centos kdump]]></title>
    <link href="http://emmoblin.github.com/blog/2012/11/15/centos-kdump/"/>
    <updated>2012-11-15T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/11/15/centos-kdump</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">centos kdump</a>
<ul>
<li><a href="#sec-1-1">介绍</a></li>
<li><a href="#sec-1-2">安装</a></li>
<li><a href="#sec-1-3">添加内核启动参数</a></li>
<li><a href="#sec-1-4">配置文件</a></li>
<li><a href="#sec-1-5">测试</a></li>
<li><a href="#sec-1-6">用crash 工具分析vmcore 文件</a></li>
<li><a href="#sec-1-7">参考</a></li>
<li><a href="#sec-1-8">遗留问题</a></li>
<li><a href="#sec-1-9">systemtap</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/11/15/centos-kdump/">centos kdump</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">介绍</h3>
<div class="outline-text-3" id="text-1-1">

<p>通过kexec和kdump当内核crash的时候可以显示堆栈信息。方便调试。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">安装</h3>
<div class="outline-text-3" id="text-1-2">

<p>sudo yum install kexec-tools<br/>
sudo yum install kernel-debug kernel-debug-devel<br/>
yum install crash gdb<br/>
</p>
<p><br/>
为了让内核都统一，不妨内核也升级一下<br/>
yum install kernel kernel-devel<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">添加内核启动参数</h3>
<div class="outline-text-3" id="text-1-3">

<p>crashkernel=128M@16M<br/>
在/etc/grub.cfg中添加，表示启动的时候从16M的位置开始，预留128M内存用于crashkernel <br/>
注意centos6.2我发现可能已经默认支持了kdump，只是没有启动而已，grub.cfg中已经添加了crashkernel=auto<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">配置文件</h3>
<div class="outline-text-3" id="text-1-4">

<p>/etc/kdump.conf<br/>
配置coredump的位置，默认是 /var/crash<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">测试</h3>
<div class="outline-text-3" id="text-1-5">

<p>reboot后<br/>
这会创建/boot/initrd-kdump.img用于capture coredump，这非常重要，否则kdump就会启动失败。<br/>
该文件就是kdump加载的内核的 initrd文件，收集dump信息的工作就是在该initrd的启动环境下进行的。<br/>
查看/etc/init.d/kdump脚本的代码，你可看到其中会调用mkdumprd命令创建用于dump的initrd文件。<br/>
</p>
<p><br/>
service kdump status<br/>
</p>
<p><br/>
触发crash<br/>
echo 1 &gt; /proc/sys/kernel/sysrq<br/>
echo &#8220;c&#8221; &gt; /proc/sysrq-trigger<br/>
</p>
<p><br/>
等待时间比较长，大概5分钟，系统又重新进入了桌面。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">用crash 工具分析vmcore 文件</h3>
<div class="outline-text-3" id="text-1-6">


<p><br/>
用crash 命令分析vmcore 的命令行格式如下所示. <br/>
用crash打开vmcore后，主要是用dmesg及 bt 命令打印出问题的执行路径的call trace, <br/>
用dis 反汇编出代码，最终确认call trace对应的C源码中的位置，再进行逻辑分析.<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">参考</h3>
<div class="outline-text-3" id="text-1-7">

<p><a href="http://www.linuxidc.com/Linux/2011-03/33548.htm">http://www.linuxidc.com/Linux/2011-03/33548.htm</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">遗留问题</h3>
<div class="outline-text-3" id="text-1-8">

<p>用crash需要vmlinux，到哪里获得？<br/>
可能需要安装kernel-debuginfo<br/>
但标准库里可能没有，需要另外添加。<br/>
<a href="http://www.dedoimedo.com/computers/centos-debug.html">http://www.dedoimedo.com/computers/centos-debug.html</a><br/>
</p>
<p><br/>
<a href="http://wiki.centos.org/AdditionalResources/Repositories">http://wiki.centos.org/AdditionalResources/Repositories</a><br/>
已经说得很清楚了，需要额外添加debuginfo的库<br/>
不过看到centos6.2中自带了<br/>
 /etc/yum.repos.d/CentOS-Debuginfo.repo<br/>
<b>注意把其中的enabled改为1</b>,然后就可以安装了<br/>
kernel-debuginfo 将近300M<br/>
</p>
<p><br/>
先不下了，速度太慢了，10k。<br/>
</p>
<p><br/>
还有个问题，就算能看vmcore了，那模块coredump也能看吗？<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">systemtap</h3>
<div class="outline-text-3" id="text-1-9">

<p>有空再研究一下kprobe和systemtap<br/>
<a href="http://hi.baidu.com/donglix/item/13052275911e7a5f0c0a07f8">http://hi.baidu.com/donglix/item/13052275911e7a5f0c0a07f8</a><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gcov]]></title>
    <link href="http://emmoblin.github.com/blog/2012/11/02/gcov/"/>
    <updated>2012-11-02T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/11/02/gcov</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">gcov</a>
<ul>
<li><a href="#sec-1-1">分支覆盖的作用</a></li>
<li><a href="#sec-1-2">参考</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/11/02/gcov/">gcov</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">分支覆盖的作用</h3>
<div class="outline-text-3" id="text-1-1">

<p>所有单元测试跑完后，统计分支覆盖率，统计测试的是否全面。一个程序如果每个分支都执行过了，也不能保证程序就是正确的。<br/>
毕竟还有很多逻辑错误，但至少能从某种程度上显示出，这些代码测试的是否完善，不完善就还需要补充测试用例。<br/>
可以显示出每行被执行了多少次，哪行没有被执行。<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">参考</h3>
<div class="outline-text-3" id="text-1-2">

<p><a href="http://www.taobaotest.com/blogs/qa?bid=8451">GCOV 实现原理</a><br/>
&lt;深入浅出Linux平台代码覆盖率测试.pdf&gt;<br/>
</p>
<p><br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c单元测试框架:cutter]]></title>
    <link href="http://emmoblin.github.com/blog/2012/11/02/cutter/"/>
    <updated>2012-11-02T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/11/02/cutter</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">特性</h3>
<div class="outline-text-3" id="text-1-1">

<p>c的单元测试见的多了，cutter有什么看家本领吗？<br/>
</p><ol>
<li>框平台性好<br/>
   这个貌似意义不大，单元测试框架一般本身都很小巧，移植难度很小。<br/>

<p><br/>
</p></li>
<li>自动探测用例<br/>
   这个功能不错，只要开头是test_ 开头的函数，自动认为是testcase。<br/>
   其实他是把testcase编译成了库，然后进行符号查找。<br/>

<p><br/>
</p></li>
<li>显示友好<br/>
   尽量精确的提出错误在哪里，有个expect和real，貌似还可以diff。<br/>

<p><br/>
</p></li>
<li>支持数据驱动测试<br/>
   这个功能还有点不明白，貌似应该是测试前准备数据集的功能，不知道是否是mock功能。<br/>

<p><br/>
</p></li>
<li>支持代码的分支覆盖率攻击。<br/>

<p><br/>
</p></li>
<li>针对ubuntu特别优化。<br/>
</li>
</ol>


<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">后续待添加功能</h3>
<div class="outline-text-3" id="text-1-2">

<p>从他的TODO中可以看到一些，不过我最期望的是：<br/>
</p><ol>
<li>测试用例的search<br/>
</li>
<li>内存泄漏测试，最好集成memwatch的功能。mem_limit很好。<br/>
</li>
<li>是否有mock功能？<br/>
</li>
</ol>


<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">主页</h3>
<div class="outline-text-3" id="text-1-3">

<p><a href="http://sourceforge.net/projects/cutter/">http://sourceforge.net/projects/cutter/</a><br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[memwatch]]></title>
    <link href="http://emmoblin.github.com/blog/2012/10/30/memwatch-/"/>
    <updated>2012-10-30T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/10/30/memwatch-</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">memwatch</a>
<ul>
<li><a href="#sec-1-1">Memwatch简介</a></li>
<li><a href="#sec-1-2">MemWatch的内存处理</a></li>
<li><a href="#sec-1-3">初始化和结束处理</a></li>
<li><a href="#sec-1-4">MemWatch的I/O 操作</a></li>
<li><a href="#sec-1-5">使用</a>
<ul>
<li><a href="#sec-1-5-1">使用MemWatch提供的功能</a></li>
</ul>
</li>
<li><a href="#sec-1-6">Memwatch使用注意</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/10/30/memwatch-/">memwatch</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">Memwatch简介</h3>
<div class="outline-text-3" id="text-1-1">

<p>在三种检测工具当中，设置最简单的算是memwatch，和dmalloc一样，<br/>
它能检测未释放的内存、同一段内存被释放多次、位址存取错误及不当使用未分配之内存区域。<br/>
请往<br/>
<a href="http://www.linkdata.se/sourcecode.html">http://www.linkdata.se/sourcecode.html</a><br/>
下载最新版本的Memwatch。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">MemWatch的内存处理</h3>
<div class="outline-text-3" id="text-1-2">

<p>MemWatch将所有分配的内存用0xFE填充，所以，如果你看到错误的数据是用0xFE填充的，那就是你没有初始化数据。<br/>
例外是calloc()，它会直接把分配的内存用0填充。<br/>
</p>
<p><br/>
MemWatch将所有已释放的内存用0xFD填充(zapped with 0xFD).<br/>
如果你发现你使用的数据是用0xFD填充的，那你就使用的是已释放的内存。<br/>
在这种情况，注意MemWatch会立即把一个&#8221;释放了的块信息&#8221; 填在释放了的数据前。<br/>
这个块包括关于内存在哪儿释放的信息，以可读的文本形式存放，格式 为&#8221;FBI&lt;counter&gt;filename(line)&#8221;。<br/>
如:&#8221;FBI&lt;267&gt;test.c(12)&#8221;.使用FBI会降 低free()的速度，所以默认是关闭的。使用mwFreeBufferInfo(1)开启。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">初始化和结束处理</h3>
<div class="outline-text-3" id="text-1-3">

<p>一般来说，在程序中使用MemWatch的功能，可以手动添加mwInit()进行初始化，并用对应的mwTerm ()进行结束处理。<br/>
一般不需要手动添加，memwatch会在第一个malloc的时候自动初始化，并在atexit中添加mwTerm。<br/>
</p>
<p><br/>
如果自动初始化不合适或者程序比较特殊，请显式调用mwInit()和mwTerm().<br/>
比如，有的时候明明程序没有问题，而memwatch显示内存泄漏，这时就需要手动调用初始化和结束。<br/>
</p>
<p><br/>
涉及的函数主要有：<br/>
mwInit()    mwTerm()    mwAbort()<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">MemWatch的I/O 操作</h3>
<div class="outline-text-3" id="text-1-4">

<p>对于一般的操作，MemWatch创建memwatch.log文件。有时，该文件不能被创建;<br/>
MemWatch会试图创建memwatNN.log文件，NN在01~99之间。<br/>
</p>
<p><br/>
如果你不能使用日志，或者不想使用，也没有问题。<br/>
只要使用类型为&#8221;void func(int c)&#8221;的参数调用mwSetOutFunc()，然后所有的输出都会按字节定向到该函数.<br/>
</p>
<p><br/>
当ASSERT或者VERIFY失败时，MemWatch也有Abort/Retry/Ignore处理机制。<br/>
默认的处理机制没有I/O操作，但是会自动中断程序。<br/>
你可以使用任何其他Abort/Retry/Ignore的处理机制,只要以参数&#8221;void func(int c)&#8221;调用mwSetAriFunc()。<br/>
</p>
<p><br/>
涉及的函数主要有：<br/>
mwTrace()           mwPuts()        mwSetOutFunc()  mwSetAriFunc()<br/>
mwSetAriAction()    mwAriHandler()  mwBreakOut()<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">使用</h3>
<div class="outline-text-3" id="text-1-5">

<p>在要使用MemWatch的.c文件中包含头文件&#8221;memwatch.h&#8221;<br/>
</p>
<p><br/>
使用GCC编译（注意：不是链接）自己的程序时，加入-DMEMWATCH -DMW_STDIO<br/>
如：gcc -DMEMWATCH -DMW_STDIO –o test.o –c  test1.c memwatch.c<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">使用MemWatch提供的功能</h4>
<div class="outline-text-4" id="text-1-5-1">

<ol>
<li>mwTRACE，mwASSERT，mwVERIFY和mwPuts<br/>
</li>
<li>ARI机制即程序设置的“Abort, Retry, Ignore选择陷阱<br/>
</li>
<li>mwSetOutFunc<br/>
   将输出转向调用者给出的函数(参数即函数地址)。参数为NULL，表示把输出写入日志文件memwatch.log.<br/>
</li>
<li>mwIsReadAddr<br/>
   检查内存是否有读取的权限<br/>
</li>
<li>mwIsSafeAddr<br/>
   检查内存是否有读、写的权限<br/>
</li>
<li>mwStatistics<br/>
   设置状态搜集器的行为。对应的参数采用宏定义。<br/>

<p><br/>
   #define MW_STAT_GLOBAL  0       <i>* 仅搜集全局状态信息 *</i><br/>
   #define MW_STAT_MODULE  1       <i>* 搜集模块级的状态信息 *</i><br/>
   #define MW_STAT_LINE    2       <i>* 搜集代码行级的状态信息 *</i><br/>
   #define MW_STAT_DEFAULT 0       <i>* 默认状态设置 *</i><br/>
</p></li>
</ol>


<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">Memwatch使用注意</h3>
<div class="outline-text-3" id="text-1-6">

<p>Memwatch 的优点是无需特別配置，不需安装便能使用，但缺点是它会拖慢程序的运行速度，尤其是释放内存时它会作大量检查。<br/>
但它比mtrace和dmalloc多了 一项功能，就是能模拟系统内存不足的情況，<br/>
使用者只需用mwLimit(long num_of_byte)函数来限制程式的heap memory大小(以byte单位)。<br/>
</p>
<p><br/>
最详细的使用说明(包括优点缺点，运行原理等)已在README中列出，本人强烈建议各位读者参考该文件。<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CUnit]]></title>
    <link href="http://emmoblin.github.com/blog/2012/10/29/cunit/"/>
    <updated>2012-10-29T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/10/29/cunit</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">CUnit</a>
<ul>
<li><a href="#sec-1-1">CUnit交叉编译</a></li>
<li><a href="#sec-1-2">使用bootstrap而不是configure</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/10/29/cunit/">CUnit</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">CUnit交叉编译</h3>
<div class="outline-text-3" id="text-1-1">

<p>我更换到ubuntu12.04上编译CUnit已经编译不过去了，错误原因是：<br/>
libtool : X&ndash;tag=CC: command not found 编译报错<br/>
原因据说是因为在项目目录下生成的libtool脚本中定义了$ECHO变量，但是在脚本文件ltmain.sh中，使用的却是$echo(生成的libtool版本太旧)<br/>
可通过以下方法解决：<br/>
</p>
<p> <br/>
</p><ol>
<li>直接复制系统自带的libtool到项目目录，应该在/usr/bin目录下，覆盖代码文件目录下的libtool，再执行make<br/>
</li>
</ol>

<p>（没装就apt-get install libtool 或者 yum install libtool 安装一下吧）<br/>
但是这有个问题，不能用于交叉编译，系统的libtool会使用系统的ld等，而应该使用交叉工具连的ld。<br/>
</p>
<p> <br/>
</p><ol>
<li>修改aclocal.m4文件，将上面的LIBTOOL=&#8217;$(SHELL) $(top_builddir)/libtool&#8217;改成<br/>
</li>
</ol>

<p>LIBTOOL=&#8217;$(SHELL)  /usr/bin/libtool&#8217;后重新执行./configure<br/>
</p>
<p> <br/>
</p><ol>
<li>将源码目录下libtool脚本中所有的$ECHO替换成$echo. 或者将脚本文件ltmain.sh里的$echo替换成$ECHO，<br/>
</li>
</ol>

<p>都一样，重新执行./configure<br/>
</p>
<p><br/>
另一种解决方案<br/>
export echo=echo  回车后 make 正常<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">使用bootstrap而不是configure</h3>
<div class="outline-text-3" id="text-1-2">

<p>没有了上边的libtool的问题，直接修改bootstrap，添加CC就ok了。<br/>
CC=/workspace26/i386-env/cross-tools/bin/i686-unknown-linux-gnu-gcc<br/>
或者采用&ndash;host的形式：<br/>
PATH=/workspace26/i386-env/cross-tools/bin/:$PATH LD_LIBRARY_PATH=/workspace26/env-x86-lib <br/>
./configure &ndash;host=i686-unknown-linux-gnu &ndash;enable-shared=no &ndash;disable-dependency-tracking<br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[svn使用]]></title>
    <link href="http://emmoblin.github.com/blog/2012/10/16/svn/"/>
    <updated>2012-10-16T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/10/16/svn</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">svn使用</a>
<ul>
<li><a href="#sec-1-1">svn libneon的问题</a></li>
<li><a href="#sec-1-2">自己编译，真的不容易啊</a></li>
<li><a href="#sec-1-3">tftpd-hpa</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/10/16/svn/">svn使用</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">svn libneon的问题</h3>
<div class="outline-text-3" id="text-1-1">

<p>ubuntu安装的svn要使用https时，默认使用的libneon-gnutls有点兼容性问题。所以导致的错误是：<br/>
SSL handshake failed: SSL 错误：在证书中检测到违规的密钥用法。<br/>
解决办法：<br/>
<a href="http://www.yeap.de/blog2.0/archives/260-Subversion-Certificate-Problems-with-Ubuntu-Precise-Pangolin.html">http://www.yeap.de/blog2.0/archives/260-Subversion-Certificate-Problems-with-Ubuntu-Precise-Pangolin.html</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">自己编译，真的不容易啊</h3>
<div class="outline-text-3" id="text-1-2">

<p>cd openssl<br/>
由于是64bit系统，所以需要添加fPIC<br/>
./config -fPIC<br/>
但是cropt目录不好添加fPIC，难道生成的.a难道也需要fPIC吗？，所以无奈，只能先安装系统的openssl<br/>
apt-get install openssl-dev openssl<br/>
</p>
<p><br/>
cd subversion<br/>
./configure &ndash;with-ssl=openssl &ndash;with-neon=./neon &ndash;with-openssl=/usr<br/>
出现warnning无用理会直接make<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">tftpd-hpa</h3>
<div class="outline-text-3" id="text-1-3">

<p>atftpd 设置半天不能启动，连直接输入命令行都不能启动。<br/>
所以换成tftpd-hpa，非常简单。<br/>
不过要想能够上传文件需要修改配置：<br/>
vi /etc/default/tftpd-hpa<br/>
添加&ndash;create<br/>
注意-s参数不能去掉。<br/>
</p>
<p><br/>
客户端使用atftp。<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[串口工具ckermit]]></title>
    <link href="http://emmoblin.github.com/blog/2012/10/16/ckermit/"/>
    <updated>2012-10-16T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/10/16/ckermit</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">串口工具ckermit</a>
<ul>
<li><a href="#sec-1-1">默认配置文件</a></li>
<li><a href="#sec-1-2">操作</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/10/16/ckermit/">串口工具ckermit</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">默认配置文件</h3>
<div class="outline-text-3" id="text-1-1">

<p>/etc/kermit/kermrc<br/>
一般配置一个home下的自己的配置文件就ok了。<br/>
~/.mykermrc<br/>
</p>
<p><br/>
<pre class="example">set line /dev/ttyS0
set speed 9600
set carrier-watch off
set handshake none
set flow-control none
robust
set file type bin
set file name lit
set rec pack 1000
set send pack 1000
set window 5
</pre>


</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">操作</h3>
<div class="outline-text-3" id="text-1-2">

<p>C-\ 切换到命令行<br/>
c 打开链接<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[thunderbird技巧]]></title>
    <link href="http://emmoblin.github.com/blog/2012/10/12/thunderbirdskill/"/>
    <updated>2012-10-12T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/10/12/thunderbirdskill</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">插件</h3>
<div class="outline-text-3" id="text-1-1">


</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">mouseless mutt key</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>像mutt一样操作邮件，非常方便。<br/>
m： write email<br/>
n/p: next,preview<br/>
r: re<br/>
f: forward<br/>
s: 加星<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">Contact Tabs</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>方便查看联系人<br/>
</p></div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">Thunderbird Conversations</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>把显示样式呈现的更友好<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">实现回复在前面</h3>
<div class="outline-text-3" id="text-1-2">

<p>默认Thunderbird是将回复加在回复邮件的后面，可以通过修改配置项实现回复在前面，<br/>
首选项&ndash;&gt;高级&ndash;&gt;高级配置&ndash;&gt;配置编辑器<br/>
找到配置编辑器，将 mail.identity.default.reply_on_top 这一项由默认的0改为1即可。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">3列显示</h3>
<div class="outline-text-3" id="text-1-3">

<p>在view显示为垂直视图<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ubuntu使用dropbox]]></title>
    <link href="http://emmoblin.github.com/blog/2012/10/10/dropbox-under-ubuntu/"/>
    <updated>2012-10-10T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/10/10/dropbox-under-ubuntu</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">对ubuntu one有点失望</h3>
<div class="outline-text-3" id="text-1-1">

<p>我本来是用ubuntu one，但是我先在使用ubuntu one来同步我的org笔记，同时我的org笔记又使用hg同步。<br/>
也就是一个文件夹同时使用hg和ubuntu one同步，结果发现ubuntu one同步总是出错，尤其是我使用hg fetch一个版本的时候。<br/>
经常把我一个文件夹的内容同步没了，幸亏我有hg，否则这些文件就丢失啦。<br/>
所以决定还是用dropbox吧，本来我手机使用dropbox来同步照片的，所以又申请了一个帐号，专门用于同步笔记。<br/>
而且最终要的是：<br/>
ubuntu one没有历史版本功能<br/>
而dropbox可以可以回退到以前的历史版本，这个非常好。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">dropbox同步任意文件夹问题</h3>
<div class="outline-text-3" id="text-1-2">

<p>本来还是我是打算用dropbox的，但是发现dropbox只能指定一个主目录，不想ubuntu one可以随便指定文件夹。<br/>
但后来发现，其实只要做一个软链接到Dropbox目录就ok了。<br/>
而且发现dropbox同步的速度非常快。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">dropbox安装</h3>
<div class="outline-text-3" id="text-1-3">

<p>需要使用https链接去登录dropbox主页，下边有如何安装的方式，很简单，就是wget一个压缩包，然后解压就ok了。<br/>
默认是.dropbox_dist目录。<br/>
然后启动dropboxd就ok了<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">ubuntu one的一些命令</h3>
<div class="outline-text-3" id="text-1-4">

<p>查看当前传输字节数<br/>
<code>u1sdtool --current-transfers</code><br/>
显示共享的文件夹<br/>
<code>u1sdtool --list-folders</code><br/>
删除文件夹<br/>
<code>u1sdtool --delete-folder=FOLDER_ID</code><br/>
其他命令使用&ndash;help查看<br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh的一些技巧]]></title>
    <link href="http://emmoblin.github.com/blog/2012/10/09/ssh-skill/"/>
    <updated>2012-10-09T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/10/09/ssh-skill</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">ssh的一些技巧</a>
<ul>
<li><a href="#sec-1-1">多条连接共享</a></li>
<li><a href="#sec-1-2">长连接</a></li>
<li><a href="#sec-1-3">别再输入密码</a></li>
<li><a href="#sec-1-4">省去用户名</a></li>
<li><a href="#sec-1-5">在服务器间跳转</a></li>
<li><a href="#sec-1-6">穿越Web代理</a></li>
<li><a href="#sec-1-7">shfs</a></li>
<li><a href="#sec-1-8">使用本地App连接远程服务器</a></li>
<li><a href="#sec-1-9">减少延迟</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/10/09/ssh-skill/">ssh的一些技巧</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">多条连接共享</h3>
<div class="outline-text-3" id="text-1-1">

<p>如果你需要在多个窗口中打开到同一个服务器的连接，而不想每次都输入用户名，密码，或是等待连接建立，<br/>
那么你可以配置SSH的连接共享选项，在本地打开你的SSH配置文件，通常它们位于~/.ssh/config，然后添加下面2行：<br/>
ControlMaster auto<br/>
ControlPath /tmp/ssh_mux_%h_%p_%r<br/>
现在试试断开你与服务器的连接，并建立一条新连接，然后打开一个新窗口，再创建一条连接，你会发现，第二条连接几乎是在瞬间就建立好了。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">长连接</h3>
<div class="outline-text-3" id="text-1-2">

<p>如果你发现自己每条需要连接同一个服务器无数次，那么长连接选项就是为你准备的：<br/>
ControlPersist 4h<br/>
现在你每次通过SSH与服务器建立连接之后，这条连接将被保持4个小时，即使在你退出服务器之后，这条连接依然可以重用，<br/>
因此，在你下一次（4小时之内）登录服务器时，你会发现连接以闪电般的速度建立完成，<br/>
这个选项对于通过scp拷贝多个文件提速尤其明显，因为你不在需要为每个文件做单独的认证了。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">别再输入密码</h3>
<div class="outline-text-3" id="text-1-3">

<p>如果你还在通过密码方式登录SSH，那么你或许应该试试SSH Keys，首先使用OpenSSH为自己声称一对密钥：<br/>
$ ssh-keygen<br/>
跟随指示，完成之后，你应该可以在你的.ssh目录下看到两个文件，id_rsa就是你的私钥，而id_ras.pub则是你的公钥，<br/>
现在你需要将你的公钥拷贝到服务器上，如果你的系统有ssh-copy-id命令，拷贝会很简单：<br/>
$ ssh-copy-id smylers@compo.example.org<br/>
否则，你需要手动将你的私钥拷贝的服务器上的~/.ssh/authorized_keys文件中：<br/>
$ &lt; ~/.ssh/id_rsa.pub ssh clegg.example.org ‘mkdir -p .ssh; cat &gt;&gt; .ssh/authorized_keys; chmod go-w .ssh .ssh/authorized_keys’<br/>
现在试试重新连接到SSH服务器，或是拷贝文件，是不是已经不需要再输入密码了？<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">省去用户名</h3>
<div class="outline-text-3" id="text-1-4">

<p>如果你在远程服务器上的用户名和你本地的用户名不同，你同样可以在SSH配置中进行设置：<br/>
Host www* mail<br/>
HostName %h.example.com<br/>
User simon<br/>
现在就算我的本地用户名是 smylers，我仍然可以这样连接我的服务器：<br/>
$ ssh www2<br/>
SSH会使用simon账户连接你的服务器，同样，Putty可以保存这个信息在你的session中。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">在服务器间跳转</h3>
<div class="outline-text-3" id="text-1-5">

<p>有些时候，你可能没法直接连接到某台服务器，而需要使用一台中间服务器进行中转，这个过程也可以自动化。首先确保你已经为服务器配置了公钥访问，并开启了agent forwarding，现在你就可以通过2条命令来连接目标服务器，不会有任何提示输入：<br/>
$ ssh gateway<br/>
gateway $ ssh db<br/>
然后在你的本地SSH配置中，添加下面这条配置：<br/>
Host db<br/>
HostName db.internal.example.com<br/>
ProxyCommand ssh gateway netcat -q 600 %h %p<br/>
现在你就可以通过一条命令来直接连接目标服务器了:<br/>
$ ssh db<br/>
这里你可能会需要等待长一点的时间，因为SSH需要进行两次认证，，注意netcat也有可能被写成nc或者ncat或者前面还需要加上g，你需要检查你的中间服务器来确定实际的参数。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">穿越Web代理</h3>
<div class="outline-text-3" id="text-1-6">

<p>有些时候，你所在的网络不止封锁SSH端口，它们有可能更进一步，只让你通过Web代理来访问网络，幸运的是我们有一个叫做Corkscrew的程序可以通过Web代理在发送SSH数据。Corkscrew的使用非常简单，一般我都是在需要时搜索，然后直接下载，跟随网站上的指示，然后就搞定了，一般你需要这样一条配置：<br/>
ProxyCommand corkscrew proxy.example.org 8080 %h %p<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">shfs</h3>
<div class="outline-text-3" id="text-1-7">

<p>另一种让远程GUI程序显示在本地的替代方案就是让本地的GUI程序可以直接操作远程文件，你可以通过SSHFS来实现，只需要创建一个空目录，然后使用SSHFS将一个远程目录mount到这个目录就可以了：<br/>
$ mkdir gallery_src<br/>
$ sshfs dev:projects/gallery/src gallery_src<br/>
$ cd gallery_src<br/>
$ ls<br/>
现在你就可以使用任何你喜欢的本地程序来便捷这个目录中的文件了，它们看起来是在你的本地，但其实时远程服务器上的文件，你可以使用fusermount命令来unmount这些文件，不要担心记不住，它们就在sshfs手册的顶上：<br/>
$ cd ..<br/>
$ fusermount -u gallery_src<br/>
SSHFS可以在Linux和OSX上工作，Windows用户我目前还没找到什么好办法。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">使用本地App连接远程服务器</h3>
<div class="outline-text-3" id="text-1-8">

<p>有时可能有些服务，比如数据库或是Web服务器，它们运行在远程服务器上，但是如果有用方式可以直接从本地程序连接它们，那会非常有用，要做到这一点，你需要用到端口转发(port forwarding)，<br/>
举个例子，如果你的服务器运行Postgres（并且只允许本地访问），那么你就可以在你的SSH配置中加入：<br/>
Host db<br/>
LocalForward 5433 localhost:5432<br/>
现在当你连接你的SSH服务器时，它会在你本地电脑打开一个5433端口（我随便挑的），并将所有发送到这个端口的数据转发到服务器的5432端口（Postgres的默认端口），然后，只要你和服务器建立了连接，你就可以通过5433端口来访问服务器的Postgres了。<br/>
$ ssh db<br/>
现在打开另外一个窗口，你就可以通过下面这条命令在本地连接你的Postgres数据库了：<br/>
$ psql -h localhost -p 5443 orders<br/>
如果你想要使用服务器不支持的图形化Postgres客户端时，这条命令会显得尤其有用：<br/>
$ pgadmin3 &amp;<br/>
或者你有一个后台的Web服务器，你不希望直接通过Internet访问它，你也可以通过端口转发来访问它：<br/>
Host api<br/>
LocalForward 8080 localhost:80<br/>
现在连接到服务器：<br/>
$ ssh api<br/>
然后将浏览器指向你选择的端口号：<br/>
$ firefox <a href="http://localhost:8080/">http://localhost:8080/</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">减少延迟</h3>
<div class="outline-text-3" id="text-1-9">

<p>如果每次连接服务器都意味着你需要等待几十秒而无所事事，那么你或许应该试试在你的SSH配置中加入下面这条：<br/>
GSSAPIAuthentication no<br/>
如果这条命令有效的话，你应该通知你的系统管理员让他在服务器上禁用这个选项，这样其他人就不用再分别添加这条配置到它们的本地配置了。<br/>
在server端修改：<br/>
/etc/ssh/sshd_config<br/>
添加<br/>
USEDNS no<br/>
service sshd restart<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Unix Utility You Should Know About:lsof]]></title>
    <link href="http://emmoblin.github.com/blog/2012/10/09/lsof/"/>
    <updated>2012-10-09T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/10/09/lsof</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">A Unix Utility You Should Know About:lsof</a>
<ul>
<li><a href="#sec-1-1">前言</a></li>
<li><a href="#sec-1-2">如何使用lsof？</a></li>
<li><a href="#sec-1-3">找出谁在使用某个文件</a></li>
<li><a href="#sec-1-4">列出某个用户打开的所有文件</a></li>
<li><a href="#sec-1-5">查找某个程序打开的所有文件</a></li>
<li><a href="#sec-1-6">列出所有由某个用户或某个进程打开的文件</a></li>
<li><a href="#sec-1-7">列出除root用户外的所有用户打开的文件</a></li>
<li><a href="#sec-1-8">列出所有由某个PID对应的进程打开的文件</a></li>
<li><a href="#sec-1-9">列出所有网络连接</a></li>
<li><a href="#sec-1-10">列出所有NFS（网络文件系统）文件</a></li>
<li><a href="#sec-1-11">列出所有UNIX域Socket文件</a></li>
<li><a href="#sec-1-12">列出所有对应某个组id的进程</a></li>
<li><a href="#sec-1-13">列出所有与某个描述符关联的文件</a></li>
<li><a href="#sec-1-14">输出使用某些资源的进程pid</a></li>
<li><a href="#sec-1-15">循环列出文件</a></li>
<li><a href="#sec-1-16">如何安装lsof？</a></li>
<li><a href="#sec-1-17">原文</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/10/09/lsof/">A Unix Utility You Should Know About:lsof</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">前言</h3>
<div class="outline-text-3" id="text-1-1">

<p>这是“你应该知道的Unix和Linux命令”系列的第三篇，在这篇文章中，我会介绍lsof这个工具，如果说netcat是进行网络诊断的瑞士军刀，那么lsof就是Unix调试的瑞士军刀。<br/>
</p>
<p><br/>
Lsof是遵从Unix哲学的典范，它只做一件事情，并且做的相当完美——它可以列出某个进程打开的所有文件信息。<br/>
打开的文件可能是普通的文件，目录，NFS文件，块文件，字符文件，共享库，常规管道，明明管道，符号链接，Socket流，网络Socket，UNIX域Socket，以及其它更多。因为Unix系统中几乎所有东西都是文件，你可以想象lsof该有多有用。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">如何使用lsof？</h3>
<div class="outline-text-3" id="text-1-2">


<p><br/>
这篇文章中我会尽力列举我能想到的所有lsof的用法，让我们先从最简单的开始（或许你已经知道了），然后逐渐增加复杂度：<br/>
</p>
<p><br/>
列出所有打开的文件<br/>
</p>
<p><br/>
<code>lsof</code><br/>
</p>
<p><br/>
不带任何参数运行lsof会列出所有进程打开的所有文件。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">找出谁在使用某个文件</h3>
<div class="outline-text-3" id="text-1-3">


<p><br/>
<code>lsof /path/to/file</code><br/>
</p>
<p><br/>
只需要执行文件的路径，lsof就会列出所有使用这个文件的进程，你也可以列出多个文件，lsof会列出所有使用这些文件的进程。<br/>
</p>
<p><br/>
你也可以一次制定多个文件：<br/>
</p>
<p><br/>
<code>lsof /path/to/file1 /path/to/file2</code><br/>
</p>
<p><br/>
递归查找某个目录中所有打开的文件<br/>
</p>
<p><br/>
<code>lsof +D /usr/lib</code><br/>
</p>
<p><br/>
加上+D参数，lsof会对指定目录进行递归查找，注意这个参数要比grep版本慢：<br/>
</p>
<p><br/>
= lsof | grep &#8216;/usr/lib&#8217; =<br/>
</p>
<p><br/>
之所以慢是因为+D首先查找所有的文件，然后一次性输出。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">列出某个用户打开的所有文件</h3>
<div class="outline-text-3" id="text-1-4">


<p><br/>
<code>lsof -u pkrumins</code><br/>
</p>
<p><br/>
-u选项限定只列出所有被用户pkrumins打开的文件，你可以通过逗号指定多个用户：<br/>
</p>
<p><br/>
<code>lsof -u rms,root</code><br/>
</p>
<p><br/>
这条命令会列出所有rms和root用户打开的文件。<br/>
</p>
<p><br/>
你也可以像下面这样使用多个-u做同样的事情：<br/>
</p>
<p><br/>
<code>lsof -u rms -u root</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">查找某个程序打开的所有文件</h3>
<div class="outline-text-3" id="text-1-5">


<p><br/>
<code>lsof -c apache</code><br/>
</p>
<p><br/>
-c选项限定只列出以apache开头的进程打开的文件：<br/>
</p>
<p><br/>
所以你可以不用像下面这样写：<br/>
</p>
<p><br/>
<code>lsof | grep foo</code><br/>
</p>
<p><br/>
而使用下面这个更简短的版本：<br/>
</p>
<p><br/>
<code>lsof -c foo</code><br/>
</p>
<p><br/>
事实上，你可以只制定进程名称的开头：<br/>
</p>
<p><br/>
<code>lsof -c apa</code><br/>
</p>
<p><br/>
这会列出所有以apa开头的进程打开的文件<br/>
</p>
<p><br/>
你同样可以制定多个-c参数：<br/>
</p>
<p><br/>
<code>lsof -c apache -c python</code><br/>
</p>
<p><br/>
这会列出所有由apache和python打开的文件<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">列出所有由某个用户或某个进程打开的文件</h3>
<div class="outline-text-3" id="text-1-6">


<p><br/>
<code>lsof -u pkrumins -c apache</code><br/>
</p>
<p><br/>
你也可以组合使用多个选项，这些选项默认进行或关联，也就是说上面的命令会输入由pkrumins用户或是apache进程打开的文件。<br/>
</p>
<p><br/>
列出所有由一个用户与某个进程打开的文件<br/>
</p>
<p><br/>
<code>lsof -a -u pkrumins -c bash</code><br/>
</p>
<p><br/>
-a参数可以将多个选项的组合条件由或变为与，上面的命令会显示所有由pkrumins用户以及bash进程打开的文件。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">列出除root用户外的所有用户打开的文件</h3>
<div class="outline-text-3" id="text-1-7">


<p><br/>
<code>lsof -u ^root</code><br/>
</p>
<p><br/>
注意root前面的^符号，它执行取反操作，因此lsof会列出所有root用户之外的用户打开的文件。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">列出所有由某个PID对应的进程打开的文件</h3>
<div class="outline-text-3" id="text-1-8">


<p><br/>
<code>lsof -p 1</code><br/>
</p>
<p><br/>
-p选项让你可以使用进程id来过滤输出。<br/>
</p>
<p><br/>
记住你也可以用都好来分离多个pid。<br/>
</p>
<p><br/>
<code>lsof -p 450,980,333</code><br/>
</p>
<p><br/>
列出所有进程打开的文件除了某个pid的<br/>
</p>
<p><br/>
<code>lsof -p ^1</code><br/>
</p>
<p><br/>
同前面的用户一样，你也可以对-p选项使用^来进行取反。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">列出所有网络连接</h3>
<div class="outline-text-3" id="text-1-9">


<p><br/>
<code>lsof -i</code><br/>
</p>
<p><br/>
lsof的-i选项可以列出所有打开了网络套接字（TCP和UDP）的进程。<br/>
</p>
<p><br/>
列出所有TCP网络连接<br/>
</p>
<p><br/>
<code>lsof -i tcp</code><br/>
</p>
<p><br/>
也可以为-i选项加上参数，比如tcp，tcp选项会强制lsof只列出打开TCP sockets的进程。<br/>
</p>
<p><br/>
列出所有UDP网络连接<br/>
</p>
<p><br/>
<code>lsof -i udp</code><br/>
</p>
<p><br/>
同样udp让lsof只列出使用UDP socket的进程。<br/>
</p>
<p><br/>
找到使用某个端口的进程<br/>
</p>
<p><br/>
<code>lsof -i :25</code><br/>
</p>
<p><br/>
:25和-i选项组合可以让lsof列出占用TCP或UDP的25端口的进程。<br/>
</p>
<p><br/>
你也可以使用/etc/services中制定的端口名称来代替端口号，比如：<br/>
</p>
<p><br/>
<code>lsof -i :smtp</code><br/>
</p>
<p><br/>
找到使用某个udp端口号的进程<br/>
</p>
<p><br/>
<code>lsof -i udp:53</code><br/>
</p>
<p><br/>
同样的，也可以找到使用某个tcp端口的进程：<br/>
</p>
<p><br/>
<code>lsof -i tcp:80</code><br/>
</p>
<p><br/>
找到某个用户的所有网络连接<br/>
</p>
<p><br/>
<code>lsof -a -u hacker -i</code><br/>
</p>
<p><br/>
使用-a将-u和-i选项组合可以让lsof列出某个用户的所有网络行为。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10">列出所有NFS（网络文件系统）文件</h3>
<div class="outline-text-3" id="text-1-10">


<p><br/>
<code>lsof -N</code><br/>
</p>
<p><br/>
这个参数很好记，-N就对应NFS。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-11" class="outline-3">
<h3 id="sec-1-11">列出所有UNIX域Socket文件</h3>
<div class="outline-text-3" id="text-1-11">


<p><br/>
<code>lsof -U</code><br/>
</p>
<p><br/>
这个选项也很好记，-U就对应UNIX。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-12" class="outline-3">
<h3 id="sec-1-12">列出所有对应某个组id的进程</h3>
<div class="outline-text-3" id="text-1-12">


<p><br/>
<code>lsof -g 1234</code><br/>
</p>
<p><br/>
进程组用来来逻辑上对进程进行分组，这个例子查找所有PGID为1234的进程打开的文件。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-13" class="outline-3">
<h3 id="sec-1-13">列出所有与某个描述符关联的文件</h3>
<div class="outline-text-3" id="text-1-13">


<p><br/>
<code>lsof -d 2</code><br/>
</p>
<p><br/>
这个命令会列出所有以描述符2打开的文件。<br/>
</p>
<p><br/>
你也可以为描述符指定一个范围：<br/>
</p>
<p><br/>
<code>lsof -d 0-2</code><br/>
</p>
<p><br/>
这会列出所有描述符为0，1，2的文件。<br/>
</p>
<p><br/>
-d选项还支持其它很多特殊值，下面的命令列出所有内存映射文件：<br/>
</p>
<p><br/>
<code>lsof -d mem</code><br/>
</p>
<p><br/>
txt则列出所有加载在内存中并正在执行的进程：<br/>
</p>
<p><br/>
<code>lsof -d txt</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-14" class="outline-3">
<h3 id="sec-1-14">输出使用某些资源的进程pid</h3>
<div class="outline-text-3" id="text-1-14">


<p><br/>
<code>lsof -t -i</code><br/>
</p>
<p><br/>
-t选项输出进程的PID，你可以将它和-i选项组合输出使用某个端口的进程的PID，下面的命令将会杀掉所有使用网络的进程：<br/>
</p>
<p><br/>
<code>kill -9 `lsof -t -i`</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-15" class="outline-3">
<h3 id="sec-1-15">循环列出文件</h3>
<div class="outline-text-3" id="text-1-15">


<p><br/>
<code>lsof -r 1</code><br/>
</p>
<p><br/>
-r选项让lsof可以循环列出文件直到被中断，参数1的意思是每秒钟重复打印一次，这个选项最好同某个范围比较小的查询组合使用，比如用来监测网络活动：<br/>
</p>
<p><br/>
<code>lsof -r 1 -u john -i -a</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-16" class="outline-3">
<h3 id="sec-1-16">如何安装lsof？</h3>
<div class="outline-text-3" id="text-1-16">


<p><br/>
许多Unix系统都内置了lsof，如果你的系统没有安装，你可以从这里直接下载源代码。<br/>
</p>
<p><br/>
BSD系统有一个类似的工具可以做同样的事情，叫做fstat。<br/>
</p>
<p><br/>
你可以通过man lsof来了解关于lsof的完整文档，或者通过lsof -h查看。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-17" class="outline-3">
<h3 id="sec-1-17">原文</h3>
<div class="outline-text-3" id="text-1-17">

<p><a href="http://www.catonmat.net/blog/unix-utilities-lsof/">http://www.catonmat.net/blog/unix-utilities-lsof/</a><br/>
还有pipe view和netcat，以后再总结<br/>
翻译：<br/>
<a href="http://heikezhi.com/2011/06/19/swiss-army-knife-of-unix-debugging-lsof/">http://heikezhi.com/2011/06/19/swiss-army-knife-of-unix-debugging-lsof/</a><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[functional-programming-is-hard-thats-why-its-good]]></title>
    <link href="http://emmoblin.github.com/blog/2012/09/11/functional-programming-is-hard-thats-why-its-good/"/>
    <updated>2012-09-11T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/09/11/functional-programming-is-hard-thats-why-its-good</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">functional-programming-is-hard-thats-why-its-good</a>
<ul>
<li><a href="#sec-1-1">函数式编程很难，这正是你要学习它的原因</a>
<ul>
<li><a href="#sec-1-1-1">它给你的初次印象不友善</a></li>
<li><a href="#sec-1-1-2">新奇事物</a></li>
<li><a href="#sec-1-1-3">眼见为实</a></li>
<li><a href="#sec-1-1-4">各有所求</a></li>
<li><a href="#sec-1-1-5">补充</a></li>
<li><a href="#sec-1-1-6">转载自: http://www.aqee.net/functional-programming-is-hard-thats-why-its-good/</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/09/11/functional-programming-is-hard-thats-why-its-good/">functional-programming-is-hard-thats-why-its-good</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">函数式编程很难，这正是你要学习它的原因</h3>
<div class="outline-text-3" id="text-1-1">

<p>很奇怪不是，很少有人每天都使用函数式编程语言。如果你用Scala，Haskell，Erlang，F#或某个Lisp方言来编程，很可能没有公司会花钱聘你。这个行业里的绝大部分人都是使用像Python，Ruby，Java或C#等面向对象的编程语言——它们用起来很顺手。不错，你也许会偶然用到一两个“函数式语言特征”，例如“block”，但人们不会去做函数式编程。<br/>
</p>
<p><br/>
然而，很多年来，我们一直被教导说函数式编程语言很好很棒。我仍然记得当我第一次阅读ESR的著名的关于学习Lisp语言的论文时的困惑。也许大多数的人对Paul Graham 的《Beating The Averages》这篇文章更加熟悉：<br/>
</p>
<p><br/>
使用Lisp开发使我们的开发周期迭代的如此之快，以至于有时当竞争对手在新闻发布会上推出他们的新功能一两天后，我们就能复制出同样的功能。当报道产品发布的新闻记者打电话给我们时，我们的产品已经拥有了同样的功能特征。<br/>
</p>
<p><br/>
那些皈依函数式编程的人中，一直常见的考虑是：学习这种新的、函数式的语言“对你有好处”；就像是某些人建议说每天30分钟的健身房活动会“让你的身体健康”一样。但这也同时暗示了这样做的难度和需要的付出。Lisp语言跟Haskell、Ocaml和Scala语言不同，被认为是出了名的难学，可以说是臭名昭著。文雅的人说这是Lisp语言的“深度&amp;广度”的体现。不文雅的人说这是“意淫”或“玩弄学术”或简单的“没必要”。我认为，它的难度跟你对它熟不熟悉有关，而且，这种难度是一种重要指标显示：学习这样的一种语言会让你编程更有效率、能力更强。<br/>
</p>
<p><br/>
<!-- more -->

</p>
</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">它给你的初次印象不友善</h4>
<div class="outline-text-4" id="text-1-1-1">


<p><br/>
我7岁时就开始编程，在漫长无聊的郊区夏季里，在我祖父的计算机上瞎搞一气。我学了BASIC，用它在屏幕上画一个蹦跳的球。我学了Pascal，用它写了一个能通过PC喇叭放音乐的程序。大概10岁时我学了C语言，但遇到了一堵越不过去的墙，直到我上了高中。那就是：指针。即使不算这些该死的指针，我写、读、学习、练习中，同样遭遇无数的失败。我把祖父的硬盘给毁掉了两次(一次属意外)，最后弄得不少次要自己重装操作系统。我失败，一遍遍的失败。<br/>
</p>
<p><br/>
也许你也有跟我相似的故事，也许是完全不同的一个。但我想，差不多所有学过编程的人都有过遇到困难的经历。我们在学了一些基本知识后，必然会遇到一些公认的概念上的关口，比如“指针”。很多计算机科学教授会把指针描述为他们课程上的过滤网。如果你想成为一名优秀的程序员，你必须要能理解指针。很少人能轻松的掌握它们。大多数人，包括我，则需要不断的练习和参考例子来理解什么是指针、为什么它们很重要。<br/>
</p>
<p><br/>
这种艰难的努力过程不是偶然的，是一种几乎普遍的现象。指针是一种非常强大和基础功能的概念。学会它能让你成为一名更好的程序员，能让你的思考更加形象化。即使你使用的语言并不提供指针这样的特征，但跟指针类似的数据结构和概念却随处可见。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">新奇事物</h4>
<div class="outline-text-4" id="text-1-1-2">


<p><br/>
一旦你学会了几种语言后，所有的语言都开始看起来都很相似。知道Python的人学习Ruby可能不会遇到太多的问题，知道Java的人学习C#会感到很熟悉。不错，也有意外的地方。Ruby爱好者在学习Python时会对它的comprehension感到吃惊，Java用户会对C#里的委派摸不着头脑。还是那句话，如果你只瞟一眼，它们都很相似。我可以打保票的说，如果你还不曾有过这样的认识，一旦你学了一种Lisp语言，你会发现所有的Lisp变种都很相似。<br/>
</p>
<p><br/>
有人说，大部分人第一次使用Haskell或Ocaml时都完全的不知所措。见鬼了，在Haskell里，连分号都跟别人不一样。这并不是语法的问题；Haskell和ML语言完全基于一种不同的概念、一种新的语言范式。你需要用不同的方式开发应用，不同的方式组织应用，不同的方式扩展应用。<br/>
</p>
<p><br/>
很多这样的新概念都具有不可思议的强大力量。Haskell里的Monads 是跟指针一样基础且强大的概念(你很可能在不知道它叫什么的情况下就已经使用过它们了)。所以，跟学了Java后再学C#不一样，有志向学习函数式语言的人需要往回走的更远，去学习更加基础的概念后才能接下去学习。就像是完全再学习一次指针。并且，就像是当年我们刚开始学习编程一样，一些很大的概念看起来会让人迷惑茫然，让人沮丧，直到你去攻克(以及失败)它们。<br/>
</p>
<p><br/>
吃下你的药丸，找到你的药剂师<br/>
</p>
<p><br/>
尽管不好学，但我坚信，学习这些函数式编程语言会在职业上对你有好处。我相信有些人读到这点时会眼睛翻起来向天看，很难想象出这些monoids 或 monad 会对他们在使用Java或C#时有用处。对我而言，我已经不惊奇于由于这样的思维而阻止他们学习函数式语言的现象；他们需要学习一种跟指针和递归一样基础的新概念。他们需要有一种只有专业人员在完成清晰的商业目标时才具有的耐心和斗志。很少人能在过了可塑的年龄后还受得了挫折——一次又一次的挫折——否则我们现在都早成专家了，不是吗？<br/>
</p>
<p><br/>
还有更复杂的东西，有大量的语言和算法研究都是用函数式语言实施的(尤其是Haskell)。你很容易会被这些不熟悉的概念——例如范畴论， half-finished abstractions，一些失败的研究——弄的迷失方向。没有一个清晰的指导(比如由一个实用主义的作者写的一本好书)，本来已经很困难的学习任务变的更加可怕。<br/>
</p>
<p><br/>
这些叠加起来的复杂因素导致了不出意外的结果：很多人不情愿在函数式编程学习中投入时间。很容易理解这种不情愿，“我干嘛不把花在学习这些东西的时间用在实现什么东西上呢？”但这种思路也表明了你永远不愿意在任何新技术上浪费时间(只用自己熟悉的)。在一个像软件技术这样日新月异的产业里，我不认为这是正确的判断。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">眼见为实</h4>
<div class="outline-text-4" id="text-1-1-3">


<p><br/>
学习一种函数式编程语言最显而易见的好处是，你能学会这种类型语言中的函数式概念。它能帮助你的大脑，让它具有能非常清晰的思考和处理一些惊人的重大概念的能力。这并不是函数式编程具有魔法；各种语言和范式的出现都是为了应对某一特定类别的问题。函数式编程的杀手锏正是应对了当今世界上日益增长的并行性编程和元数据编程趋势。<br/>
</p>
<p><br/>
例如，我们研究一个简化的、本地版本化的Google著名的MapReduce范例。用函数式方式描述这种范例是不可思议的清晰简洁：<br/>
</p>
<p><br/>
</p>
<p><br/>
<pre class="example">mapReducer data partitioner mapper reducer =
              let partitions = partitioner data
              in reduce reducer (map mapper partitions)
</pre>

让这样的代码支持并行计算或分布式并行计算是轻而易举的(对于本地并行计算，很多的功能包都支持“pmap”和“preduce“——只需要利用函数式语言的一些简单特性)。像maps, partitions, generators, streams, reductions, folds, 已以及 function chaining等概念在各种的函数式编程语言中都大同小异，所以，任何对Lisp，Haskell，OCaml，甚至带点函数式语言特征的语言——Python和Ruby熟悉的人，都会很容易的理解这里面的思想精华。<br/>
</p>
<p><br/>
让我们花点时间考虑一下，如何用一种面向对象的语言，以一种常见的面向对象的模式来清楚的描述这种架构。至少你需要做的事情是定义用来描述mapper和reducer的声明。如果你有好奇心，请试着用你喜欢的面向对象语言描述一个最小化的“面向对象”的MapReduce。我发现那是非常罗嗦的。如果使用Java风格的语言，它会像这样：<br/>
</p>
<p><br/>
</p>
<p><br/>
<pre class="example">interface Mapper {
   B map(A input);
 }

 interface Reducer {
   Y reduce(X a, X b);
 }

 abstract class MapReduce {
   private Mapper mapper;
   private Reducer reducer;

   public MapReduce(Mapper map, Reducer reduce) {
     // ...
   }

   public run(SeqenceType data) {
     // ...
   }
 }
</pre>

即使是没有加入循环逻辑，这种缺乏函数式模式中常见的名词和动词的使用，使得MapReduce这种技术很难被定义。这种定义方式几乎是滑稽可笑的，但它能让你想到函数式概念。另外一个好例子是Scala语言如何利用完备的Java Fork/Join 类库，把它轻松的集成的自己的自有语法中。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">各有所求</h4>
<div class="outline-text-4" id="text-1-1-4">


<p><br/>
所以，我鼓励任何想进步的程序员：请考虑学习一种函数式语言。Haskell和OCaml都是极好的选择，F#和Erlang也相当的不错。它们都不好学，但也许这是个好事。努力弄清楚你遇到的复杂的概念，看看是否有其他人正在利用这些概念；经常的，你会在寻找这些不熟悉的概念的真正用意的时候实现思想上的突破。<br/>
</p>
<p><br/>
当你开始学的时候，请注意，不要过于在意。就像其他任何需要你花时间和精力的事情一样，过度的在函数式编程上进行精力上的投资是很危险的。掉进了认知能力的陷阱后你的投资会血本无归。你很容易会忘掉世界上还有无数种计算模型，你更容易忘掉有多少种优秀的软件根本没有使用任何的函数式概念。<br/>
</p>
<p><br/>
学习的道路会越来越难走，但从另一方面说，在你日常的编程中，你会发现有越来越多的可以使用的重要概念和模型。对于这样紧凑的编程风格你会越来越适应，必然，你也会对如何成为一名更好的软件工程师有了新的认识。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-5" class="outline-4">
<h4 id="sec-1-1-5">补充</h4>
<div class="outline-text-4" id="text-1-1-5">


<p><br/>
有不少校对这篇文章的人在看完文章后都问了我一个同样的问题：“听起来不错，大卫，可是我应该学习那种语言呢？”当然，这是他们给我出的难题。<br/>
</p>
<p><br/>
我想，如果你是一个很有经验的程序员，这最能“应付”这个问题的答案是：“选一种符合你的需求的”。如果你需要在JVM上工作，选择Scala或Clojure。如果你想能快速的开发大型分布式软件系统，选择Erlang。如果你想要一种具有超强编译器的超能干活的语言，请选择Haskell或RCaml。如果你想要一种比Ruby或Python更有能力的原型工具，选择Scheme。<br/>
</p>
<p><br/>
请记住，我们在这里要做的这些目的是为了实际的技能和自我进步。如果你能腾出时间学这些，就走出你的安逸环境，挑战自己。<br/>
</p>
<p><br/>
因为我已经学习了Lisp和Erlang，而且使用OCaml做专业工作，我决定研究一下Haskell，这完全是另外一个世界。我发现唯一能帮助我参透这种语言的途径是依赖Learn You A Haskell 和 Real World Haskell 这两本有用的指导材料。这些书写的非常好，很有价值，而且可以免费在网上找到。如果你想试一下Haskell，这些书可以当作你的寻宝图。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-6" class="outline-4">
<h4 id="sec-1-1-6">转载自: <a href="http://www.aqee.net/functional-programming-is-hard-thats-why-its-good/">http://www.aqee.net/functional-programming-is-hard-thats-why-its-good/</a></h4>
<div class="outline-text-4" id="text-1-1-6">

</div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[can your programming language do this]]></title>
    <link href="http://emmoblin.github.com/blog/2012/09/11/can-your-programming-language-do-this/"/>
    <updated>2012-09-11T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/09/11/can-your-programming-language-do-this</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">can your programming language do this</a>
<ul>
<li><a href="#sec-1-1">你的编程语言能这样做吗？</a></li>
<li><a href="#sec-1-2">转载自</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/09/11/can-your-programming-language-do-this/">can your programming language do this</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">你的编程语言能这样做吗？</h3>
<div class="outline-text-3" id="text-1-1">

<p>一日，你查看你的程序代码，你有两大块代码看起来几乎完全的一样。事实上它们就是完全一样，除了一个代码里说的是“Spaghetti(意大利面条)”，另一个代码里说的是“Chocolate Moose(巧克力慕丝)”。<br/>
</p>
<p><br/>
<pre class="example">// 一个小例子：

alert("I'd like some Spaghetti!");
alert("I'd like some Chocolate Moose!");
</pre>

这个例子恰好是用Javascript写的，但即使是你不懂Javascript，你也应该能看懂我说的。<br/>
</p>
<p><br/>
当然，重复的代码看起来不太好。所以你决定写一个函数：<br/>
</p>
<p><br/>
<pre class="example">function SwedishChef( food )
{
    alert("I'd like some " + food + "!");
}

SwedishChef("Spaghetti");
SwedishChef("Chocolate Moose");
</pre>


没错，这个例子很简单，但你可以想出一些更有实际价值的例子。这样做是更好一些，有很多理由，这些理由估计你都听说过一万遍了。可维护性，可读性，抽象 = 好！<br/>
</p>
<p><br/>
<!-- more -->

现在，你又发现两块代码几乎完全一样，除了一块是不停的调用一个叫BoomBoom的函数，而一块是不停的调用一个叫PutInPot的函数。除此之外，这两块代码完全一样。<br/>
</p>
<p><br/>
<pre class="example">alert("get the lobster");
PutInPot("lobster");
PutInPot("water");

alert("get the chicken");
BoomBoom("chicken");
BoomBoom("coconut");
</pre>

现在，你需要一个途径，把一个参数传递到一个函数里，而这个参数本身是个函数。这是一个很重要的功能，它是一个好的方法，能让你发现函数中存在的重复的代码，减少这样的重复。<br/>
</p>
<p><br/>
<pre class="example">function Cook( i1, i2, f )
{
    alert("get the " + i1);
    f(i1);
    f(i2);
}

Cook( "lobster", "water", PutInPot );
Cook( "chicken", "coconut", BoomBoom );
</pre>

看见了没！我们把一个函数当做了参数。<br/>
</p>
<p><br/>
你的语言能这样做吗？<br/>
</p>
<p><br/>
且慢… 如果你还没有写出PutInPot 或 BoomBoom 函数呢。如果你能把他们写成内联函数，而不是要在其它地方先声明，这样是不是更好？<br/>
</p>
<p><br/>
<pre class="example">Cook( "lobster", 
      "water", 
      function(x) { alert("pot " + x); }  );
Cook( "chicken", 
      "coconut", 
      function(x) { alert("boom " + x); } );
</pre>

老天，这太方便了。注意到了没有，我即时创建了一个方法，甚至都不用麻烦给它起名，只需掂着它的耳朵把它丢进函数里。<br/>
</p>
<p><br/>
当你开始思考把匿名函数当作参数时，你也许会注意到有一种代码到处都是，就是，遍历数组里的所有元素进行操作。<br/>
</p>
<p><br/>
<pre class="example">var a = [1,2,3];

for (i=0; i&lt;a.length; i++)
{
    a[i] = a[i] * 2;
}

for (i=0; i&lt;a.length; i++)
{
    alert(a[i]);
}
</pre>

对数组里的每个元素进行操作是一种很常见的动作，你可以写出一个函数，让它为你做这些：<br/>
</p>
<p><br/>
<pre class="example">function map(fn, a)
{
    for (i = 0; i &lt; a.length; i++)
    {
        a[i] = fn(a[i]);
    }
}
</pre>

现在，你可以把上面的代码重写成这样：<br/>
</p>
<p><br/>
<pre class="example">map( function(x){return x*2;}, a );
map( alert, a );
</pre>

另一个常见的跟数组相关的操作是，通过某种方式把数组里的所有值组合到一起。<br/>
</p>
<p><br/>
<pre class="example">function sum(a)
{
    var s = 0;
    for (i = 0; i &lt; a.length; i++)
        s += a[i];
    return s;
}

function join(a)
{
    var s = "";
    for (i = 0; i &lt; a.length; i++)
        s += a[i];
    return s;
}

alert(sum([1,2,3]));
alert(join(["a","b","c"]));
</pre>

sum 和 join 看起来非常的相似，你也许会想把它们的通用之处提取出来做成一个能把数组里的元素合并成一个值的通用函数：<br/>
</p>
<p><br/>
</p>
<p><br/>
<pre class="example">function reduce(fn, a, init)
{
    var s = init;
    for (i = 0; i &lt; a.length; i++)
        s = fn( s, a[i] );
    return s;
}

function sum(a)
{
    return reduce( function(a, b){ return a + b; }, 
                   a, 0 );
}

function join(a)
{
    return reduce( function(a, b){ return a + b; }, 
                   a, "" );
}
</pre>

很多老式的语言根本没有方法做出这种事情。另外一些语言允许你做这些，但不容易(例如，C语言里有函数指针，但你必须进行声明，并要在什么地方定义它)。面向对象的语言并没有被证实可以允许你对函数做所有的操作。<br/>
</p>
<p><br/>
如果你想在Java里把函数作为一个一等(First Class)对象，你需要建一个只包含一个用来调用功能点的方法的整个对象。把这种现象跟实际情况联系起来，很多的面向对象语言都会要求你为每个class创建一个完整的文件，非常的没效率。如果你的编程语言里要求你去这样的调用功能点，那你根本没有享受到现代语言环境给你带来的所有好处。看看能否退货吧，挽回一点损失。<br/>
</p>
<p><br/>
写这样的小函数，只是做一些遍历数组，处理其中的每个元素的操作，这样做究竟能得到多少好处？<br/>
</p>
<p><br/>
那好，我们来回头看一看map这个函数。当你需要对数组里的每个元素依次做一些操作时，实际情况是，你并不在乎处理这些元素的顺序。你可以向前或向后遍历整个数组，得到的结果是一样的，不是吗？ 事实上，如果你的机器是2cpu的，你可以写出一些程序让每个cpu个处理一半的元素，你的map一下子就变快了2倍。<br/>
</p>
<p><br/>
或者，只是个假设，在你遍布全球的数个数据中心里，你有成千上万的服务器，你有一个非常非常大的数组，我说过，只是假设，它们装载着整个互联网的内容信息。那现在，你就可以在你的成千上万的计算机上运行map函数，每个机器都能分摊掉计算中的一小部分任务。<br/>
</p>
<p><br/>
所以，如今，举个例子，要想写出一个十分高效的能搜索整个互联网内容信息的代码，你只需要简单的用基本搜索字符串当作参数来调用map函数就行了。<br/>
</p>
<p><br/>
这里，我想请你们要真正注意的有趣的事情是，你会发现像map 和 reduce这样的函数每个人都可以使用，当人们使用它时，你只需要找到一个编程能手写出最困难的调用map 和 reduce 函数的代码，让它们能够运行在全球大量的并行执行的计算机上，而以前旧的运行的很好的代码只需要调用这个循环操作，唯一不同的是，它们获得了比以前千万倍快的速度，这意味着你能做瞬间处理完巨大的计算工作。<br/>
</p>
<p><br/>
让我再复述一遍。通过把通用的循环操作提取出来，你可以实现你想要的任何循环操作，包括实现出一种能随硬件设备的增加而性能升级的效果。<br/>
</p>
<p><br/>
我想现在你就该明白为什么我在前段时间写的一篇文章里抱怨学校只教授计算机科学专业的学生Java知识而忽略其它：<br/>
</p>
<p><br/>
缺乏对函数式编程的理解，你不可能发明出MapReduce——这个能够让Google实现大规模按需扩展和升级的算法。Map和Reduce这两个词来自于Lisp语言和函数式编程。回首看来，MapReduce对于任何还存有记忆的人来说都意味着一种纯函数式的编程，没有副作用，易于并行计算。事实恰巧是Google发明了MapReduce，而微软没有，这就说明了为什么微软仍然努力做那些基本的搜索功能研究的原因了，而Google已经开始了它的下一个目标：开发它的Skynet^H^H^H^H^H^H——这世界上最大规模的并行超级计算机。我并不觉得微软已经认识到在如今的潮流中它已经落后的多远。<br/>
</p>
<p><br/>
那么，我希望现在你已经能理解了以函数为一等(First class)特征编程语言能使你更容易的对代码进行提炼抽象，这意味着你的代码更短小，紧凑，可复用性强，更容易扩展升级。大量的Google应用程序都使用了MapReduce，在他们优化程序或修改Bug时，都能从中得到益处。<br/>
</p>
<p><br/>
现在我要说一点怨言牢骚，最高效的语言开发环境应该是一种能让你在不同层次上进行抽象归纳的语言环境。笨拙陈旧的FORTRAN语言甚至不允许你写函数。C语言里有函数指针，但实现的很丑陋，不能匿名，使用之前必须先进行声明实现。Java允许你使用功能点调用(functor)，但更加丑陋。就像Steve Yegge指出的，Java就是一个名词的王国。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">转载自</h3>
<div class="outline-text-3" id="text-1-2">

<p>   <a href="http://www.aqee.net/can-your-programming-language-do-this/">http://www.aqee.net/can-your-programming-language-do-this/</a><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
</feed>
