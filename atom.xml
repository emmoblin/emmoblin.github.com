<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Emmoblin Blog]]></title>
  <link href="http://emmoblin.github.com/atom.xml" rel="self"/>
  <link href="http://emmoblin.github.com/"/>
  <updated>2013-03-03T00:06:30+08:00</updated>
  <id>http://emmoblin.github.com/</id>
  <author>
    <name><![CDATA[emmoblin]]></name>
    <email><![CDATA[emmoblin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[nc使用]]></title>
    <link href="http://emmoblin.github.com/blog/2013/02/27/netcat/"/>
    <updated>2013-02-27T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/02/27/netcat</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">基本使用</h3>
<div class="outline-text-3" id="text-1-1">

<p>本地监听<br/>
<code>nc -l 3333</code><br/>
远端访问<br/>
<code>nc 192.168.0.1 3333</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">传送文件</h3>
<div class="outline-text-3" id="text-1-2">

<p>发送端<br/>
<code>cat backup.iso | nc -l 3333</code><br/>
接收端<br/>
<code>nc 192.168.0.1 3333 &gt; backup.iso</code><br/>
</p>
<p><br/>
显示传送进度，可以使用管道监控,pv命令<br/>
以上命令修改为：<br/>
<code>cat backup.iso | pv -b | nc -l 3333</code><br/>
<code>nc 192.168.0.1 3333 | pv -b &gt; backup.iso</code><br/>
</p>
<p><br/>
本地打包文件，传送到远端<br/>
<code>tar -czf - /etc/ | nc -l 3333</code><br/>
接收端<br/>
<code>nc 192.168.0.1 3333 | pv -b &gt; mybackup.tar.gz</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">端口扫描</h3>
<div class="outline-text-3" id="text-1-3">

<p>扫描端口，并返回相关信息<br/>
<code>nc -z 192.168.0.1 80-90</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">资料</h3>
<div class="outline-text-3" id="text-1-4">

<p><a href="http://www.sans.org/security-resources/sec560/netcat_cheat_sheet_v1.pdf">http://www.sans.org/security-resources/sec560/netcat\_cheat\_sheet\_v1.pdf</a><br/>
<a href="http://www.g-loaded.eu/2006/11/06/netcat-a-couple-of-useful-examples/">http://www.g-loaded.eu/2006/11/06/netcat-a-couple-of-useful-examples/</a><br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建dns服务器]]></title>
    <link href="http://emmoblin.github.com/blog/2013/02/20/dnsserver/"/>
    <updated>2013-02-20T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/02/20/dnsserver</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">搭建dns服务器</a>
<ul>
<li><a href="#sec-1-1">首先提出一些问题</a></li>
<li><a href="#sec-1-2">BIND服务</a></li>
<li><a href="#sec-1-3">配置文件</a></li>
<li><a href="#sec-1-4">参考</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/20/dnsserver/">搭建dns服务器</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">首先提出一些问题</h3>
<div class="outline-text-3" id="text-1-1">

<ol>
<li>什么是 DNS 的授权模式﹖是怎样进行的?<br/>
</li>
<li>zone 和 domain 的差别?<br/>
</li>
<li>什么是 DNS 正解和反解?<br/>
</li>
<li>什么是 DNS 的查询模式?<br/>
</li>
<li>查询过程是怎样进行的?<br/>
</li>
<li>DNS cache 的作用和它对查询流程的影响?<br/>
</li>
</ol>


<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">BIND服务</h3>
<div class="outline-text-3" id="text-1-2">

<p>在 Linux 上面﹐提供 DNS 服务的套件是叫 bind，<br/>
但执行服务程序名称则是 named。<br/>
请您确定系统上装有 bind﹑bind-utils﹑以及 caching-nameserver 这几个套件。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">配置文件</h3>
<div class="outline-text-3" id="text-1-3">

<p>/etc/named.conf<br/>
如果安装的是bind-chroot，则文件在<br/>
/var/named/chroot/etc/named.conf<br/>
</p>
<p><br/>
/var/named/chroot/etc/named.caching-nameserver.conf<br/>
这个是主要配置文件的模板配置文件（区域模板配置文件<br/>
</p>
<p><br/>
首先生成主要配置文件，复制出一份模板配置文件到此目录下，并更改名字为named.conf <br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #a52a2a;">cd</span>  /var/named/chroot/etc    
cp  named.caching-nameserver.conf  named.conf
</pre>


默认会有三个配置：<br/>
</p>
<p><br/>
<pre class="example">zone "." IN {
  type hint;
  file "named.ca";
};
</pre>

根区域“ . ”(root zone) 的设定﹐同时它是一个 internet ( IN ) 的区域类别( class )。这里还指定了root zone 的服务器种类( type ) 为“hint”(也只有这个 zone 会使用这样的种类)。最后﹐用 file 指定这个区域记录文件为﹕“named.ca”﹐也就是“/var/named/named.ca”档案。<br/>
</p>
<p><br/>
在 root zone 后面﹐您应该还会看到如下这两段,一个是localhost的正向解析，一个是反向解析。不允许自行更新DNS记录。<br/>
</p>
<p><br/>
<pre class="example">zone "localhost" IN {
  type master;
  file "localhost.zone";
  allow-update { none; };
};

zone "0.0.127.in-addr.arpa" IN {
  type master;
  file "named.local";
  allow-update { none; };
}; 
</pre>


首先来看root zone，named.ca<br/>
里边的记录类似如下：<br/>
</p>
<p><br/>
<pre class="example">. 3600000 NS L.ROOT-SERVERS.NET.
L.ROOT-SERVERS.NET. 3600000 A 198.32.64.12
</pre>

以‘ . ’开头的﹐那就是所谓的 root zone 了﹗<br/>
第二栏都是‘ 3600000 ’﹐这是 TTL (Time To Live) 设定﹐也就是在 cache 中保留的时间，<br/>
其后的‘ NS ’是“Name Server”的意思﹐是 DNS 记录名称之一﹐也就是负责这个记录的 name server 是哪一台主机。<br/>
‘ A ’记录﹐也就是 Address 的意思﹐解释 [A-M].ROOT-SERVER.NET. 这些主机各自的 IP 地址所在。<br/>
</p>
<p><br/>
如果您了解 DNS 的查询模式﹐您会知道 DNS 服务器在查询非自己管辖的 zone 的时候﹐首先会向 root 查询下一级的 zone 在哪里﹐然后逐级查询下去。但问题是﹕当 named 刚启动的时候﹐在 cache 里面一片空白﹐它怎么知道 root zone 的 servers 在哪里呢﹖这不是一个矛盾吗﹖所以﹐就必须靠这个档案告诉 named 关于 root zone 的 servers 有哪些﹖以及在哪里﹖<br/>
</p>
<p><br/>
locaohost.zone<br/>
</p>
<p><br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">参考</h3>
<div class="outline-text-3" id="text-1-4">

<p><a href="http://wenku.baidu.com/view/4d88c6bf960590c69ec376a2.html">http://wenku.baidu.com/view/4d88c6bf960590c69ec376a2.html</a><br/>
</p>
<p><br/>
</p>
<p><br/>
</p>
<p><br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh隧道技术]]></title>
    <link href="http://emmoblin.github.com/blog/2013/02/19/ssh-tunnel/"/>
    <updated>2013-02-19T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/02/19/ssh-tunnel</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">ssh隧道技术</a>
<ul>
<li><a href="#sec-1-1">什么情况下使用隧道</a></li>
<li><a href="#sec-1-2">建立本地隧道</a>
<ul>
<li><a href="#sec-1-2-1">通过SSH隧道建立SOCKS服务器</a></li>
</ul>
</li>
<li><a href="#sec-1-3">建立远程SSH隧道</a></li>
<li><a href="#sec-1-4">一些技巧</a>
<ul>
<li><a href="#sec-1-4-1">检查隧道状态</a></li>
<li><a href="#sec-1-4-2">如何将端口绑定到外部地址上</a></li>
<li><a href="#sec-1-4-3">自动连接和防断线脚本</a></li>
</ul>
</li>
<li><a href="#sec-1-5">动态域名</a></li>
<li><a href="#sec-1-6">参考</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/19/ssh-tunnel/">ssh隧道技术</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">什么情况下使用隧道</h3>
<div class="outline-text-3" id="text-1-1">

<ol>
<li>公司为了防止我们用XX软件封锁了它的端口或者服务器地址。<br/>
</li>
<li>nat穿越，或者叫ssh反向隧道访问内网的pc，比如：在家里访问我在公司的电脑。<br/>
</li>
</ol>


<p><br/>
通过在外网一个ssh服务器做代理，实现穿越功能。<br/>
我主要使用第二种功能，在家里访问公司的电脑。可以远程办公了。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">建立本地隧道</h3>
<div class="outline-text-3" id="text-1-2">

<p>建立本地隧道实现第一种隧道模式。<br/>
假设内网机子A要访问C，但被拒绝了，这样可以通过中间的B建立ssh本地隧道实现A-B-C的访问。<br/>
实际上这种一般不太常用，毕竟有很多代理服务器都可以方便实现代理功能。<br/>
</p>
<p><br/>
在A上执行：<br/>
</p>
<p><br/>
<pre class="src src-sh">ssh -N -f -L 2121:C:21 B
ftp localhost:2121 <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">&#29616;&#22312;&#35775;&#38382;&#26412;&#22320;2121&#31471;&#21475;&#65292;&#23601;&#33021;&#36830;&#25509;C&#30340;21&#31471;&#21475;&#20102;</span>
</pre>


这里我们用到了SSH客户端的三个参数:<br/>
-N 告诉SSH客户端，这个连接不需要执行任何命令。仅仅做端口转发<br/>
-f 告诉SSH客户端在后台运行<br/>
-L 做本地映射端口，被冒号分割的三个部分含义分别是<br/>
需要使用的本地端口号<br/>
需要访问的目标机器IP地址（IP: 234.234.234.234）<br/>
需要访问的目标机器端口（端口: 21)<br/>
最后一个参数是我们用来建立隧道的中间机器的IP地址(IP: 123.123.123.123)<br/>
</p>
<p><br/>
我们再重复一下-L参数的行为。<br/>
-L X:Y:Z 将IP为Y的机器的Z端口通过中间服务器映射到本地机器的X端口。<br/>
</p>
<p><br/>
在这条命令成功执行之后，我们已经具有绕过公司防火墙的能力，并且成功访问到了我们喜欢的一个FTP服务器了。<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">通过SSH隧道建立SOCKS服务器</h4>
<div class="outline-text-4" id="text-1-2-1">

<p>如果我们需要借助一台中间服务器访问很多资源，一个个映射显然不是高明的办法。<br/>
幸好，SSH客户端为我们提供了通过SSH隧道建立SOCKS服务器的功能。<br/>
</p>
<p><br/>
通过下面的命令我们可以建立一个通过123.123.123.123的SOCKS服务器。<br/>
ssh -N -f -D 0.0.0.0:1080 123.123.123.123 # 将端口绑定在0.0.0.0上<br/>
通过SSH建立的SOCKS服务器使用的是SOCKS5协议，在为应用程序设置SOCKS代理的时候要特别注意。<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">建立远程SSH隧道</h3>
<div class="outline-text-3" id="text-1-3">

<p>现象我想在家里访问公司内网的电脑，这时从外到内访问显然是不行的，但从公司内往外访问是正常的。<br/>
所以就是用远程ssh隧道，先通过内网ssh到B，然后通过访问B的端口就可以访问内网的A了。<br/>
</p>
<p><br/>
在A上执行：<br/>
<code>ssh -N -f -R 2222:127.0.0.1:22 B</code><br/>
现在，在B机器上我们用下面的命令就可以登陆公司的A机器了。<br/>
<code>ssh -p 2222 localhost</code><br/>
</p>
<p><br/>
我们现在重点说说参数-R。该参数的三个部分的含义分别是:<br/>
远程机器使用的端口（2222）<br/>
需要映射的内部机器的IP地址(127.0.0.1)<br/>
需要映射的内部机器的端口(22)<br/>
例如：-R X:Y:Z 就是把我们内部的Y机器的Z端口映射到远程机器的X端口上。<br/>
</p>
<p><br/>
实际上这里所说的本地隧道和远程隧道(-L,-R),实际上指的是ssh代理listen的端口在本地还是在远端。<br/>
如果在本地listen就是本地隧道，如果要是在远端listen一个端口就是远端隧道。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">一些技巧</h3>
<div class="outline-text-3" id="text-1-4">


</div>

<div id="outline-container-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">检查隧道状态</h4>
<div class="outline-text-4" id="text-1-4-1">

<p>有些时候隧道会因为一些原因通信不畅而卡死，例如：由于传输数据量太大，被路由器带入stalled状态。这种时候，往往SSH客户端并不退出，而是卡死在那里。一种应对方法是，使用SSH客户端的ServerAliveInterval和ServerAliveCountMax选项。ServerAliveInterval会在隧道无通信后的一段设置好的时间后发送一个请求给服务器要求服务器响应。如果服务器在ServerAliveCountMax次请求后都没能响应，那么SSH客户端就自动断开连接并退出，将控制权交给你的监控程序。这两个选项的设置方法分别是在ssh时加入-o ServerAliveInterval=n和-o ServerAliveCountMax=m。其中n, m可以自行定义。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">如何将端口绑定到外部地址上</h4>
<div class="outline-text-4" id="text-1-4-2">

<p>使用上面的方法，映射的端口只能绑定在127.0.0.1这个接口上。也就是说，只能被本机自己访问到。如何才能让其他机器访问这个端口呢？我们可以把这个映射的端口绑定在0.0.0.0的接口上，方法是加上参数-b 0.0.0.0。同时还需要打开SSH服务器端的一个选项－GatewayPorts。默认情况下它应当是被打开的。如果被关闭的话，可以在/etc/sshd_config中修改GatewayPorts no为GatewayPorts yes来打开它。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4-3" class="outline-4">
<h4 id="sec-1-4-3">自动连接和防断线脚本</h4>
<div class="outline-text-4" id="text-1-4-3">

<p>Linux平台ssh默认不支持把密码作为参数，不过有sshpass可以搞定<br/>
</p>
<p><br/>
<a href="http://sourceforge.net/projects/sshpass/files/latest/download">http://sourceforge.net/projects/sshpass/files/latest/download</a><br/>
</p>
<p><br/>
下载，解压，编译，把可执行文件拷贝到合适的目录，执行命令格式如下：<br/>
</p>
<p><br/>
<code>sshpass -p "password" ssh -D 7070 user@serverip</code><br/>
</p>
<p><br/>
貌似ubuntu下可以直接apt-get install sshpass<br/>
</p>
<p><br/>
然后写脚本autossh.sh，内容如下：<br/>
</p>
<p><br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">!/bin/</span><span style="color: #0000ff;">bash</span>
<span style="color: #0000ff;">while</span> [ <span style="color: #00bfff;">''</span> == <span style="color: #00bfff;">''</span> ]
<span style="color: #0000ff;">do</span>
 <span style="color: #ff1493;">ssh_d_process_num</span>=<span style="color: #ff00ff;">`ps aux|grep -E 'ssh \-' |grep -v grep |wc -l`</span>
 <span style="color: #0000ff;">if</span> [ <span style="color: #00bfff;">"$ssh_d_process_num"</span> == <span style="color: #00bfff;">"0"</span> ]; <span style="color: #0000ff;">then</span>
  /home/user/sshpass -p <span style="color: #00bfff;">"password"</span> ssh -D 7070 user@ServerIP &amp;
 <span style="color: #0000ff;">fi</span>

 sleep 300
<span style="color: #0000ff;">done</span>
</pre>


执行一下这个脚本就可以了。sleep 300代表300秒查看一次，可以根据需要调整。<br/>
</p></div>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">动态域名</h3>
<div class="outline-text-3" id="text-1-5">

<p>花生壳linux程序下载地址：<br/>
<a href="http://www.oray.com/peanuthull/download_linux.php">http://www.oray.com/peanuthull/download\_linux.php</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">参考</h3>
<div class="outline-text-3" id="text-1-6">

<p><a href="http://blog.creke.net/722.html">http://blog.creke.net/722.html</a><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IPv6 NAT MAP66]]></title>
    <link href="http://emmoblin.github.com/blog/2013/02/17/ipv6-nat-map66/"/>
    <updated>2013-02-17T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/02/17/ipv6-nat-map66</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">IPv6 NAT MAP66</a>
<ul>
<li><a href="#sec-1-1">相关的RFC</a></li>
<li><a href="#sec-1-2">IPv6子网和NAT的关系</a></li>
<li><a href="#sec-1-3">checksum无关性和自动转换</a></li>
<li><a href="#sec-1-4">Linux上的MAP66</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/17/ipv6-nat-map66/">IPv6 NAT MAP66</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">相关的RFC</h3>
<div class="outline-text-3" id="text-1-1">

<p>RFC6296的标题是IPv6-to-IPv6 Network Prefix Translation，描述了IPv6下的NAT的实现要点，给出了一个合理的建议，<br/>
既保持了IP的无方向性，又可以满足NAT的语义，这就是IPv6之NAT stateless的缘由，你不能再指望像IPv4的NAT那样只需要配置一条rule，然后反方向的rule动态生成，<br/>
IPv6情况下，两个方向的rule都需要你自己手工来配置。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">IPv6子网和NAT的关系</h3>
<div class="outline-text-3" id="text-1-2">

<p>IP地址可以划分为几个段，包括网络前缀，子网标识，主机标识，这在IPv4和IPv6中没有什么不同。<br/>
IPv4的NAT为了节约IP地址，也就是说，可供映射的IP地址pool中的地址小于或者远远小于其内部主机的数量，因此很有可能多个内部主机被映射成了同一个外部IP地址，<br/>
这如何来区分它们，因此不得不引入诸如第四层协议，端口等信息了，也就是我们熟知的五元组信息，因此IPv4的NAT实现大多数都是基于五元组流的，这样就保证了内核保持的NAT信息项的唯一性，同时也引入了很多副作用。<br/>
</p>
<p><br/>
IPv6地址持有将近128位可随意调配的位，鉴于地址空间的庞大，一般的单位都会被分配到一个拥有很大量地址的网段，<br/>
此网段拥有足够多的地址来和内网主机进行一一映射，也就是说可用于映射的IP地址pool容量巨大无比，<br/>
关键是这个一一映射如何来保持，既然不想再使用非IP层的信息来保持信息，那就要用纯IP层的信息了，这样对上层影响最小。<br/>
对于IPv4，经典NAT使用了五元组来保持流标识信息，而对于IPv6，则更加绝妙，它利用(而不是使用)了checksum的算法，丝毫不管这个checksum是谁的checksum，因为它根本就不改变数据包的checksum&hellip;<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">checksum无关性和自动转换</h3>
<div class="outline-text-3" id="text-1-3">

<p>这个很好解释，考虑<br/>
a+b+c+d=X<br/>
其中X就是checksum，我们把a，b当成源IP地址的两部分，c，d当成目的IP地址的两部分，我们作源地址转换，将a和b都改变，比如a改变成了A，<br/>
试问将b改成多少才能保持checksum的值X不变，这其实很简单，就是一个简单的一元一次方程求解的问题。<br/>
IPv6的建议NAT实现也是这个原理，只不过上面的一元一次方程是实数域的，而这个是计算机布尔数域。<br/>
既然可以不触动第四层的checksum值，那么NAT对第四层协议的影响也就减小了，虽然它还是解决不了诸如ESP/AH等穿越NAT的问题。<br/>
基于以上算法，IPv6在做NAT的时候，在给定的子网网段内，可以自动生成一个新的IP地址供映射之用，从算法本身来看，冲突的可能性非常之小致于0，<br/>
上述的做法对于IPv4几乎是不可能的，因为IPv4地址空间太小了。<br/>
既然IPv6的NAT机制“自动”为一个连接选择了一个IP地址，那么当返回包到来的时候，如何来把地址转换回原来的呢？<br/>
我们知道，IPv6的NAT已经不再使用五元组来维护NAT映射信息，也不在内核维护这种信息，那么“转换回去”这件事就要完全靠算法本身了，<br/>
恰恰就是算法本身能将转换后的地址再转回原来的，其依据就是本小节最开始处给出的一元一次方程解的唯一性，<br/>
在IPv6的NAT实现中，算法只针对IP地址中16位的地址信息进行自动生成，而其它的则需要手工显式配置，<br/>
由于内网IPv6地址可以使用MAC地址映射成唯一的地址，由于一元一次方程解的唯一性，那么转换后的地址也是唯一的，将这一切反过来，最后还是能映射回原始的IP地址的。<br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">Linux上的MAP66</h3>
<div class="outline-text-3" id="text-1-4">

<p>Linux上，IPv6的NAT MAP66是一个基本遵循RFC6296建议的Linux实现，编译安装很简单，详见其README，和IPv4的iptables一样：<br/>
1.配置正向的转换规则，将源地址fdca:ffee:babe::/64网段的地址转换为2008:db8:1::/64网段的地址<br/>
<code>ip6tables -t mangle -A POSTROUTING -s fdca:ffee:babe::/64 -o eth2 -j MAP66--src-to 2008:db8:1::/64</code><br/>
可以看出，没有显式指定任何具体地址，类似IPv4的MASQUERADE和IPv4的IP Pool<br/>
2.配置反向包的转换规则，将正向包被转换过的地址再转换回去<br/>
<code>ip6tables -t mangle -A PREROUTING -d 2008:db8:1::/64 -i eth2 -j MAP66 --dst-to fdca:ffee:babe::/64</code><br/>
可以看出，也没有显式指定任何具体的地址，更值得一提的是，内核并不维护任何关于NAT映射的信息，因此MAP66也不再依赖ip(6)_conntrack。<br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[goagent翻墙]]></title>
    <link href="http://emmoblin.github.com/blog/2013/02/14/goagent/"/>
    <updated>2013-02-14T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/02/14/goagent</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">安装</h3>
<div class="outline-text-3" id="text-1-1">

<p>安装最好直接看官网：<br/>
<a href="https://code.google.com/p/goagent/">https://code.google.com/p/goagent/</a><br/>
</p>
<p><br/>
不过为了自己方便，我也自己记录一下。<br/>
</p>
<p><br/>
在GAE注册一个appid，<a href="https://appengine.google.com/">https://appengine.google.com/</a><br/>
</p><ol>
<li>修改local\proxy.ini中的[gae]下的appid=你的appid<br/>
</li>
<li>双击server\uploader.bat(Mac/Linux上传方法请见FAQ)，上传成功后即可使用了(地址127.0.0.1:8087)<br/>
</li>
</ol>

<p>对于linux<br/>
在server目录下，python uploader.zip<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">安装python-gevent</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>参考：<a href="https://code.google.com/p/goagent/wiki/InstallGeventAndPyopensslOnUbuntu">https://code.google.com/p/goagent/wiki/InstallGeventAndPyopensslOnUbuntu</a><br/>
<code>sudo apt-get install  python-gevent</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">安装pyopenssl</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>这个一般都安装了<br/>
</p>
<p><br/>
<pre class="src src-sh">wget http://pypi.python.org/packages/source/p/pyOpenSSL/pyOpenSSL-0.13.tar.gz &amp;&amp; tar zxvf pyOpenSSL-0.13.tar.gz &amp;&amp; <span style="color: #a52a2a;">cd</span> pyOpenSSL-0.13 &amp;&amp; sudo python setup.py install
</pre>


</p></div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">Chrome下如何使用goagent</h3>
<div class="outline-text-3" id="text-1-2">

<p>Chrome可以安装switchysharp插件<br/>
然后导入local中的SwitchyOptions.bak配置文件，之后就可以选择自动切换模式，他会根据规则自动选择是否使用代理。<br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">有时goagent无法使用，解决办法</h3>
<div class="outline-text-3" id="text-1-3">

<p>可能是google_cn服务被屏蔽<br/>
我们可以在proxy.ini中将profile=google_cn改成google_hk<br/>
将[google_hk]段中的mode = http改为mode = https，重启goagent解决。<br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">遗留问题</h3>
<div class="outline-text-3" id="text-1-4">

<p>我现在使用的是2.1.12版本，发现的问题是google analytics总是提示cookiemismatch。<br/>
搜了半天也解决不了。<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[raid介绍]]></title>
    <link href="http://emmoblin.github.com/blog/2013/02/13/raid/"/>
    <updated>2013-02-13T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/02/13/raid</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">raid介绍</a>
<ul>
<li><a href="#sec-1-1">关键技术</a>
<ul>
<li><a href="#sec-1-1-1">数据校验</a></li>
</ul>
</li>
<li><a href="#sec-1-2">可管理性</a></li>
<li><a href="#sec-1-3">RAID等级</a>
<ul>
<li><a href="#sec-1-3-1">RAID0</a></li>
<li><a href="#sec-1-3-2">RAID1</a></li>
<li><a href="#sec-1-3-3">RAID2</a></li>
<li><a href="#sec-1-3-4">RAID3</a></li>
<li><a href="#sec-1-3-5">RAID4</a></li>
<li><a href="#sec-1-3-6">RAID5</a></li>
<li><a href="#sec-1-3-7">RAID6</a></li>
<li><a href="#sec-1-3-8">RAID 组合等级</a></li>
</ul>
</li>
<li><a href="#sec-1-4">linux上创建raid5</a></li>
<li><a href="#sec-1-5">资料</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/13/raid/">raid介绍</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
RAID 的两个关键目标是提高数据可靠性和 I/O 性能。<br/>
通过把相同数据同时写入到多块磁盘（典型地如镜像），或者将计算的校验数据写入阵列中来获得冗余能力，当单块磁盘出现故障时可以保证不会导致数据丢失。有些 RAID 等级允许更多地 磁盘同时发生故障，比如 RAID6 ，可以是两块磁盘同时损坏。在这样的冗余机制下，可以用新磁盘替换故障磁盘， RAID 会自动根据剩余磁盘中的数据和校验数据重建丢失的数据，保证数据一致性和完整性。数据分散保存在 RAID 中的多个不同磁盘上，并发数据读写要大大优于单个磁盘，因此可以获得更高的聚合 I/O 带宽。当然，磁盘阵列会减少全体磁盘的总可用存储空间，牺牲空间换取更高的可靠性和性能。<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">关键技术</h3>
<div class="outline-text-3" id="text-1-1">

<p>RAID 中主要有三个关键概念和技术：镜像（ Mirroring ）、数据条带（ Data Stripping ）和数据校验（ Data parity ）<br/>
数据条带，将数据分片保存在多个不同的磁盘，多个数据分片共同组成一个完整数据副本，这与镜像的多个副本是不同的，它通常用于性能考虑。数据条带具有更高的并发粒度，当访问数据时，可以同时对位于不同磁盘上数据进行读写操作， 从而获得非常可观的 I/O 性能提升 。数据校验，利用冗余数据进行数据错误检测和修复，冗余数据通常采用海明码、异或操作等算法来计算获得。利用校验功能，可以很大程度上提高磁盘阵列的可靠性、鲁棒性和容错能力。不过，数据校验需要从多处读取数据并进行计算和对比，会影响系统性能。 不同等级的 RAID 采用一个或多个以上的三种技术，来获得不同的数据可靠性、可用性和 I/O 性能。<br/>
</p>
</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">数据校验</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>采用数据校验时， RAID 要在写入数据同时进行校验计算，并将得到的校验数据存储在 RAID 成员磁盘中。校验数据可以集中保存在某个磁盘或分散存储在多个不同磁盘中，甚至校验数据也可以分块，不同 RAID 等级实现各不相同。当其中一部分数据出错时，就可以对剩余数据和校验数据进行反校验计算重建丢失的数据。校验技术相对于镜像技术的优势在于节省大量开销，但由于每次数据读写都要进行大量的校验运算，对计算机的运算速度要求很高，必须使用硬件 RAID 控制器。在数据重建恢复方面，检验技术比镜像技术复杂得多且慢得多。<br/>
海明校验码和 异或校验是两种最为常用的 数据校验算法。海明校验码是由理查德 · 海明提出的，不仅能检测错误，还能给出错误位置并自动纠正。海明校验的基本思想是：将有效信息按照某种规律分成若干组，对每一个组作奇偶测试并安排一个校验位，从而能提供多位检错信息，以定位错误点并纠正。可见海明校验实质上是一种多重奇偶校验。异或校验通过异或逻辑运算产生，将一个有效信息与一个给定的初始值进行异或运算，会得到校验信息。如果有效信息出现错误，通过校验信息与初始值的异或运算能还原正确的有效信息。<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">可管理性</h3>
<div class="outline-text-3" id="text-1-2">

<p>实际上， RAID 是一种虚拟化技术，它对多个物理磁盘驱动器虚拟成一个大容量的逻辑驱动器。对于外部主机系统来说， RAID 是一个单一的、快速可靠的大容量磁盘驱动器。这样，用户就可以在这个虚拟驱动器上来组织和存储应用系统数据。 从用户应用角度看，可使存储系统简单易用，管理也很便利。 由于 RAID 内部完成了大量的存储管理工作，管理员只需要管理单个虚拟驱动器，可以节省大量的管理工作。 RAID 可以动态增减磁盘驱动器，可自动进行数据校验和数据重建，这些都可以 大大简化管理工作。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">RAID等级</h3>
<div class="outline-text-3" id="text-1-3">


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">RAID0</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>RAID0 是一种简单的、无数据校验的数据条带化技术。<br/>
RAID0 的性能在所有 RAID 等级中是最高的。<br/>
不提供数据冗余保护，一旦数据损坏，将无法恢复。 因此， RAID0 一般适用于对性能要求严格但对数据安全性和可靠性不高的应用，如视频、音频存储、临时数据缓存空间等。<br/>
<img src="../img/raid0.png"  alt="../img/raid0.png" /><br/>
</p></div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">RAID1</h4>
<div class="outline-text-4" id="text-1-3-2">

<p>RAID1 称为镜像，它将数据完全一致地分别写到工作磁盘和镜像 磁盘，它的磁盘空间利用率为 50%<br/>
RAID1 与 RAID0 刚好相反，是为了增强数据安全性使两块 磁盘数据呈现完全镜像，从而达到安全性好、技术简单、管理方便。 RAID1 拥有完全容错的能力.<br/>
<img src="../img/raid1.png"  alt="../img/raid1.png" /><br/>
</p></div>

</div>

<div id="outline-container-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">RAID2</h4>
<div class="outline-text-4" id="text-1-3-3">

<p>RAID2 称为纠错海明码磁盘阵列，其设计思想是利用海明码实现数据校验冗余。海明码是一种在原始数据中加入若干校验码来进行错误检测和纠正的编码技术，其中第 2n 位（ 1, 2, 4, 8, … ）是校验码，其他位置是数据码。因此在 RAID2 中，数据按位存储，每块磁盘存储一位数据编码，磁盘数量取决于所设定的数据存储宽度，可由用户设定。图 4 所示的为数据宽度为 4 的 RAID2 ，它需要 4 块数据磁盘和 3 块校验磁盘。如果是 64 位数据宽度，则需要 64 块 数据磁盘和 7 块校验磁盘。可见， RAID2 的数据宽度越大，存储空间利用率越高，但同时需要的磁盘数量也越多。<br/>
海明码自身具备纠错能力，因此 RAID2 可以在数据发生错误的情况下对纠正错误，保证数据的安全性。它的数据传输性能相当高，设计复杂性要低于后面介绍的 RAID3 、 RAID4 和 RAID5 。<br/>
但是，海明码的数据冗余开销太大，而且 RAID2 的数据输出性能受阵列中最慢磁盘驱动器的限制。<br/>
<img src="../img/raid2.png"  alt="../img/raid2.png" /><br/>
</p></div>

</div>

<div id="outline-container-1-3-4" class="outline-4">
<h4 id="sec-1-3-4">RAID3</h4>
<div class="outline-text-4" id="text-1-3-4">

<p>使用专用校验盘的并行访问阵列，它采用一个专用的磁盘作为校验盘，其余磁盘作为数据盘，数据按位可字节的方式交叉存储到各个数据盘中。 RAID3 至少需要三块磁盘，不同磁盘上同一带区的数据作 XOR 校验，校验值写入校验盘中。 RAID3 完好时读性能与 RAID0 完全一致，并行从多个磁盘条带读取数据，性能非常高，同时还提供了数据容错能力。<br/>
目前， RAID5 算法不断改进，在大数据量读取时能够模拟 RAID3 ，而且 RAID3 在出现坏盘时性能会大幅下降，因此常使用 RAID5 替代 RAID3 来运行具有持续性、高带宽、大量读写特征的应用。<br/>
<img src="../img/raid3.png"  alt="../img/raid3.png" /><br/>
</p></div>

</div>

<div id="outline-container-1-3-5" class="outline-4">
<h4 id="sec-1-3-5">RAID4</h4>
<div class="outline-text-4" id="text-1-3-5">

<p>RAID4 与 RAID3 的原理大致相同，区别在于条带化的方式不同。 RAID4按照块的方式来组织数据.<br/>
RAID4 提供了 非常好的读性能，但单一的校验盘往往成为系统性能的瓶颈。对于写操作， RAID4 只能一个磁盘一个磁盘地写，并且还要写入校验数据，因此写性能比较差。而且随着成员磁盘数量的增加，校验盘的系统瓶颈将更加突出。正是如上这些限制和不足， RAID4 在实际应用中很少见，主流存储产品也很少使用 RAID4 保护。<br/>
</p></div>

</div>

<div id="outline-container-1-3-6" class="outline-4">
<h4 id="sec-1-3-6">RAID5</h4>
<div class="outline-text-4" id="text-1-3-6">

<p>RAID5 应该是目前最常见的 RAID 等级，它的原理与 RAID4 相似，区别在于校验数据分布在阵列中的所有磁盘上，而没有采用专门的校验磁盘。对于数据和校验数据，它们的写操作可以同时发生在完全不同的磁盘上。因此， RAID5 不存在 RAID4 中的并发写操作时的校验盘性能瓶颈问题。另外， RAID5 还具备很好的扩展性。当阵列磁盘 数量增加时，并行操作量的能力也随之增长，可比 RAID4 支持更多的磁盘，从而拥有更高的容量以及更高的性能。<br/>
当一个数据盘损坏时，系统可以根据同一条带的其他数据块和对应的校验数据来重建损坏的数据。与其他 RAID 等级一样，重建数据时， RAID5 的性能会受到较大的影响。<br/>
RAID5 兼顾存储性能、数据安全和存储成本等各方面因素，它可以理解为 RAID0 和 RAID1 的折中方案，是目前综合性能最佳的数据保护解决方案。 RAID5 基本上可以满足大部分的存储应用需求，数据中心大多采用它作为应用数据的保护方案。<br/>
<img src="../img/raid5.png"  alt="../img/raid5.png" /><br/>
</p>
<p><br/>
有人可能担心RAID5的可靠性，我试过，稳定性很好，同步完成后，拷贝数据上去，然后，随意的掉电，RAID5 组上的数据都没事。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3-7" class="outline-4">
<h4 id="sec-1-3-7">RAID6</h4>
<div class="outline-text-4" id="text-1-3-7">

<p>前面所 述的各个 RAID 等级都只能保护因单个磁盘失效而造成的数据丢失。如果两个磁盘同时发生故障，数据将无法恢复。 RAID6 （如图 8 ）引入双重校验的概念，它可以保护阵列中同时出现两个磁盘失效时，阵列仍能够继续工作，不会发生数据丢失。<br/>
</p></div>

</div>

<div id="outline-container-1-3-8" class="outline-4">
<h4 id="sec-1-3-8">RAID 组合等级</h4>
<div class="outline-text-4" id="text-1-3-8">

<p>标准 RAID 等级各有优势和不足。自然地，我们想到把多个 RAID 等级组合起来，实现优势互补，弥补相互的不足，从而达到在性能、数据安全性等指标上更高的 RAID 系统。<br/>
实际得到较为广泛应用的只有 RAID01 和 RAID10 两个等级。<br/>
RAID01 兼备了 RAID0 和 RAID1 的优点，它先用两块磁盘建立镜像，然后再在镜像内部做条带化。 RAID01 的数据将同时写入到两个磁盘阵列中，如果其中一个阵列损坏，仍可继续工作，保证数据安全性的同时又提高了性能。 RAID01 和 RAID10 内部都含有 RAID1 模式，因此整体磁盘利用率均仅为 50% 。<br/>
<img src="../img/raid10.png"  alt="../img/raid10.png" /><br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">linux上创建raid5</h3>
<div class="outline-text-3" id="text-1-4">

<p>4个硬盘，每个硬盘都化分为一个区。<br/>
创建raid5<br/>
</p>
<p><br/>
<pre class="src src-sh">mdadm --create /dev/md0 --level=5 --raid-devices=3 --spare-devices=1 /dev/sd[a-d]1
</pre>

创建RAID设备名为md0, 级别为RAID 5，使用3个设备建立RAID,空余一个做备用。<br/>
可以看来做raid只需要分区，所以一个硬盘可以分为多个分区，不同分区作为不同的raid type。<br/>
</p>
<p><br/>
查看raid信息<br/>
</p>
<p><br/>
<pre class="src src-sh">mdadm --detail /dev/md0
</pre>


513984 blocks [2/2] [UU]<br/>
The second line gives us some more information about the device. [2/2] [UU] tells us both partitions are used.<br/>
</p>
<p><br/>
让RAID开机启动.配置RIAD配置文件<br/>
</p>
<p><br/>
<pre class="src src-sh">mdadm --detail --scan &gt; /etc/mdadm.conf
</pre>

修改下，格式，去掉devices后的=。<br/>
<code>devices /dev/sda1,/dev/sdb1,/dev/sdc1,/dev/sdd1</code><br/>
</p>
<p><br/>
如果其中某个硬盘坏了会怎么样呢?系统会自动停止这块硬盘的工作,然后让后备的那块硬盘顶上去工作。我们可以实验下.<br/>
</p>
<p><br/>
<pre class="src src-sh">mdadm /dev/md0 --fail /dev/sdc1
cat /proc/mdstat&#25110;&#32773;mdadm --detail
</pre>


删除一个硬盘<br/>
<code>mdadm /dev/md0 --remove /dev/sdc1</code><br/>
</p>
<p><br/>
添加一个硬盘<br/>
<code>mdadm /dev/md0 --add /dev/sdc1</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">资料</h3>
<div class="outline-text-3" id="text-1-5">

<p><a href="http://blog.csdn.net/liuben/article/details/4581970">http://blog.csdn.net/liuben/article/details/4581970</a><br/>
</p>
<p><br/>
ubuntu使用raid的一个例子：<br/>
<a href="http://www.dedoimedo.com/computers/linux-raid.html">http://www.dedoimedo.com/computers/linux-raid.html</a><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenLDAP介绍]]></title>
    <link href="http://emmoblin.github.com/blog/2013/02/13/openldap/"/>
    <updated>2013-02-13T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/02/13/openldap</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">OpenLDAP介绍</a>
<ul>
<li><a href="#sec-1-1">LDAP 入门</a></li>
<li><a href="#sec-1-2">LDAP 目录结构</a>
<ul>
<li><a href="#sec-1-2-1">DN</a></li>
<li><a href="#sec-1-2-2">组织单元</a></li>
<li><a href="#sec-1-2-3">个别项</a></li>
<li><a href="#sec-1-2-4">对象类objectclass</a></li>
</ul>
</li>
<li><a href="#sec-1-3">配置openLDAP</a>
<ul>
<li><a href="#sec-1-3-1">rootdn</a></li>
<li><a href="#sec-1-3-2">AC</a></li>
</ul>
</li>
<li><a href="#sec-1-4">插入数据</a>
<ul>
<li><a href="#sec-1-4-1">LDIF 方法</a></li>
</ul>
</li>
<li><a href="#sec-1-5">参考资料</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/13/openldap/">OpenLDAP介绍</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">LDAP 入门</h3>
<div class="outline-text-3" id="text-1-1">

<p>首字母缩略 LDAP 代表轻量级目录访问协议（Lightweight Directory Access Protocol）。<br/>
信息被集中存储在服务器上的 LDAP 目录中。LDAP 目录是一种数据库；然而，它不是关系数据库。<br/>
它的目录或数据库的结构与 UNIX 文件系统非常相似： <br/>
数据按层次存储；有“根”或“基本 DN”（专有名称，Distinguished Name）；<br/>
目录被进一步细分成组织单元（Organization Units 或 OU）；<br/>
在这些 OU 中是包含数据的项。<br/>
这种树-叶结构不仅使 LDAP 变得可扩展， 而且当进行简单的搜索或查询时，比传统的关系数据库更快。<br/>
</p>
<p><br/>
LDAP 目录几乎可以存储所有类型的数据：电子邮件地址、DNS 信息、NIS 映射、安全性密钥、联系人信息列表和计算机名等。<br/>
可以通过 ACL（访问控制表，Access Control List）来控制对目录的访问。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">LDAP 目录结构</h3>
<div class="outline-text-3" id="text-1-2">


</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">DN</h4>
<div class="outline-text-4" id="text-1-2-1">

<p>LDAP 目录树的“根”或顶部是基本 DN。基本 DN 通常有两种形式：organization=（例如，o=syroidmanor.com）， 或者从组织的 DNS 域组件派生的 DN（dc=syroidmanor,dc=com）。<br/>
</p></div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">组织单元</h4>
<div class="outline-text-4" id="text-1-2-2">

<p>在目录基本 DN 的下面是容器或组织单元（OU），它们从逻辑上对您的数据进行分隔或分组。<br/>
</p>
<p><br/>
<pre class="example">dc=foobar,dc=com
                ou=customers
                        ou=northamerica
                        ou=southamerica
                        ou=asia
                        ou=europe
</pre>

</p></div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">个别项</h4>
<div class="outline-text-4" id="text-1-2-3">

<p>项只是存储属性的地方。<br/>
属性是可用来将一种类型的信息存储在目录中的容器。<br/>
每个属性都有一种类型和一个或多个值。<br/>
LDAP 目录中的每个项都有唯一的 DN，每个 DN 都由两部分组成 ―“相对专有名称”（或 RDN）和对 LDAP 目录结构中存储记录的位置的引用。 几乎存储在 LDAP 目录中的所有数据都有一个唯一名称，这个名称通常存储在 cn 属性中。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">对象类objectclass</h4>
<div class="outline-text-4" id="text-1-2-4">

<p>对象类由 LDAP 目录使用来定义给定类型的对象可以有哪些属性。对象类还定义项必须有什么属性， 以及项可以有什么属性。所有对象类都从其父对象类继承需求，然后添加它们自己的需求。<br/>
对象类有五个组件：OID（对象标识）、唯一名称、父对象（SUP）、任何需要的属性（MUST）和 允许的属性列表（MAY）。<br/>
如：<br/>
</p>
<p><br/>
<pre class="example">objectclass ( 2.5.6.6 NAME 'person' SUP top STRUCTURAL
        MUST ( sn $ cn )
        MAY ( userPassword $ telephoneNumber $ seeAlso $ description ) )
</pre>


</p></div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">配置openLDAP</h3>
<div class="outline-text-3" id="text-1-3">


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">rootdn</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>rootdn 项控制谁可以对目录数据库进行写操作，以及他们要这样做所必须提供的密码。<br/>
您在 rootdn 项的 cn= 部分填充的任何项都是对数据库有完全读／写访问权的用户。<br/>
如果您打算存储在目录中的数据只有一点点机密性，则对密码进行散列处理。可以用 slappasswd 实用程序完成它，如下所示：<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">AC</h4>
<div class="outline-text-4" id="text-1-3-2">


<p><br/>
<pre class="example">access to dn=".*,dc=syroidmanor,dc=com" attr=userPassword
        by dn="cn=root,dc=syroidmanor,dc=com" write
        by self write
        by * auth
access to dn=".*,dc=syroidmanor,dc=com" attr=mail
        by dn="cn=root,dc=syroidmanor,dc=com" write
        by self write
        by * read
</pre>

上面的配置仅允许 userPassword 属性的所有者修改项，但仅当所有者提供他或她的优先密码时才允许进行修改。 在所有其它情况下，只能出于认证目的来访问该项，而不能查看它。 第二个 access to&hellip; 项允许用户修改自己的电子邮件地址<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">插入数据</h3>
<div class="outline-text-3" id="text-1-4">


</div>

<div id="outline-container-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">LDIF 方法</h4>
<div class="outline-text-4" id="text-1-4-1">


<p><br/>
<pre class="example">dn: uid=juser,ou=people,dc=syroidmanor,dc=com
uid: juser
cn: Joe User
givenname: Joe
sn: User
mail: juser@syroidmanor.com
objectClass: top
objectClass: mailRecipient
objectClass: person
objectClass: inetOrgPerson
</pre>




</p></div>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">参考资料</h3>
<div class="outline-text-3" id="text-1-5">

<ol>
<li><a href="http://www.ibm.com/developerworks/cn/education/linux/l-ldap/section2.html">构建基于 LDAP 的地址簿</a><br/>
</li>
</ol>

</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[openfiler 2.99创建raid]]></title>
    <link href="http://emmoblin.github.com/blog/2013/02/13/openfiler/"/>
    <updated>2013-02-13T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/02/13/openfiler</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">openfiler 2.99创建raid</a>
<ul>
<li><a href="#sec-1-1">创建raid5</a>
<ul>
<li><a href="#sec-1-1-1">设置gpt</a></li>
<li><a href="#sec-1-1-2">分区</a></li>
<li><a href="#sec-1-1-3">设置raid标记</a></li>
<li><a href="#sec-1-1-4">在web上创建raid</a></li>
<li><a href="#sec-1-1-5">扩展</a></li>
</ul>
</li>
<li><a href="#sec-1-2">如果web上无法识别raid盘</a></li>
<li><a href="#sec-1-3">测试速度</a></li>
<li><a href="#sec-1-4">优缺点</a></li>
<li><a href="#sec-1-5">资料</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/13/openfiler/">openfiler 2.99创建raid</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
有人可能担心RAID5的可靠性，我试过，稳定性很好，同步完成后，拷贝数据上去，然后，随意的掉电，RAID5 组上的数据都没事。<br/>
OpenFiler读写性能很好，随便调整一下就能达到RAID5 下写130MB/S和读220MB/S的成绩，这个远远超过了FREENas的成绩。<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">创建raid5</h3>
<div class="outline-text-3" id="text-1-1">

<p>一个磁盘用于安装系统，其他3块作为raid5.<br/>
进入root<br/>
</p>
</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">设置gpt</h4>
<div class="outline-text-4" id="text-1-1-1">


<p><br/>
<pre class="src src-sh">parted /dec/sdb
mklabel
gpt
</pre>


</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">分区</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>整个磁盘化为一个分区，<br/>
<code>mkpart primary 0 -0</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">设置raid标记</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>设置为raid分区<br/>
<code>set 1 raid on</code><br/>
</p>
<p><br/>
同样操作于<br/>
<code>select /dev/sdc</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">在web上创建raid</h4>
<div class="outline-text-4" id="text-1-1-4">

<p>Volumes &gt; Software RAID:<br/>
Create the software RAID 5 with sdb1, sdc1 and sdd1.<br/>
</p>
<p><br/>
Create the vg0 volume group with /dev/md0<br/>
Create the lv0 volume, using full space and XFS.<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-5" class="outline-4">
<h4 id="sec-1-1-5">扩展</h4>
<div class="outline-text-4" id="text-1-1-5">

<p>如果要再添加两块硬盘，<br/>
</p>
<p><br/>
<pre class="src src-sh">[root@localhost]# mdadm --add /dev/md0 /dev/sde1 add the two disks to /dev/md0
[root@localhost]# mdadm --add /dev/md0 /dev/sdf1

[root@localhost]# mdadm --grow /dev/md0 --raid-devices=5 set the RAID to use the two new disks

In the OpenFiler WEBinterface, Wait for /dev/md0 to be Clean and Synchronized, then:

[root@localhost]# pvresize /dev/md0 resize the physical volume /dev/md0
</pre>


In the OpenFiler WEBinterface &gt; Volumes &gt; Manage Volumes &gt; Edit properties of lv0 to use full capacity.<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">如果web上无法识别raid盘</h3>
<div class="outline-text-3" id="text-1-2">

<p>首先需要把/dev/md0  mklabel为gpt<br/>
然后分区，mkpart primary ext2 <br/>
设置lvm flag<br/>
<code>set 1 LVM on</code><br/>
</p>
<p><br/>
手动添加卷组：<br/>
<code>vgcreate VG1 /dev/md0</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">测试速度</h3>
<div class="outline-text-3" id="text-1-3">

<p><code>dd if=/dev/zero of=tmpfile bs=1M count=10000</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">优缺点</h3>
<div class="outline-text-3" id="text-1-4">

<p>优点：<br/>
</p>
<p><br/>
1、兼容性很好，几乎可以识别所有的常见硬件，哪怕识别不了也可以装个REDHAT的驱动，REDHAT的驱动几乎是每个厂商都会提供的，上面那台HP SERVER RAID卡就是装了READHAT的驱动搞定的；<br/>
</p>
<p><br/>
2、性能强大，支持网卡捆绑，上门的PC-SERVER通过网络访问，可以实现RAID5的245MB/S的读写速度，和本地盘没啥区别，要不是受制于HP PCSERVER网卡数量不够的限制，网络服务应该还能实现更高的速度，本地测试RAID5超过400MB/S的读写速度；<br/>
</p>
<p><br/>
3、支持卷管理功能，支持在线扩展功能，支持按用户空间限制配置；<br/>
</p>
<p><br/>
4、内部带OPENLDAP,用户的认证通过OPENLDAP认证，安全性很高；<br/>
</p>
<p><br/>
5、支持WEB管理和系统监控，管理方便。<br/>
</p>
<p><br/>
缺点：<br/>
</p>
<p><br/>
1、页面管理功能要是没用过肯定一头雾水，监控管理功能很一般，只能算有吧；<br/>
</p>
<p><br/>
2、用户认证使用OPENLDAP，配置麻烦，我折腾了一个小时才搞定；<br/>
</p>
<p><br/>
3、不支持BT电驴什么的，虽然可以安装但是无法和WEB页面集成，感觉还是很不爽<br/>
</p>
<p><br/>
4、不知道为何精简了RPM命令和yum命令，要在上面装点东西很麻烦，要先装RPM才能进行下面的工作。<br/>
应该是改为了conary。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">资料</h3>
<div class="outline-text-3" id="text-1-5">

<ol>
<li>LDAP设置<br/>
   <a href="http://www.njeit.cn/show.aspx?id=831&amp;cid=65">http://www.njeit.cn/show.aspx?id=831&amp;cid=65</a><br/>

<p><br/>
</p></li>
<li>创建iscsi <br/>
   <a href="http://wenku.baidu.com/view/b51fdeedf8c75fbfc77db202.html">http://wenku.baidu.com/view/b51fdeedf8c75fbfc77db202.html</a><br/>
</li>
</ol>

</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LVM介绍]]></title>
    <link href="http://emmoblin.github.com/blog/2013/02/13/lvm/"/>
    <updated>2013-02-13T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/02/13/lvm</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">LVM介绍</a>
<ul>
<li><a href="#sec-1-1">LVM基本术语</a></li>
<li><a href="#sec-1-2">创建和管理lvm</a>
<ul>
<li><a href="#sec-1-2-1">分区</a></li>
<li><a href="#sec-1-2-2">创建物理卷</a></li>
<li><a href="#sec-1-2-3">创建卷组</a></li>
<li><a href="#sec-1-2-4">激活卷组</a></li>
<li><a href="#sec-1-2-5">添加新的物理卷到卷组中</a></li>
<li><a href="#sec-1-2-6">查看物理卷信息</a></li>
<li><a href="#sec-1-2-7">从卷组中删除一个物理卷</a></li>
<li><a href="#sec-1-2-8">创建逻辑卷</a></li>
<li><a href="#sec-1-2-9">创建文件系统</a></li>
<li><a href="#sec-1-2-10">删除一个逻辑卷</a></li>
<li><a href="#sec-1-2-11">扩展逻辑卷大小</a></li>
<li><a href="#sec-1-2-12">减少逻辑卷大小</a></li>
<li><a href="#sec-1-2-13">灵活</a></li>
</ul>
</li>
<li><a href="#sec-1-3">snapshot</a></li>
<li><a href="#sec-1-4">lvm常用管理工具：</a></li>
<li><a href="#sec-1-5">参考</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/13/lvm/">LVM介绍</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。通过LVM系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组（volumegroup），形成一个存储池。管理员可以在卷组上随意创建逻辑卷组（logicalvolumes），并进一步在逻辑卷组上创建文件系统。管理员通过LVM可以方便的调整存储卷组的大小，并且可以对磁盘存储按照组的方式进行命名、管理和分配。<br/>
而且当系统添加了新的磁盘，通过LVM管理员就不必将磁盘的文件移动到新的磁盘上以充分利用新的存储空间，而是直接扩展文件系统跨越磁盘即可。<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">LVM基本术语</h3>
<div class="outline-text-3" id="text-1-1">

<p>物理存储介质（The physical media）<br/>
这里指系统的存储设备：硬盘，如：/dev/hda1、/dev/sda等等，是存储系统最低层的存储单元。 <br/>
</p>
<p><br/>
物理卷PV（physical volume）<br/>
物理卷就是指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与LVM相关的管理参数。 <br/>
</p>
<p><br/>
卷组VG（Volume Group）<br/>
LVM卷组类似于非LVM系统中的物理硬盘，其由物理卷组成。可以在卷组上创建一个或多个“LVM分区”（逻辑卷），LVM卷组由一个或多个物理卷组成。 <br/>
</p>
<p><br/>
逻辑卷LV（logical volume）<br/>
LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上可以建立文件系统(比如/home或者/usr等)。 <br/>
</p>
<p><br/>
PE（physical extent）<br/>
每一个物理卷被划分为称为PE(Physical Extents)的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是可配置的，默认为4MB。 <br/>
</p>
<p><br/>
LE（logical extent）<br/>
逻辑卷也被划分为被称为LE(Logical Extents) 的可被寻址的基本单位。在同一个卷组中，LE的大小和PE是相同的，并且一一对应。<br/>
</p>
<p><br/>
<img src="../img/lvm_vg.jpg"  alt="../img/lvm_vg.jpg" /><br/>
</p>
<p><br/>
VGDA（卷组描述符区域）<br/>
和非 LVM 系统将包含分区信息的元数据保存在位于分区起始位置的分区表中一样，逻辑卷以及卷组相关的元数据被保存在位于物理卷起始处的 VGDA 中。VGDA 包括以下内容：PV 描述符、VG 描述符、LV 描述符、和一些 PE 描述符。系统启动 LVM 时激活 VG，并将 VGDA 加载至内存，来识别 LV 的实际物理存储位置。当系统进行 I/O 操作时，就会根据 VGDA 建立的映射机制来访问实际的物理位置。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">创建和管理lvm</h3>
<div class="outline-text-3" id="text-1-2">


</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">分区</h4>
<div class="outline-text-4" id="text-1-2-1">

<p>使用分区工具（如：fdisk等）创建LVM分区，方法和创建其他一般分区的方式是一样的，区别仅仅是LVM的分区类型为8e。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">创建物理卷</h4>
<div class="outline-text-4" id="text-1-2-2">

<p>创建物理卷的命令为pvcreate，利用该命令将希望添加到卷组的所有分区或者磁盘创建为物理卷。<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">pvcreate /dev/hda5</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">创建卷组</h4>
<div class="outline-text-4" id="text-1-2-3">

<p>创建卷组的命令为vgcreate，将使用pvcreate建立的物理卷创建为一个完整的卷组：<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">vgcreate web_document /dev/hda5 /dev/hdb</span>
</pre>

vgcreate在创建卷组 web_document 以外，还设置使用大小为4 MB的PE（默认为4MB），这表示卷组上创建的所有逻辑卷都以 4 MB 为增量单位来进行扩充或缩减。由于内核原因，PE大小决定了逻辑卷的最大大小，4 MB 的PE决定了单个逻辑卷最大容量为 256 GB，若希望使用大于256G的逻辑卷则创建卷组时指定更大的PE。PE大小范围为8 KB 到 512 MB，并且必须总是 2 的倍数（使用-s指定）<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">激活卷组</h4>
<div class="outline-text-4" id="text-1-2-4">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">vgchange -ay web_document</span>
</pre>

</p></div>

</div>

<div id="outline-container-1-2-5" class="outline-4">
<h4 id="sec-1-2-5">添加新的物理卷到卷组中</h4>
<div class="outline-text-4" id="text-1-2-5">

<p>当系统安装了新的磁盘并创建了新的物理卷，而要将其添加到已有卷组时，就需要使用vgextend命令：<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">vgextend web_document /dev/hdc1</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-2-6" class="outline-4">
<h4 id="sec-1-2-6">查看物理卷信息</h4>
<div class="outline-text-4" id="text-1-2-6">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">pvdisplay /dev/hda1</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-2-7" class="outline-4">
<h4 id="sec-1-2-7">从卷组中删除一个物理卷</h4>
<div class="outline-text-4" id="text-1-2-7">

<p>要从一个卷组中删除一个物理卷，首先要确认要删除的物理卷没有被任何逻辑卷正在使用.<br/>
如果某个物理卷正在被逻辑卷所使用，就需要将该物理卷的数据备份到其他地方，然后再删除。<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">vgreduce web_document /dev/hda1</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-2-8" class="outline-4">
<h4 id="sec-1-2-8">创建逻辑卷</h4>
<div class="outline-text-4" id="text-1-2-8">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">lvcreate -L1500 &#8211;n www1 web_document</span>
</pre>

该命令就在卷组web_document上创建名字为www1，大小为1500M的逻辑卷，并且设备入口为/dev/web_document/www1<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-9" class="outline-4">
<h4 id="sec-1-2-9">创建文件系统</h4>
<div class="outline-text-4" id="text-1-2-9">

<p>推荐使用reiserfs文件系统，来替代ext2和ext3<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-10" class="outline-4">
<h4 id="sec-1-2-10">删除一个逻辑卷</h4>
<div class="outline-text-4" id="text-1-2-10">

<p>删除逻辑卷以前首先需要将其卸载，然后删除：<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">umount /dev/web_document/www1</span>
<span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">lvremove /dev/web_document/www1</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-2-11" class="outline-4">
<h4 id="sec-1-2-11">扩展逻辑卷大小</h4>
<div class="outline-text-4" id="text-1-2-11">

<p>LVM提供了方便调整逻辑卷大小的能力，扩大为12G<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">lvextend -L12G /dev/web_document/www1</span>
&#22686;&#21152;1G
<span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">lvextend -L+1G /dev/web_document/www1</span>
</pre>


增加了逻辑卷的容量以后，就需要修改文件系统大小以实现利用扩充的空间。笔者推荐使用reiserfs文件系统来替代ext2或者ext3。因此这里仅仅讨论reiserfs的情况。Reiserfs文件工具提供了文件系统大小调整工具：resize_reiserfs。对于希望调整被加载的文件系统大小：<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">resize_reiserfs -f /dev/web_document/www1</span>
</pre>


对于使用ext2或ext3文件系统的用户可以考虑使用工具<br/>
ext2resize。<br/>
<a href="http://sourceforge.net/projects/ext2resize">http://sourceforge.net/projects/ext2resize</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-12" class="outline-4">
<h4 id="sec-1-2-12">减少逻辑卷大小</h4>
<div class="outline-text-4" id="text-1-2-12">

<p>使用lvreduce即可实现对逻辑卷的容量，同样需要首先将文件系统卸载：<br/>
要先减少文件系统，然后再减少逻辑卷<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">umount /data/wwwroot</span>
<span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">resize_reiserfs -s-2G /dev/web_document/www1</span>
<span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">lvreduce -L-2G /dev/web_document/www1</span>
<span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">mount -treiserfs /dev/web_document/www1 /data/wwwroot</span>
</pre>

</p></div>

</div>

<div id="outline-container-1-2-13" class="outline-4">
<h4 id="sec-1-2-13">灵活</h4>
<div class="outline-text-4" id="text-1-2-13">

<p>逻辑卷可以再组合成pv，和vg，再次进行lvm。<br/>
而且一个卷组可以跨多个磁盘。<br/>
如果想自己做实验可以自己创建空洞文件进行lvm练习。<br/>
</p>
<p><br/>
<pre class="src src-sh">dd <span style="color: #ff1493;">if</span>=/dev/zore <span style="color: #ff1493;">of</span>=./loop1.img <span style="color: #ff1493;">bs</span>=1G <span style="color: #ff1493;">count</span>=0 <span style="color: #ff1493;">seek</span>=100
</pre>

这就创建了一个100G的稀疏文件，文件大小是100G，但占用的空间是0.<br/>
然后使用losetup进行加载。就可以当/dev/loop0 磁盘使用了。<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">snapshot</h3>
<div class="outline-text-3" id="text-1-3">

<p>lvm可以创建镜像，创建时选择创建允许多大的空间用于记录变化。<br/>
创建镜像后实际上就是和原始lv独立，但如果原始lv删掉了，则所有的snap也就丢失了。<br/>
snap和原始lv都可以后续修改，而且snap可以和原始lv进行合并，使原始lv变为snap当前的样子。<br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">lvm常用管理工具：</h3>
<div class="outline-text-3" id="text-1-4">


<p><br/>
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left">功能</td><td class="left">物理卷</td><td class="left">卷组</td><td class="left">逻辑卷</td></tr>
<tr><td class="left">扫描</td><td class="left">pvscan</td><td class="left">vgscan</td><td class="left">lvscan</td></tr>
<tr><td class="left">查看</td><td class="left">pvdisplay</td><td class="left">vgdisplay</td><td class="left">lvdisplay</td></tr>
<tr><td class="left">新建</td><td class="left">pvcreat</td><td class="left">vgcreat</td><td class="left">lvcreat</td></tr>
<tr><td class="left">卸载</td><td class="left">pvremove</td><td class="left">vgremove</td><td class="left">lvremove</td></tr>
<tr><td class="left">增大</td><td class="left">无</td><td class="left">vgextend</td><td class="left">lvextend</td></tr>
<tr><td class="left">减小</td><td class="left">无</td><td class="left">vgreduce</td><td class="left">lvreduce</td></tr>
</tbody>
</table>


<p><br/>
lvs<br/>
pvs<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">参考</h3>
<div class="outline-text-3" id="text-1-5">

<p><a href="http://blog.csdn.net/steelren/article/details/1931363">http://blog.csdn.net/steelren/article/details/1931363</a><br/>
</p>
<p><br/>
LVM-HOWTO<br/>
<a href="http://tldp.org/HOWTO/LVM-HOWTO/">http://tldp.org/HOWTO/LVM-HOWTO/</a><br/>
</p>
<p><br/>
一些操作例子<br/>
<a href="http://sapling.me/unixlinux/lvm_howto.html">http://sapling.me/unixlinux/lvm\_howto.html</a><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[先衰竭训练法]]></title>
    <link href="http://emmoblin.github.com/blog/2013/02/12/xian-shuai-jie-xun-lian-fa/"/>
    <updated>2013-02-12T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/02/12/xian-shuai-jie-xun-lian-fa</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">先衰竭训练法</a>
<ul>
<li><a href="#sec-1-1">先衰竭训练法</a></li>
<li><a href="#sec-1-2">胸大肌的先衰竭训练法</a></li>
<li><a href="#sec-1-3">三角肌的先衰竭训练法：</a></li>
<li><a href="#sec-1-4">肱三头肌的先衰竭训练法</a></li>
<li><a href="#sec-1-5">竖脊肌（后腰）的先衰竭训练法</a></li>
<li><a href="#sec-1-6">大腿的先衰竭训练法</a></li>
<li><a href="#sec-1-7">背阔肌的先衰竭训练法</a></li>
<li><a href="#sec-1-8">总结</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2013/02/12/xian-shuai-jie-xun-lian-fa/">先衰竭训练法</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">先衰竭训练法</h3>
<div class="outline-text-3" id="text-1-1">

<p>先衰竭法是目前增大肌肉围径的有效方法。<br/>
其做法是要想发展那块肌肉，先选择只发展这块肌肉的局部肌肉练习来训练，做8-10次直到疲劳，使其衰竭，然后在3-5秒之内跑向另一器械，做一个以发展这块肌肉为主的综合肌肉群练习，用70％的重量做到极限，这样交替训练4组左右，肌肉会感受到极大的刺激。据研究，这样能有效地刺激肌肉生长，促进其发育。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">胸大肌的先衰竭训练法</h3>
<div class="outline-text-3" id="text-1-2">

<p>发达胸大肌的局部有效练习：仰卧飞鸟；<br/>
发达胸大肌综合肌群的练习：卧推（包括宽握、中握、窄握），它除了发展胸大肌外，还能发展肱三头肌、三角肌前部和前锯肌。<br/>
</p>
<p>  <br/>
先用只能举8-10次的重量做仰卧飞鸟练习，直到起不来，<br/>
紧接着跑到卧推架前用事先准备好的60-70％重量做卧推，尽力举次数，直到起不来算一组，<br/>
共做4组左右，累计总运动量为8组约50次左右。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">三角肌的先衰竭训练法：</h3>
<div class="outline-text-3" id="text-1-3">

<p>发达三角肌的局部肌肉练习：哑铃前平举 主要发展三角肌前束；哑铃侧平举主要发展三角肌中束；俯身后斜举主要发展三角肌后束。<br/>
发达三角肌的综合练习：颈后宽推，这个练习既能发展三角肌，还能发展肱三头肌，对胸大肌、前锯肌也有影响。<br/>
</p>
<p>  <br/>
为发达三角肌将这两个有效练习有机地结合在一起训练，其效果会更好。<br/>
每组动作：是先用只能平举8-10次的重量做哑铃来练习。直到起不来，紧接着跑到放置在另一侧的杠铃前，用做（70％），直到一个起不来算一大组，共做4大组。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">肱三头肌的先衰竭训练法</h3>
<div class="outline-text-3" id="text-1-4">

<p>发达肱三头肌的局部肌肉练习：各种臂屈伸，如颈后臂屈伸、弓身臂屈伸等<br/>
发达肱三头肌的综合练习：是窄卧推<br/>
</p>
<p> <br/>
先做颈后臂屈伸6-10次直到疲劳，然后迅速跑向深蹲架前拿起架上事先放好的杠铃（杠铃重量为自己最高重量的60-70％），<br/>
连续举直到起不来，这样两种练习算一大组，共做4大组，肱三头肌就会很胀，刺激很深。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">竖脊肌（后腰）的先衰竭训练法</h3>
<div class="outline-text-3" id="text-1-5">

<p>发达后腰竖脊肌的局部肌肉练习：负重山羊挺身<br/>
发达后腰竖脊肌的综合练习：弓身、屈腿硬拉等。<br/>
</p>
<p><br/>
<img src="../img/shanyangtingshen.gif"  alt="../img/shanyangtingshen.gif" /><br/>
先在山羊上做负重挺身6-10次直到挺不起为止，紧接着跑向深蹲架前肩负杠铃做弓身练习（或做硬拉），直到疲劳。将这两个练习组合在一起训练4组，背肌就能得到很好的刺激。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">大腿的先衰竭训练法</h3>
<div class="outline-text-3" id="text-1-6">

<p>发达股四头肌的局部肌肉练习：负重腿屈伸<br/>
发达腿部肌肉的综合肌群练习：深蹲，<br/>
<img src="../img/qutui.gif"  alt="../img/qutui.gif" /><br/>
</p>
<p><br/>
尽力做8次左右负重腿屈伸，紧接着做也尽力做6-8次深蹲，这样交叉轮换做8组（4大组）约50次，股四头肌就会因刺激较深而发胀。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">背阔肌的先衰竭训练法</h3>
<div class="outline-text-3" id="text-1-7">

<p>发达背阔肌的局部肌肉练习：宽握颈后引体向上<br/>
发达背阔肌的综合练习：坐姿划船<br/>
</p>
<p> <br/>
先宽握颈后引体向上10-15次直到拉不起为止，紧接着跑向做坐姿划船练习，直到疲劳。将这两个练习组合在一起训练4组，背阔肌就能得到很好的刺激。 <br/>
</p>
<p> <br/>
</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">总结</h3>
<div class="outline-text-3" id="text-1-8">

<p>先衰竭原理之所以先进，从理论上讲它符合极限负荷后的超量恢复的原则。<br/>
这是因为肌体精疲力竭地负荷之后，首先功能能力大大减退，紧接着在恢复防疲肌体由适应一提高，超过它原有的水平。<br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux_3g拨号]]></title>
    <link href="http://emmoblin.github.com/blog/2013/01/06/linux-g-dial/"/>
    <updated>2013-01-06T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/01/06/linux-g-dial</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">linux下3g网卡拨号</h3>
<div class="outline-text-3" id="text-1-1">

<p>需要安装的软件usb_modeswitch,wvdial<br/>
usb_modeswitch用于将usb3g转换为usb modem模式，这样才能拨号。最好到官网下载最新代码，包含的3g网卡类型会更全。最主要的就是usb_modeswitch_data。<br/>
<a href="http://www.draisberghof.de/usb_modeswitch/#download">http://www.draisberghof.de/usb\_modeswitch/#download</a><br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">安装usb_modeswitch_data</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>进入目录，执行<br/>
sudo make install<br/>
会安装对应的udev文件到/lib/udev/rules.d目录。<br/>
</p>
<p><br/>
不过我发现自动转换没有效果，暂时先不查了。<br/>
直接使用命令行转：<br/>
usb_modeswitch -c /etc/usb_modeswitch.conf<br/>
如果转换成功会出现/dev/ttyUSB0-3，dmesg也会有输出信息。<br/>
</p>
<p><br/>
usb_modeswitch.conf<br/>
</p>
<p><br/>
<pre class="example">######################################################## 
# ZTE A371B
#
# Contributor: Wang Lei

DefaultVendor= 0x19d2
DefaultProduct=0x0169

TargetVendor=  0x19d2
TargetProduct= 0x0170

MessageContent="5553424312345678000000000000061b000000020000000000000000000000"
NeedResponse=1
</pre>


</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">wvdial</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>这个难了，wvdial负责发送AT命令给usb modem，进行拨号。但不同的3g卡发送的指令也不一样。<br/>
我是在xp上安装了usb抓包软件，把xp上官方的3g拨号过程进行了抓包分析，提取出如下序列：<br/>
</p>
<p><br/>
</p>
<p><br/>
<pre class="example">[Dialer Defaults]
Init1 = AT
Init2 = AT+CIMI
Init3 = AT+CMEE=1
Init4 = ATE0
Init5 = AT+CFUN=1
Init6 = AT+CLCK="SC",2
Init7 = AT+cgdcont=1,"ip","CMNET"
Modem Type = USB Modem
Baud = 460800
New PPPD = yes
Modem = /dev/ttyUSB0
ISDN = 0
Phone = *98*1#
Password = any
Username = any
Stupid Mode = 1
</pre>



</p></div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">遇到的问题</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>我的x230上无线鼠标的usb接收器貌似总是捣乱，拔了接收器，换了个usb口插3g，就可以ok了。<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[fstab恢复]]></title>
    <link href="http://emmoblin.github.com/blog/2013/01/01/fstab-recover/"/>
    <updated>2013-01-01T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/01/01/fstab-recover</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">fstab恢复</h3>
<div class="outline-text-3" id="text-1-1">

<p>不小心配置fstab结果参数写错了，导致重启后无法挂载，系统进不去。<br/>
从grub进入recover模式，选择进入root。<br/>
但此时根文件系统挂载的是只读的，所以无法修改fstab。<br/>
重新挂载为rw就ok了，非常关键。<br/>
mount -n -o remount,rw /<br/>
之后就可以修改了fstab了。<br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git服务器开源软件]]></title>
    <link href="http://emmoblin.github.com/blog/2012/12/18/git-server/"/>
    <updated>2012-12-18T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/12/18/git-server</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">git服务器开源软件</a>
<ul>
<li><a href="#sec-1-1">在服务器上部署git</a>
<ul>
<li><a href="#sec-1-1-1">通过git账户访问</a></li>
<li><a href="#sec-1-1-2">gitweb</a></li>
<li><a href="#sec-1-1-3">repo</a></li>
<li><a href="#sec-1-1-4">代码抽取</a></li>
<li><a href="#sec-1-1-5">分支合并</a></li>
<li><a href="#sec-1-1-6">git submodule</a></li>
<li><a href="#sec-1-1-7">gitk</a></li>
<li><a href="#sec-1-1-8">git log &ndash;graph</a></li>
<li><a href="#sec-1-1-9">git help workflows</a></li>
</ul>
</li>
<li><a href="#sec-1-2">GITolite</a></li>
<li><a href="#sec-1-3">gerrit</a></li>
<li><a href="#sec-1-4">Jenkins</a></li>
<li><a href="#sec-1-5">git权限控制理解</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/12/18/git-server/">git服务器开源软件</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">在服务器上部署git</h3>
<div class="outline-text-3" id="text-1-1">

<p>git clone &ndash;bare my_project my_project.git<br/>
其实 clone 操作基本上相当于 git init 加 git fetch。<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">通过git账户访问</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>第二个办法是在主机上建立一个 git 账户，让每个需要写权限的人发送一个 SSH 公钥，然后将其加入 git 账户的~/.ssh/authorized_keys 文件。这样一来，所有人都将通过 git 账户访问主机。这丝毫不会影响提交的数据 — 访问主机用的身份不会影响提交对象的提交者信息。<br/>
</p>
<p><br/>
$ sudo adduser git<br/>
$ su git<br/>
$ cd<br/>
$ mkdir .ssh<br/>
</p>
<p><br/>
只要把它们逐个追加到 authorized_keys 文件尾部即可：<br/>
</p>
<p><br/>
$ cat <i>tmp/id_rsa.john.pub &gt;&gt; ~</i>.ssh/authorized_keys<br/>
$ cat <i>tmp/id_rsa.josie.pub &gt;&gt; ~</i>.ssh/authorized_keys<br/>
$ cat <i>tmp/id_rsa.jessica.pub &gt;&gt; ~</i>.ssh/authorized_keys<br/>
现在可以用 &ndash;bare 选项运行 git init 来建立一个裸仓库，这会初始化一个不包含工作目录的仓库。<br/>
</p>
<p><br/>
$ cd /opt/git<br/>
$ mkdir project.git<br/>
$ cd project.git<br/>
$ git &ndash;bare init<br/>
这时，Join，Josie 或者 Jessica 就可以把它加为远程仓库，推送一个分支，从而把第一个版本的项目文件上传到仓库里了。值得注意的是，每次添加一个新项目都需要通过 shell 登入主机并创建一个裸仓库目录。<br/>
$ cd myproject<br/>
$ git init<br/>
$ git add .<br/>
$ git commit -m &#8216;initial commit&#8217;<br/>
$ git remote add origin git@gitserver:/opt/git/project.git<br/>
$ git push origin master<br/>
作为一个额外的防范措施，你可以用 Git 自带的 git-shell 工具限制 git 用户的活动范围。只要把它设为git 用户登入的 shell，那么该用户就无法使用普通的 bash 或者 csh 什么的 shell 程序。编辑 /etc/passwd 文件：<br/>
</p>
<p><br/>
在其他人机子上可以直接clone<br/>
git clone git@gitserver:/opt/git/project.git<br/>
</p>
<p><br/>
$ sudo vim /etc/passwd<br/>
在文件末尾，你应该能找到类似这样的行：<br/>
</p>
<p><br/>
git:x:1000:1000::/home/git:/bin/sh<br/>
把 bin/sh 改为 /usr/bin/git-shell （或者用 which git-shell 查看它的实际安装路径）。该行修改后的样子如下：<br/>
</p>
<p><br/>
git:x:1000:1000::/home/git:/usr/bin/git-shell<br/>
</p>
<p><br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">gitweb</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>git自带的cgi脚本<br/>
git instaweb &ndash;httpd=lighttpd<br/>
</p>
<p> <br/>
</p></div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">repo</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>git仓库太大会导致git操作很慢，那么分成多个子项目，用repo来管理。<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">代码抽取</h4>
<div class="outline-text-4" id="text-1-1-4">

<p>git cherry-pick &lt;commit&gt;<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-5" class="outline-4">
<h4 id="sec-1-1-5">分支合并</h4>
<div class="outline-text-4" id="text-1-1-5">

<p>git merge<br/>
git rebase &lt;upstream&gt; [&lt;branch&gt;]<br/>
rebase 可以让你看起来是基于最新的代码实现的改动。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-6" class="outline-4">
<h4 id="sec-1-1-6">git submodule</h4>
<div class="outline-text-4" id="text-1-1-6">

<p>子模块允许你将一个git仓库当作另一个git仓库的子目录。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-7" class="outline-4">
<h4 id="sec-1-1-7">gitk</h4>
<div class="outline-text-4" id="text-1-1-7">

<p>安装apt-get install gitk<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-8" class="outline-4">
<h4 id="sec-1-1-8">git log &ndash;graph</h4>
<div class="outline-text-4" id="text-1-1-8">

<p>可以添加到git的配置文件中<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-9" class="outline-4">
<h4 id="sec-1-1-9">git help workflows</h4>
<div class="outline-text-4" id="text-1-1-9">

<p>查看推荐的工作流<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">GITolite</h3>
<div class="outline-text-3" id="text-1-2">

<p>Gitolite 是一款 Perl 语言开发的 Git 服务管理工具，通过公钥对用户进行认证，并能够通过配置文件对写操作进行基于分支和路径的的精细授权。GITolite 采用的是SSH协议，并需要使用公钥 验证。也就是说 GITolite会根据管理员预先定义好的设置，根据客户的SSH，对于来自不同客户端的请求进行权限控制，只读，或者读写，甚至于精确到某个文件夹，某个文件的权限。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">gerrit</h3>
<div class="outline-text-3" id="text-1-3">

<p>前面我们说到了对Gitolite是对于开发人员的一种授权，但一旦保证了授权，就能够保证版本库的稳定吗？如果获得授权的人乱搞代码，或者改错代码，那版本库照样会出现不稳定的情况的。就像前面在敏捷系列里面说到的一样，在代码改动之后，要引入code review (代码审阅，说code review 比较顺口，还是用code review吧)。在Clearcase条件下，code review是需要把别人的代码整进去版本库之后，再由code reviewer拿下来看的。于是在Google Android项目的开发过程当中，Google为GIT带来了又一个伟大的工具-Gerrit，也有人叫Gerrit2，因为现在用的Gerrit跟Google刚开始整的时候有很大的不同，我们暂且叫它Gerrit就可以。<br/>
Gerrit有两个很牛的功能，第一是权限管理，它提供了一个跟GITolite一样的功能，管理用户的读写权限。但它比GITolite好用，对权限的控制都在它提供的网页系统里面完成，不用push啥的！第二是Gerrit为GIT带来强制性的code review，除非你某某是管理员。任何的代码改动都需要有人approve之后，这个代码改动才有可能进入公共代码库，如果没有经过approve或者被人reject了，即使你已经push了五百年，这代码依旧进不了公共版本库。而且 相比起裸奔时代的code review，Gerrit提供一个在线review 的系统，所有的操作都在它提供的系统上面点点点就能搞定的。<br/>
首先我们来看看权限控制，Gerrit有10种不同的权限，其中有读写权限，code review的权限等等。每个权限的设置包括两部分：权限本身，以及权限授予的组。<br/>
</p>
<p><br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">Jenkins</h3>
<div class="outline-text-3" id="text-1-4">

<p>如果用了Gerrit，那么每一个代码改动都要经过code review approve 并且要验证。code review还好说，可验证就麻烦了。如果每个改动都要人手拿到本地，至少去确保能编译通过吧，那谁都会疯了的！！！话说IT人的精品特质之一就是懒，所以有繁琐的地方<br/>
 往往都会产生自动化 （这貌似也是工业能够向前发展，甚至于社会能够向前发展的一个因素哦，要发扬发扬）。Jenkins就应运而生了。<br/>
Jenkins， 曾用名Hudson，是基于Java开发的持续集成的工具。它能够自动监控到公共代码库的版本变更，并且执行我们预先定义好的动作。在动作完成之后，把动作执行的结果回传给有关部门！比如我们可以让Jenkins监听Gerrit上面的代码变更情况，看有没有人提出code review的请求。如果监听到请求，那么Jenkins就偷偷向Gerrit要那个人改了的代码，试着做一些编译以及单元测试。如果这人很牛叉，测试通过。那么Jenkins会告诉Gerrit ：“喂，这条友很牛哦，我向毛主席保证，TA的代码改动没有问题”，这时Gerrit就跑过去将这个review item的 verify设置为+1，如果不通过，那就铁面无私地给一个 verify-1.<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">git权限控制理解</h3>
<div class="outline-text-3" id="text-1-5">

<p>从技术上讲，git可能永远也做不到类似svn的路径授权(读权限)<br/>
如果允许按照路径授权，则各个克隆的关系不再是平等的，有的内容多有的内容少，分布式的理念被破坏。<br/>
git的授权模型只能实现非零即一的方式，要不拥有全部写权限，要不没有写权限。<br/>
要么拥有全部库的读权限，o要么禁用。<br/>
</p>
<p><br/>
看来git的保密性确实不好，要不一视同仁，大家都有全部代码，要不把代码分成多个库。<br/>
这样看来在公司内部使用git确实不太方便了。公司最基本的要求就是代码的保护。<br/>
</p>
<p><br/>
Git对于写操作可以精细到目录和分支级别（使用Gitolite作为服务器）， 但作为分布式版本库控制系统，在设计上只能实现版本库量子化的读授权。 即某用户对整个版本库要么都能读，要么对整个版本库都不能读。<br/>
</p>
<p><br/>
那么如何控制Git版本库的读授权呢？实际上Git可以通过子模组来实现细粒度的读授权。 即在项目需要精细授权的场合，将版本库拆分为多个Git版本库进行单独授权， 再使用子模组将多个版本库整合为一个。这个操作并不复杂，而且有助于实现项目的模块化。<br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[shell代码片段收集]]></title>
    <link href="http://emmoblin.github.com/blog/2012/12/05/shell-snippet-collect/"/>
    <updated>2012-12-05T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/12/05/shell-snippet-collect</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">shell代码片段收集</a>
<ul>
<li><a href="#sec-1-1">获取磁盘大小</a></li>
<li><a href="#sec-1-2">变为大写</a></li>
<li><a href="#sec-1-3">判断返回值</a></li>
<li><a href="#sec-1-4">提问</a></li>
<li><a href="#sec-1-5">for循环</a></li>
<li><a href="#sec-1-6">while and until</a></li>
<li><a href="#sec-1-7">case</a></li>
<li><a href="#sec-1-8">读取文件</a></li>
<li><a href="#sec-1-9">awk按域搜索的例子</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/12/05/shell-snippet-collect/">shell代码片段收集</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">获取磁盘大小</h3>
<div class="outline-text-3" id="text-1-1">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Return the size of the drive in MB</span>
get_drive_size () {
  <span style="color: #ff1493;">ldrive</span>=$<span style="color: #ff1493;">1</span>

  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Make sure you can print disk info using parted</span>
  parted --script /dev/$<span style="color: #ff1493;">ldrive</span> print &gt;/dev/null 2&gt;&amp;1

  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">If unable to read disk, it's likely it needs a disklabel</span>
  <span style="color: #0000ff;">if</span> [  <span style="color: #00bfff;">"$?"</span> != <span style="color: #00bfff;">"0"</span> ]; <span style="color: #0000ff;">then</span>
    <span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">"Creating a new disklabel on $ldrive"</span> &gt;&gt; $<span style="color: #ff1493;">INSTALL_LOG</span>
    <span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">"parted /dev/$ldrive mklabel msdos"</span> &gt;&gt; $<span style="color: #ff1493;">INSTALL_LOG</span>
    <span style="color: #ff1493;">output</span>=$(<span style="color: #ff00ff;">parted</span> -s /dev/$<span style="color: #ff1493;">ldrive</span> mklabel msdos)

    <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Get the drive size from parted</span>
    <span style="color: #ff1493;">lsize</span>=$(<span style="color: #ff00ff;">parted</span> -s /dev/$<span style="color: #ff1493;">ldrive</span> p | grep <span style="color: #00bfff;">"^Disk"</span> | awk <span style="color: #00bfff;">'{ print $3 }'</span>)

    <span style="color: #0000ff;">if</span> [ $(<span style="color: #ff00ff;">echo</span> $<span style="color: #ff1493;">lsize</span> | grep error) ]; <span style="color: #0000ff;">then</span>
      <span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">"Unable to read disk label.  Exiting."</span>
      <span style="color: #0000ff;">exit</span> 1
    <span style="color: #0000ff;">fi</span>
  <span style="color: #0000ff;">fi</span>

  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Get the drive size from parted</span>
  <span style="color: #ff1493;">lsize</span>=$(<span style="color: #ff00ff;">parted</span> -s /dev/$<span style="color: #ff1493;">ldrive</span> p | grep <span style="color: #00bfff;">"^Disk"</span> | awk <span style="color: #00bfff;">'{ print $3 }'</span>)
  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Get the reported units (mB, GB, kB)</span>
  <span style="color: #ff1493;">lmodifier</span>=$(<span style="color: #ff00ff;">echo</span> $<span style="color: #ff1493;">lsize</span> | sed <span style="color: #00bfff;">'s/[0-9\.]//g'</span>)
  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">remove the modifier</span>
  <span style="color: #ff1493;">lsize</span>=$(<span style="color: #ff00ff;">echo</span> $<span style="color: #ff1493;">lsize</span> | sed <span style="color: #00bfff;">'s/[a-z,A-Z]//g'</span>)
  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Remove any fractions</span>
  <span style="color: #ff1493;">lsize</span>=$(<span style="color: #ff00ff;">echo</span> $<span style="color: #ff1493;">lsize</span> | cut -f1 -d<span style="color: #00bfff;">'.'</span>)
  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Translate our size into mB if not there already</span>
  <span style="color: #0000ff;">if</span> [ $<span style="color: #ff1493;">lmodifier</span> = <span style="color: #00bfff;">"GB"</span> ]; <span style="color: #0000ff;">then</span> 
    <span style="color: #ff1493;">lsize</span>=$(($<span style="color: #ff1493;">lsize</span> * 1000))
  <span style="color: #0000ff;">elif</span> [ $<span style="color: #ff1493;">lmodifier</span> = <span style="color: #00bfff;">"kB"</span> ]; <span style="color: #0000ff;">then</span> 
    <span style="color: #ff1493;">lsize</span>=$(($<span style="color: #ff1493;">lsize</span> / 1000))
  <span style="color: #0000ff;">fi</span>

  <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">lsize</span>
}

</pre>


disk_size=`fdisk -l $CF | grep MB | cut -d&#8221;:&#8221; -f2 | cut -d &#8220;,&#8221; -f1| sed s/MB//g `<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">变为大写</h3>
<div class="outline-text-3" id="text-1-2">


<p><br/>
<pre class="src src-sh">upper_str()
{
        <span style="color: #ff1493;">upper</span>=<span style="color: #ff00ff;">`echo $1 | tr "[a-z]" "[A-Z]"`</span>
        <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">upper</span>
}
</pre>


</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">判断返回值</h3>
<div class="outline-text-3" id="text-1-3">


<p><br/>
<pre class="src src-sh"><span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">TOS_VERSION</span> | grep <span style="color: #00bfff;">"^3.3.016"</span> 
<span style="color: #0000ff;">if</span> [  $? != 0  ]
<span style="color: #0000ff;">then</span> 
        <span style="color: #ff1493;">VERSION_016</span>=<span style="color: #00bfff;">"false"</span>
<span style="color: #0000ff;">else</span>
        <span style="color: #ff1493;">VERSION_016</span>=<span style="color: #00bfff;">"true"</span>
<span style="color: #0000ff;">fi</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">提问</h3>
<div class="outline-text-3" id="text-1-4">


<p><br/>
<pre class="src src-sh">auto_echo <span style="color: #00bfff;">"Are you sure to begin[y/n]:"</span>
<span style="color: #0000ff;">while </span><span style="color: #a52a2a;">read</span> answer
<span style="color: #0000ff;">do</span>
<span style="color: #ff1493;">answer</span>=<span style="color: #ff00ff;">`upper_str $answer`</span>
<span style="color: #0000ff;">if</span> [ <span style="color: #00bfff;">"$answer"</span> = <span style="color: #00bfff;">"Y"</span> ] 
<span style="color: #0000ff;">then</span>
<span style="color: #0000ff;">break</span>
<span style="color: #0000ff;">elif</span> [ <span style="color: #00bfff;">"$answer"</span> = <span style="color: #00bfff;">"N"</span> ] 
<span style="color: #0000ff;">then</span>
write_free
<span style="color: #0000ff;">exit</span>
<span style="color: #0000ff;">fi</span>
auto_echo <span style="color: #00bfff;">"Are you sure to begin[y/n]:"</span>
<span style="color: #0000ff;">done</span>
</pre>

</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">for循环</h3>
<div class="outline-text-3" id="text-1-5">


<p><br/>
<pre class="src src-sh"><span style="color: #0000ff;">for</span> x<span style="color: #0000ff;"> in</span> /var/log/*
<span style="color: #0000ff;">do</span>
    <span style="color: #a52a2a;">echo</span> <span style="color: #ff00ff;">`basename $x`</span> is a file living<span style="color: #0000ff;"> in</span> /var/log
<span style="color: #0000ff;">done</span>
</pre>

</p>
<p> <br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">while and until</h3>
<div class="outline-text-3" id="text-1-6">


<p><br/>
<pre class="src src-sh"><span style="color: #ff1493;">myvar</span>=0
<span style="color: #0000ff;">while</span> [ $<span style="color: #ff1493;">myvar</span> -ne 10 ]
<span style="color: #0000ff;">do</span>
    <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">myvar</span>
    <span style="color: #ff1493;">myvar</span>=$(( $<span style="color: #ff1493;">myvar</span> + 1 ))
<span style="color: #0000ff;">done</span>


<span style="color: #ff1493;">myvar</span>=0
<span style="color: #0000ff;">until</span> [ $<span style="color: #ff1493;">myvar</span> -eq 10 ]
<span style="color: #0000ff;">do</span>
    <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">myvar</span>
    <span style="color: #ff1493;">myvar</span>=$(( $<span style="color: #ff1493;">myvar</span> + 1 ))
<span style="color: #0000ff;">done</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">case</h3>
<div class="outline-text-3" id="text-1-7">

<p>*$x为文件名，只获取文件的后缀，至于是为什么现在不明白? *<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #0000ff;">case</span> <span style="color: #00bfff;">"${x##*.}"</span><span style="color: #0000ff;"> in</span>
     gz)
           gzunpack ${<span style="color: #ff1493;">SROOT</span>}/${<span style="color: #ff1493;">x</span>}
           ;;
     bz2)
           bz2unpack ${<span style="color: #ff1493;">SROOT</span>}/${<span style="color: #ff1493;">x</span>}
           ;;
     *)
           <span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">"Archive format not recognized."</span>
           <span style="color: #0000ff;">exit</span>
           ;;
<span style="color: #0000ff;">esac</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">读取文件</h3>
<div class="outline-text-3" id="text-1-8">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">! /bin/</span><span style="color: #0000ff;">bash</span><span style="color: #8c8c8c; font-style: italic;">  </span>
<span style="color: #0000ff;">while </span><span style="color: #a52a2a;">read</span> LINE
<span style="color: #0000ff;">do</span>
        <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">LINE</span> 
<span style="color: #0000ff;">done</span> &lt; /etc/passwd
</pre>


</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">awk按域搜索的例子</h3>
<div class="outline-text-3" id="text-1-9">


<p><br/>
<pre class="src src-sh"><span style="color: #0000ff;">while </span><span style="color: #a52a2a;">read</span> line; 
        <span style="color: #0000ff;">do</span> cp aaaa $<span style="color: #ff1493;">line</span>;
<span style="color: #0000ff;">done</span> &lt;&lt; (awk <span style="color: #00bfff;">'{for(i=1; i &lt;= NF; ++i){if($i ~/^-l/){gsub("^-l","lib",$i); printf("%s.so\n", $i)}}}'</span> libso.txt  | sort -u)
</pre>

</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开源防火墙]]></title>
    <link href="http://emmoblin.github.com/blog/2012/11/17/opensources-firewall/"/>
    <updated>2012-11-17T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/11/17/opensources-firewall</id>
    <content type="html"><![CDATA[<div><div><p><br/>
要说免费使用的防火墙那多了，但都不开源，而我更喜欢开源的，能学到东西。<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">可下到源代码</h3>
<div class="outline-text-3" id="text-1-1">


</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">IPCop</h4>
<div class="outline-text-4" id="text-1-1-1">

<p><a href="http://sourceforge.net/projects/ipcop/develop">http://sourceforge.net/projects/ipcop/develop</a><br/>
可以下载源代码。<br/>
<code>svn co https://ipcop.svn.sourceforge.net/svnroot/ipcop ipcop</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">EFW</h4>
<div class="outline-text-4" id="text-1-1-2">

<p><a href="http://www.endian.com/">http://www.endian.com/</a><br/>
这个比较大，600M源码包，非常全。<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">Vyatta</h3>
<div class="outline-text-3" id="text-1-2">

<p>基于debian<br/>
<a href="http://www.vyatta.org/downloads">http://www.vyatta.org/downloads</a><br/>
目前这个是我发现的有专门针对虚拟化平台优化的版本。<br/>
<a href="http://www.vyatta.org/getting-started/how-to-install">http://www.vyatta.org/getting-started/how-to-install</a><br/>
</p>
<p><br/>
Installing Vyatta Core in a Virtualized Environment<br/>
If you’re deploying Vyatta Core on a hypervisor such as VMWare ESX/ESXi or Citrix XenServer, <br/>
you’ll want to use the Vyatta virtualization ISO (virt-ISO).<br/>
Similar to the LiveCD ISO, the virt-ISO provides a bootable ISO,<br/>
except it also includes virtual machine tools and other optimizations<br/>
to deliver the best possible experience for users running Vyatta on a virtual machine. <br/>
</p>
<p><br/>
Using the vSphere Client, create a new VM<br/>
</p><ul>
<li>Configuration: Custom<br/>
</li>
<li>Name: &#8220;vyatta&#8221;<br/>
</li>
<li>Datastore: default<br/>
</li>
<li>Virtual Machine Version: 7<br/>
</li>
<li>Guest OS: Linux/Other 2.6x Linux<br/>
</li>
<li>CPU: &#8220;1&#8221;<br/>
</li>
<li>Memory: &#8220;512&#8221;<br/>
</li>
<li>Network: &#8220;2&#8221; / vmxnet3<br/>
</li>
<li>SCSI Controller: default<br/>
</li>
<li>Select a Disk: default<br/>
</li>
<li>Create a Disk: &#8220;4&#8221;GB (thin provisioning and independent / persistent mode)<br/>
</li>
<li>Advanced Options: Enable &#8220;Support VMI Paravirtualization&#8221;<br/>
</li>
</ul>


<p>        <br/>
使用了<br/>
open-vm-tools<br/>
ec2-api-tools 是不是可以通过api来管理此虚拟机，或者获得性能等。ec2-api是什么东东？<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">获取源代码</h4>
<div class="outline-text-4" id="text-1-2-1">

<p><a href="http://www.vyatta.org/downloads/source-code">http://www.vyatta.org/downloads/source-code</a><br/>
</p>
<p><br/>
git clone <a href="http://git.vyatta.com/build-iso.git">http://git.vyatta.com/build-iso.git</a><br/>
cd build-iso<br/>
注意要先调整到一个分支或者tag<br/>
build-iso$ git branch &ndash;track &lt;branch&gt; origin/&lt;branch&gt;<br/>
build-iso$ git checkout &lt;branch&gt;<br/>
或者<br/>
git checkout tagv1<br/>
</p>
<p><br/>
获取子模块的代码<br/>
git submodule init<br/>
git submodule update pkgs/SUBMODULE<br/>
</p>
<p><br/>
克隆所有模块<br/>
git submodule update<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">install</h4>
<div class="outline-text-4" id="text-1-2-2">

<p>启动虚拟机,用缺省的用户名/密码 vyatta/vyatta登陆系统<br/>
install image 基于image安装，推荐,可以切换image<br/>
install system 基于disk安装，传统硬盘安装方式<br/>
</p>
<p><br/>
There are two types of installations that can be performed on a persistent device: <br/>
• Image-based install. The simplest, most flexible, and most powerful way to <br/>
install a Vyatta system is using a binary system image. With this method, you can <br/>
install multiple versions of the Vyatta system as images and switch between the <br/>
images simply and easily. You install the image from a LiveCD then you reboot <br/>
your system and it runs the image. <br/>
• Disk-based install. A disk-based install also installs from a LiveCD onto a <br/>
persistent device such as a hard disk partition. However, unlike an image-based <br/>
install, a disk-based install uses a traditional layout of files on the disk. <br/>
Additional system images may be added at a later time to a system created using <br/>
a disk-based install. <br/>
</p>
<p><br/>
nstall-image (is what I would suggest btw) is using squashfs and is capable of booting/running multiple images of versions<br/>
</p>
<p><br/>
真让我好找，找了一天，终于找到安装脚本了，在pkgs/vyatta-cfg-system<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">debian install</h4>
<div class="outline-text-4" id="text-1-2-3">

<p>这个貌似比较重要，vyatta之所以看不太明白，应该是对d-i不了解。<br/>
看看internal<br/>
<a href="http://d-i.alioth.debian.org/doc/internals/">http://d-i.alioth.debian.org/doc/internals/</a><br/>
</p></div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">配置ip</h4>
<div class="outline-text-4" id="text-1-2-4">

<p>vyatta@vyatta:~$ configure<br/>
vyatta@vyatta# set interfaces ethernet eth0 address 192.168.1.81/24<br/>
vyatta@vyatta# commit<br/>
vyatta@vyatta# exit<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-5" class="outline-4">
<h4 id="sec-1-2-5">启动webui</h4>
<div class="outline-text-4" id="text-1-2-5">

<p>vyatta@R1# set service https<br/>
不过需要商业版才能使用webui<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2-6" class="outline-4">
<h4 id="sec-1-2-6">linux-image</h4>
<div class="outline-text-4" id="text-1-2-6">

<p>vyatta的内核配置<br/>
/home/liwei/work/src_analysis/tag_vyatta_src/pkgs/linux-image/debian/arch/i386/config.586-vyatta-virt<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[shell命令技巧收集]]></title>
    <link href="http://emmoblin.github.com/blog/2012/11/16/shell-skill/"/>
    <updated>2012-11-16T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/11/16/shell-skill</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">资料，有空在整理</h3>
<div class="outline-text-3" id="text-1-1">

<p>隆重推荐，one line command<br/>
<a href="http://www.catonmat.net/">http://www.catonmat.net/</a><br/>
</p>
<p><br/>
<a href="http://os.51cto.com/art/201008/222287.htm">http://os.51cto.com/art/201008/222287.htm</a><br/>
<a href="http://os.51cto.com/art/201008/222743.htm">http://os.51cto.com/art/201008/222743.htm</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">添加上一个命令的最后一个参数</h3>
<div class="outline-text-3" id="text-1-2">

<p>Alt .<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">字符串比较，注意要用引号</h3>
<div class="outline-text-3" id="text-1-3">

<p>字符串比较说明<br/>
大多数时候，虽然可以不使用括起字符串和字符串变量的双引号，但这并不是好主意。为什么呢？因为如果环境变量中恰巧有一个空格或制表键，bash 将无法分辨，从而无法正常工作。这里有一个错误的比较示例：<br/>
 if [ $myvar = &#8220;foo bar oni&#8221; ]<br/>
then <br/>
     echo &#8220;yes&#8221;<br/>
fi<br/>
</p>
<p><br/>
在上例中，如果 myvar 等于 &#8220;foo&#8221;，则代码将按预想工作，不进行打印。但是，如果 myvar 等于 &#8220;foo bar oni&#8221;，则代码将因以下错误失败：<br/>
 [: too many arguments<br/>
</p>
<p><br/>
在这种情况下，&#8221;$myvar&#8221;（等于 &#8220;foo bar oni&#8221;）中的空格迷惑了 bash。bash 扩展 &#8220;$myvar&#8221; 之后，代码如下：<br/>
 [ foo bar oni = &#8220;foo bar oni&#8221; ]<br/>
</p>
<p><br/>
因为环境变量没放在双引号中，所以 bash 认为方括号中的自变量过多。可以用双引号将字符串自变量括起来消除该问题。请记住，如果养成将所有字符串自变量用双引号括起的习惯，将除去很多类似的编程错误。&#8221;foo bar oni&#8221; 比较 应该写成：<br/>
if [ &#8220;$myvar&#8221; = &#8220;foo bar oni&#8221; ]<br/>
then <br/>
     echo &#8220;yes&#8221;<br/>
fi<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">算术表达式 $(( ))</h3>
<div class="outline-text-3" id="text-1-4">

<p> $ myvar=&#8221;56&#8221;<br/>
 $ echo $(( $myvar + 12 ))<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">名字空间，全局性</h3>
<div class="outline-text-3" id="text-1-5">

<p>在 bash 中，每当在函数内部创建环境变量，就将其添加到 全局名称空间。这意味着，该变量将重写函数之外的全局变量，并在函数退出之后继续存在<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">捕获脚本的输出 2&gt;&amp;1 | tee T型管道</h3>
<div class="outline-text-3" id="text-1-6">

<p>当显示正在生成的输出时，捕获每个脚本的输出 <br/>
如果脚本不能自动地将输出发送到文件的话，可以利用 Bash shell 的一些函数来捕获所执行脚本的输出，如：<br/>
./test-bucket-1  -s  2&gt;&amp;1  | tee test-bucket-1.out<br/>
</p>
<p><br/>
让我们来分析上面的命令：<br/>
&#8220;2&gt;&amp;1&#8221; 命令：<br/>
使用 &#8220;2&gt;&amp;1&#8221; 将标准错误重定向到标准输出。字符串 &#8220;2&gt;&amp;1&#8221; 表明任何错误都应送到标准输出，即 UNIX/Linux 下 2 的文件标识代表标准错误，而 1 的文件标识代表标准输出。如果不用此字符串，那么所捕捉到的仅仅是正确的信息，错误信息会被忽略。<br/>
管道 &#8220;|&#8221; 和 &#8220;tee&#8221; 命令：<br/>
UNIX/Linux 进程和简单的管道概念很相似。既然这样，可以做一个管道将期望脚本的输出作为管道的输入。下一个要决定的是如何处理管道所输出的内容。在这种情况下，我们会将它捕获到输出文件中，在此示例中将之称为 &#8220;test-bucket-1.out&#8221;。<br/>
但是，除了要捕获到输出结果外，我们还想监视脚本运行时产生的输出。为达到此目的，我们连接允许两件事同时进行的 &#8220;tee&#8221; （T- 形管道）：将输出结果放在文件中同时将输出结果显示在屏幕上。 其管道类似于：<br/>
process &ndash;&gt; T &mdash;&gt; output file<br/>
             V<br/>
           screen<br/>
</p>
<p><br/>
如果 只 想捕获输出结果而不想在屏幕上看到输出结果，那可以忽略多余的管道： ./test-bucket-1 -s 2&gt;&amp;1 &gt; test-bucket-1.out<br/>
假若这样，相类似的管道如下：<br/>
process &ndash;&gt; output file<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">产生随机数</h3>
<div class="outline-text-3" id="text-1-7">

<p>dd if=/dev/urandom count=1 2&gt; /dev/null | cksum | cut -f1 -d&#8221; &#8221; <br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">取得一些文件名称中的一部分名称</h3>
<div class="outline-text-3" id="text-1-8">

<p>interfaces=`ls session_* | sed &#8216;s/^session_//g&#8217; | sed &#8216;s//.log$//g&#8217;`<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">如何用bash从文件中读一行</h3>
<div class="outline-text-3" id="text-1-9">

<p>while read line<br/>
  do<br/>
  echo $line<br/>
done &lt; &#8220;$filename&#8221;<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10">如何用bash发现某些文件中是否没有包含string</h3>
<div class="outline-text-3" id="text-1-10">


<p><br/>
jsps=`find . -name &#8220;*.jsp&#8221;`<br/>
</p>
<p><br/>
for jsp in $jsps; do<br/>
    havegb=`grep gb2312 $jsp`<br/>
        [ ! -n &#8220;$havegb&#8221; ] &amp;&amp; echo $jsp<br/>
done<br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[centos kdump]]></title>
    <link href="http://emmoblin.github.com/blog/2012/11/15/centos-kdump/"/>
    <updated>2012-11-15T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/11/15/centos-kdump</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">centos kdump</a>
<ul>
<li><a href="#sec-1-1">介绍</a></li>
<li><a href="#sec-1-2">安装</a></li>
<li><a href="#sec-1-3">添加内核启动参数</a></li>
<li><a href="#sec-1-4">配置文件</a></li>
<li><a href="#sec-1-5">测试</a></li>
<li><a href="#sec-1-6">用crash 工具分析vmcore 文件</a></li>
<li><a href="#sec-1-7">参考</a></li>
<li><a href="#sec-1-8">遗留问题</a></li>
<li><a href="#sec-1-9">systemtap</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/11/15/centos-kdump/">centos kdump</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">介绍</h3>
<div class="outline-text-3" id="text-1-1">

<p>通过kexec和kdump当内核crash的时候可以显示堆栈信息。方便调试。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">安装</h3>
<div class="outline-text-3" id="text-1-2">

<p>sudo yum install kexec-tools<br/>
sudo yum install kernel-debug kernel-debug-devel<br/>
yum install crash gdb<br/>
</p>
<p><br/>
为了让内核都统一，不妨内核也升级一下<br/>
yum install kernel kernel-devel<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">添加内核启动参数</h3>
<div class="outline-text-3" id="text-1-3">

<p>crashkernel=128M@16M<br/>
在/etc/grub.cfg中添加，表示启动的时候从16M的位置开始，预留128M内存用于crashkernel <br/>
注意centos6.2我发现可能已经默认支持了kdump，只是没有启动而已，grub.cfg中已经添加了crashkernel=auto<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">配置文件</h3>
<div class="outline-text-3" id="text-1-4">

<p>/etc/kdump.conf<br/>
配置coredump的位置，默认是 /var/crash<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">测试</h3>
<div class="outline-text-3" id="text-1-5">

<p>reboot后<br/>
这会创建/boot/initrd-kdump.img用于capture coredump，这非常重要，否则kdump就会启动失败。<br/>
该文件就是kdump加载的内核的 initrd文件，收集dump信息的工作就是在该initrd的启动环境下进行的。<br/>
查看/etc/init.d/kdump脚本的代码，你可看到其中会调用mkdumprd命令创建用于dump的initrd文件。<br/>
</p>
<p><br/>
service kdump status<br/>
</p>
<p><br/>
触发crash<br/>
echo 1 &gt; /proc/sys/kernel/sysrq<br/>
echo &#8220;c&#8221; &gt; /proc/sysrq-trigger<br/>
</p>
<p><br/>
等待时间比较长，大概5分钟，系统又重新进入了桌面。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">用crash 工具分析vmcore 文件</h3>
<div class="outline-text-3" id="text-1-6">


<p><br/>
用crash 命令分析vmcore 的命令行格式如下所示. <br/>
用crash打开vmcore后，主要是用dmesg及 bt 命令打印出问题的执行路径的call trace, <br/>
用dis 反汇编出代码，最终确认call trace对应的C源码中的位置，再进行逻辑分析.<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">参考</h3>
<div class="outline-text-3" id="text-1-7">

<p><a href="http://www.linuxidc.com/Linux/2011-03/33548.htm">http://www.linuxidc.com/Linux/2011-03/33548.htm</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">遗留问题</h3>
<div class="outline-text-3" id="text-1-8">

<p>用crash需要vmlinux，到哪里获得？<br/>
可能需要安装kernel-debuginfo<br/>
但标准库里可能没有，需要另外添加。<br/>
<a href="http://www.dedoimedo.com/computers/centos-debug.html">http://www.dedoimedo.com/computers/centos-debug.html</a><br/>
</p>
<p><br/>
<a href="http://wiki.centos.org/AdditionalResources/Repositories">http://wiki.centos.org/AdditionalResources/Repositories</a><br/>
已经说得很清楚了，需要额外添加debuginfo的库<br/>
不过看到centos6.2中自带了<br/>
 /etc/yum.repos.d/CentOS-Debuginfo.repo<br/>
<b>注意把其中的enabled改为1</b>,然后就可以安装了<br/>
kernel-debuginfo 将近300M<br/>
</p>
<p><br/>
先不下了，速度太慢了，10k。<br/>
</p>
<p><br/>
还有个问题，就算能看vmcore了，那模块coredump也能看吗？<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">systemtap</h3>
<div class="outline-text-3" id="text-1-9">

<p>有空再研究一下kprobe和systemtap<br/>
<a href="http://hi.baidu.com/donglix/item/13052275911e7a5f0c0a07f8">http://hi.baidu.com/donglix/item/13052275911e7a5f0c0a07f8</a><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gcov]]></title>
    <link href="http://emmoblin.github.com/blog/2012/11/02/gcov/"/>
    <updated>2012-11-02T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/11/02/gcov</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">gcov</a>
<ul>
<li><a href="#sec-1-1">分支覆盖的作用</a></li>
<li><a href="#sec-1-2">参考</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/11/02/gcov/">gcov</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">分支覆盖的作用</h3>
<div class="outline-text-3" id="text-1-1">

<p>所有单元测试跑完后，统计分支覆盖率，统计测试的是否全面。一个程序如果每个分支都执行过了，也不能保证程序就是正确的。<br/>
毕竟还有很多逻辑错误，但至少能从某种程度上显示出，这些代码测试的是否完善，不完善就还需要补充测试用例。<br/>
可以显示出每行被执行了多少次，哪行没有被执行。<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">参考</h3>
<div class="outline-text-3" id="text-1-2">

<p><a href="http://www.taobaotest.com/blogs/qa?bid=8451">GCOV 实现原理</a><br/>
&lt;深入浅出Linux平台代码覆盖率测试.pdf&gt;<br/>
</p>
<p><br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c单元测试框架:cutter]]></title>
    <link href="http://emmoblin.github.com/blog/2012/11/02/cutter/"/>
    <updated>2012-11-02T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/11/02/cutter</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">特性</h3>
<div class="outline-text-3" id="text-1-1">

<p>c的单元测试见的多了，cutter有什么看家本领吗？<br/>
</p><ol>
<li>框平台性好<br/>
   这个貌似意义不大，单元测试框架一般本身都很小巧，移植难度很小。<br/>

<p><br/>
</p></li>
<li>自动探测用例<br/>
   这个功能不错，只要开头是test_ 开头的函数，自动认为是testcase。<br/>
   其实他是把testcase编译成了库，然后进行符号查找。<br/>

<p><br/>
</p></li>
<li>显示友好<br/>
   尽量精确的提出错误在哪里，有个expect和real，貌似还可以diff。<br/>

<p><br/>
</p></li>
<li>支持数据驱动测试<br/>
   这个功能还有点不明白，貌似应该是测试前准备数据集的功能，不知道是否是mock功能。<br/>

<p><br/>
</p></li>
<li>支持代码的分支覆盖率攻击。<br/>

<p><br/>
</p></li>
<li>针对ubuntu特别优化。<br/>
</li>
</ol>


<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">后续待添加功能</h3>
<div class="outline-text-3" id="text-1-2">

<p>从他的TODO中可以看到一些，不过我最期望的是：<br/>
</p><ol>
<li>测试用例的search<br/>
</li>
<li>内存泄漏测试，最好集成memwatch的功能。mem_limit很好。<br/>
</li>
<li>是否有mock功能？<br/>
</li>
</ol>


<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">主页</h3>
<div class="outline-text-3" id="text-1-3">

<p><a href="http://sourceforge.net/projects/cutter/">http://sourceforge.net/projects/cutter/</a><br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[memwatch]]></title>
    <link href="http://emmoblin.github.com/blog/2012/10/30/memwatch-/"/>
    <updated>2012-10-30T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/10/30/memwatch-</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">memwatch</a>
<ul>
<li><a href="#sec-1-1">Memwatch简介</a></li>
<li><a href="#sec-1-2">MemWatch的内存处理</a></li>
<li><a href="#sec-1-3">初始化和结束处理</a></li>
<li><a href="#sec-1-4">MemWatch的I/O 操作</a></li>
<li><a href="#sec-1-5">使用</a>
<ul>
<li><a href="#sec-1-5-1">使用MemWatch提供的功能</a></li>
</ul>
</li>
<li><a href="#sec-1-6">Memwatch使用注意</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/10/30/memwatch-/">memwatch</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">Memwatch简介</h3>
<div class="outline-text-3" id="text-1-1">

<p>在三种检测工具当中，设置最简单的算是memwatch，和dmalloc一样，<br/>
它能检测未释放的内存、同一段内存被释放多次、位址存取错误及不当使用未分配之内存区域。<br/>
请往<br/>
<a href="http://www.linkdata.se/sourcecode.html">http://www.linkdata.se/sourcecode.html</a><br/>
下载最新版本的Memwatch。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">MemWatch的内存处理</h3>
<div class="outline-text-3" id="text-1-2">

<p>MemWatch将所有分配的内存用0xFE填充，所以，如果你看到错误的数据是用0xFE填充的，那就是你没有初始化数据。<br/>
例外是calloc()，它会直接把分配的内存用0填充。<br/>
</p>
<p><br/>
MemWatch将所有已释放的内存用0xFD填充(zapped with 0xFD).<br/>
如果你发现你使用的数据是用0xFD填充的，那你就使用的是已释放的内存。<br/>
在这种情况，注意MemWatch会立即把一个&#8221;释放了的块信息&#8221; 填在释放了的数据前。<br/>
这个块包括关于内存在哪儿释放的信息，以可读的文本形式存放，格式 为&#8221;FBI&lt;counter&gt;filename(line)&#8221;。<br/>
如:&#8221;FBI&lt;267&gt;test.c(12)&#8221;.使用FBI会降 低free()的速度，所以默认是关闭的。使用mwFreeBufferInfo(1)开启。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">初始化和结束处理</h3>
<div class="outline-text-3" id="text-1-3">

<p>一般来说，在程序中使用MemWatch的功能，可以手动添加mwInit()进行初始化，并用对应的mwTerm ()进行结束处理。<br/>
一般不需要手动添加，memwatch会在第一个malloc的时候自动初始化，并在atexit中添加mwTerm。<br/>
</p>
<p><br/>
如果自动初始化不合适或者程序比较特殊，请显式调用mwInit()和mwTerm().<br/>
比如，有的时候明明程序没有问题，而memwatch显示内存泄漏，这时就需要手动调用初始化和结束。<br/>
</p>
<p><br/>
涉及的函数主要有：<br/>
mwInit()    mwTerm()    mwAbort()<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">MemWatch的I/O 操作</h3>
<div class="outline-text-3" id="text-1-4">

<p>对于一般的操作，MemWatch创建memwatch.log文件。有时，该文件不能被创建;<br/>
MemWatch会试图创建memwatNN.log文件，NN在01~99之间。<br/>
</p>
<p><br/>
如果你不能使用日志，或者不想使用，也没有问题。<br/>
只要使用类型为&#8221;void func(int c)&#8221;的参数调用mwSetOutFunc()，然后所有的输出都会按字节定向到该函数.<br/>
</p>
<p><br/>
当ASSERT或者VERIFY失败时，MemWatch也有Abort/Retry/Ignore处理机制。<br/>
默认的处理机制没有I/O操作，但是会自动中断程序。<br/>
你可以使用任何其他Abort/Retry/Ignore的处理机制,只要以参数&#8221;void func(int c)&#8221;调用mwSetAriFunc()。<br/>
</p>
<p><br/>
涉及的函数主要有：<br/>
mwTrace()           mwPuts()        mwSetOutFunc()  mwSetAriFunc()<br/>
mwSetAriAction()    mwAriHandler()  mwBreakOut()<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">使用</h3>
<div class="outline-text-3" id="text-1-5">

<p>在要使用MemWatch的.c文件中包含头文件&#8221;memwatch.h&#8221;<br/>
</p>
<p><br/>
使用GCC编译（注意：不是链接）自己的程序时，加入-DMEMWATCH -DMW_STDIO<br/>
如：gcc -DMEMWATCH -DMW_STDIO –o test.o –c  test1.c memwatch.c<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">使用MemWatch提供的功能</h4>
<div class="outline-text-4" id="text-1-5-1">

<ol>
<li>mwTRACE，mwASSERT，mwVERIFY和mwPuts<br/>
</li>
<li>ARI机制即程序设置的“Abort, Retry, Ignore选择陷阱<br/>
</li>
<li>mwSetOutFunc<br/>
   将输出转向调用者给出的函数(参数即函数地址)。参数为NULL，表示把输出写入日志文件memwatch.log.<br/>
</li>
<li>mwIsReadAddr<br/>
   检查内存是否有读取的权限<br/>
</li>
<li>mwIsSafeAddr<br/>
   检查内存是否有读、写的权限<br/>
</li>
<li>mwStatistics<br/>
   设置状态搜集器的行为。对应的参数采用宏定义。<br/>

<p><br/>
   #define MW_STAT_GLOBAL  0       <i>* 仅搜集全局状态信息 *</i><br/>
   #define MW_STAT_MODULE  1       <i>* 搜集模块级的状态信息 *</i><br/>
   #define MW_STAT_LINE    2       <i>* 搜集代码行级的状态信息 *</i><br/>
   #define MW_STAT_DEFAULT 0       <i>* 默认状态设置 *</i><br/>
</p></li>
</ol>


<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">Memwatch使用注意</h3>
<div class="outline-text-3" id="text-1-6">

<p>Memwatch 的优点是无需特別配置，不需安装便能使用，但缺点是它会拖慢程序的运行速度，尤其是释放内存时它会作大量检查。<br/>
但它比mtrace和dmalloc多了 一项功能，就是能模拟系统内存不足的情況，<br/>
使用者只需用mwLimit(long num_of_byte)函数来限制程式的heap memory大小(以byte单位)。<br/>
</p>
<p><br/>
最详细的使用说明(包括优点缺点，运行原理等)已在README中列出，本人强烈建议各位读者参考该文件。<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>
</div>
</div>
]]></content>
  </entry>
  
</feed>
