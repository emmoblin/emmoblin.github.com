<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tools | Emmoblin Blog]]></title>
  <link href="http://emmoblin.github.com/blog/categories/tools/atom.xml" rel="self"/>
  <link href="http://emmoblin.github.com/"/>
  <updated>2013-03-24T21:03:31+08:00</updated>
  <id>http://emmoblin.github.com/</id>
  <author>
    <name><![CDATA[emmoblin]]></name>
    <email><![CDATA[emmoblin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[expect自动ssh登录]]></title>
    <link href="http://emmoblin.github.com/blog/2013/03/17/expect/"/>
    <updated>2013-03-17T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/03/17/expect</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">自动ssh的expect脚本</h3>
<div class="outline-text-3" id="text-1-1">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">!/usr/bin/</span><span style="color: #0000ff;">expect</span><span style="color: #8c8c8c; font-style: italic;"> </span>
<span style="color: #a52a2a;">set</span> timeout 5
<span style="color: #a52a2a;">set</span> cmd_prompt <span style="color: #00bfff;">"]#|~]?"</span>
<span style="color: #a52a2a;">set</span> server [lindex $<span style="color: #ff1493;">argv</span> 0] 
<span style="color: #a52a2a;">set</span> user [lindex $<span style="color: #ff1493;">argv</span> 1] 
<span style="color: #a52a2a;">set</span> passwd [lindex $<span style="color: #ff1493;">argv</span> 2] 

spawn ssh -l $<span style="color: #ff1493;">user</span> $<span style="color: #ff1493;">server</span> 
expect { 
<span style="color: #00bfff;">"(yes/no)"</span> { send <span style="color: #00bfff;">"yes\r"</span>; exp_continue } 
<span style="color: #00bfff;">"password:"</span> { send <span style="color: #00bfff;">"$passwd\r"</span> } 
}
<span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">expect "$cmd_prompt" interact</span>
expect <span style="color: #00bfff;">"*Last login*"</span> interact
</pre>



</p></div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xlicp在命令行下使用剪切板]]></title>
    <link href="http://emmoblin.github.com/blog/2013/03/11/xclip/"/>
    <updated>2013-03-11T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/03/11/xclip</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">xlicp在命令行下使用剪切板</h3>
<div class="outline-text-3" id="text-1-1">

<p>一、安装xclip<br/>
ubuntu下的用户可以只用apt-get来安装：<br/>
</p>
<p><br/>
sudo apt-get install xclip<br/>
其他发行版的用户可以选择自己的安装方式，也可以用源码编译安装，xclip项目的主页是：<a href="http://sourceforge.net/projects/xclip/">http://sourceforge.net/projects/xclip/</a><br/>
</p>
<p><br/>
二、使用<br/>
xclip可以将内容输出到‘X’的剪切板中，比如：<br/>
</p>
<p><br/>
echo "Hello, world" | xclip<br/>
执行这个命令后你就可以用鼠标中键来在X程序中将内容粘贴出来。但是更多的时候，我们需要不仅仅把内容输出到‘X’的剪切板中，而是希望可以在GUI程序中用ctrl + v也可以粘贴（比如，输出到gnome的剪切板中），下面这段命令就可以让你将内容输出到gnome的剪切板中：<br/>
</p>
<p><br/>
echo "Hello, world" | xclip -selection clipboard<br/>
再在一个GUI程序中按下ctrl + v，看下是不是粘贴上去了呢？顺着这个命令，我也重新写了一下ifconfig，让它在执行后输入内容到终端的同时，也将ip地址输出到剪切板中，因为通常情况下，查看ifconfig就是为了获取机器的ip地址：<br/>
</p>
<p><br/>
alias ifconfig='/sbin/ifconfig &amp;&amp; echo `/sbin/ifconfig | sed -n 2p | awk "{ print \\$2 }" | grep -o "[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}"` | xclip -selection clipboard'<br/>
</p></div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[zsh]]></title>
    <link href="http://emmoblin.github.com/blog/2013/03/10/zsh/"/>
    <updated>2013-03-10T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/03/10/zsh</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">zsh 配置</h3>
<div class="outline-text-3" id="text-1-1">


</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">setopt autocd</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>如果你想要避免在切换目录时一直输入乏味的cd命令（比如使用/etc而不是cd /etc）你可以设置autocd选项。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">PS1</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>转义序列        打印效果<br/>
%T      系统时间（时：分）<br/>
%*      系统时间（时：分：秒）<br/>
%D      系统日期（年-月-日）<br/>
%n      你的用户名<br/>
%B - %b 开始到结束使用粗体打印<br/>
%U - %u 开始到结束使用下划线打印<br/>
%d      你目前的工作目录<br/>
%~      你目前的工作目录相对于～的相对路径<br/>
%M      计算机的主机名<br/>
%m      计算机的主机名（在第一个句号之前截断）<br/>
%l      你当前的tty<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">zsh设置为默认sh</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>我们可以通过usermod命令来设置某一个给定用户的shell。<br/>
</p>
<p><br/>
代码 4.1: 使用usermod命令永久地切换到zsh<br/>
usermod -s /bin/zsh userlogin<br/>
</p>
<p><br/>
或者<br/>
（使用你的用户名替代"username"）<br/>
$ chsh -s /bin/zsh username<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">其他</h4>
<div class="outline-text-4" id="text-1-1-4">

<p>setopt AUTO_CONTINUE<br/>
</p>
<p><br/>
为了提交工作效率，可以定义一些函数或者常用的alias<br/>
f() {<br/>
    echo "find . -iname \"<b>$1</b>\""<br/>
    find . -iname "<b>$1</b>"<br/>
}<br/>
</p>
<p><br/>
</p>
<p><br/>
autoload copy-earlier-word<br/>
zle -N copy-earlier-word<br/>
bindkey '^[,' copy-earlier-word<br/>
</p>
<p><br/>
</p>
<p><br/>
setopt AUTO_PUSHD<br/>
setopt PUSHD_IGNORE_DUPS<br/>
</p>
<p><br/>
my_accounts=(<br/>
{r00t,root}@{192.168.1.1,192.168.0.1}<br/>
kardinal@linuxtoy.org<br/>
123@211.148.131.7<br/>
)<br/>
zstyle ':completion:*:my-accounts' users-hosts $my_accounts<br/>
</p>
<p><br/>
zstyle ':completion:*:scp:*' tag-order \<br/>
   files users 'hosts:-host hosts:-domain:domain hosts:-ipaddr"IP\ Address *'<br/>
zstyle ':completion:*:scp:*' group-order \<br/>
   files all-files users hosts-domain hosts-host hosts-ipaddr<br/>
zstyle ':completion:*:ssh:*' tag-order \<br/>
   users 'hosts:-host hosts:-domain:domain hosts:-ipaddr"IP\ Address *'<br/>
zstyle ':completion:*:ssh:*' group-order \<br/>
   hosts-domain hosts-host users hosts-ipaddr<br/>
zstyle '*' single-ignored show<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-5" class="outline-4">
<h4 id="sec-1-1-5">hash 路径别名</h4>
<div class="outline-text-4" id="text-1-1-5">

<p>hash -d blog="/home/henryyan/work/blog/henryyan.github.com"<br/>
cd ~blog<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-6" class="outline-4">
<h4 id="sec-1-1-6">文件关联</h4>
<div class="outline-text-4" id="text-1-1-6">

<p>在图形化的文件管理器中，通常我们只要单击/双击某个文件，文件管理器就会调用相应的程序来打开该文件。<br/>
其实，这样的文件关联在 Zsh 中也可以实现。具体操作步骤如下：<br/>
添加下列内容到你的 $HOME/.zshrc 文件中：<br/>
autoload -U zsh-mime-setup<br/>
zsh-mime-setup<br/>
以关联扩展名为 png 的图像文件为例，假设要通过 pho 程序来查看，那么在 $HOME/.zshrc 中可以这样定义：<br/>
alias -s png=pho<br/>
我们以 alias 的形式来实现文件关联，其中 png 为要关联文件的扩展名，= 右边的 pho 为关联的程序。这里的 -s 必不可少。<br/>
要关联其他类型的文件，只需如法炮制即可。<br/>
为了使 .zshrc 生效，需要 source 该文件。<br/>
现在，在 Zsh 中，例如要查看 linuxtoy.png 文件，只要输入该文件名（可按 Tab 自动补完）并按回车，Zsh 便会自动调用 pho 来打开。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-7" class="outline-4">
<h4 id="sec-1-1-7">cd扩展</h4>
<div class="outline-text-4" id="text-1-1-7">

<p>“cd ….”之类，会根据点的个数补全路径，比如 “…”补全为 “../../” ，“….”补全为 “../../..”<br/>
</p>
<p><br/>
配合我修改的 tab 键：空行 tab 出 “cd ”，自己点点点后回车，O了<br/>
</p>
<p><br/>
</p>
<p><br/>
<pre class="example">user-ret(){
    if [[ $BUFFER = "" ]] ;then
        BUFFER="ls"
        zle end-of-line
        zle accept-line
    elif [[ $BUFFER =~ "^cd\ ...+$" ]] ;then
        BUFFER=${${BUFFER//./..\/}/..\//}
        zle end-of-line
        zle accept-line
    else
        zle accept-line
    fi
}
zle -N user-ret
bindkey "\r" user-ret
</pre>

</p></div>
</div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[grub重定向到串口]]></title>
    <link href="http://emmoblin.github.com/blog/2013/03/02/grub-output-to-serial/"/>
    <updated>2013-03-02T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/03/02/grub-output-to-serial</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">** grub输出到串口</h3>
<div class="outline-text-3" id="text-1-1">

<p>将GRUB输出重定向到串口(Edit /boot/grub/grub.conf)<br/>
</p>
<p><br/>
<pre class="example">serial --unit=0 --speed=115200 --word=8 --parity=no --stop=1
terminal --timeout=5 console serial
</pre>


grub引导过程中, 会将输出同时发送到终端屏幕和串口. <br/>
grub引导过程中将在终端和连接到串口的超级终端上提示Press any key to continue, <br/>
每秒钟提示一次, 共5次, 可修改menu.lst文件terminal行中的&ndash;timeout=10改变提示次数, <br/>
在这一段时间内, 可以在终端的键盘, 或者连接到串口的超级终端中按任意键进入grub选择菜单. <br/>
如果5秒内没有在终端和连接串口的超级终端上按任意键, 则grub的选择菜单将出现在console上, <br/>
如果希望默认情况下, grub选择菜单出现在串口上, 则可修改grub.conf将<br/>
console serial修改为serial console.<br/>
</p>
<p><br/>
将kernel输出信息输出到串口(编辑 /boot/grub/grub.conf 有的为menu.lst)<br/>
增加kernel引导参数如下:<br/>
</p>
<p><br/>
<pre class="example">kernel  /boot/vmlinuz-2.6.32-29 root=/dev/hda1 ro console=ttyS0,115200n8 console=tty0
</pre>


grub2的例子<br/>
修改文件/etc/default/grub<br/>
</p>
<p><br/>
<pre class="example">#显示启动菜单
#GRUB_HIDDEN_TIMEOUT=0
修改相应的变量如下：
GRUB_CMDLINE_LINUX="console=ttyS0,115200"
GRUB_TERMINAL=serial
GRUB_SERIAL_COMMAND="serial --unit=0 --speed=115200 --word=8 --parity=no --stop=1"
</pre>


</p><ol>
<li>运行命令， 更新grub<br/>
   <code>sudo update-grub</code><br/>

<p><br/>
</p></li>
<li>在/etc/init/下，创建文件ttyS0.conf：<br/>
</li>
</ol>


<p><br/>
<pre class="example"># ttyS0 - getty
start on stopped rc RUNLEVEL=[23]
stop on runlevel [!23]

respawn
exec /sbin/getty -L 115200 ttyS0 vt100
</pre>


</p><ol>
<li>查看/etc/securetty中，含有ttyS0否。没有则加上。<br/>
</li>
<li>BIOS开启串口<br/>
</li>
<li>另一台机器，联上串口线，开启teraterm,设置115200 8n1<br/>
</li>
<li>重启机器, 看到teraterm输出Linux的启动信息。<br/>
</li>
</ol>


<p><br/>
通过比较生成的grub.cfg<br/>
发现多了一个<br/>
</p>
<p><br/>
<pre class="example">terminal_output serial
terminal_input serial
</pre>

</p>
<p> <br/>
</p></div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nc使用]]></title>
    <link href="http://emmoblin.github.com/blog/2013/02/27/netcat/"/>
    <updated>2013-02-27T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2013/02/27/netcat</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">基本使用</h3>
<div class="outline-text-3" id="text-1-1">

<p>本地监听<br/>
<code>nc -l 3333</code><br/>
远端访问<br/>
<code>nc 192.168.0.1 3333</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">传送文件</h3>
<div class="outline-text-3" id="text-1-2">

<p>发送端<br/>
<code>cat backup.iso | nc -l 3333</code><br/>
接收端<br/>
<code>nc 192.168.0.1 3333 &gt; backup.iso</code><br/>
</p>
<p><br/>
显示传送进度，可以使用管道监控,pv命令<br/>
以上命令修改为：<br/>
<code>cat backup.iso | pv -b | nc -l 3333</code><br/>
<code>nc 192.168.0.1 3333 | pv -b &gt; backup.iso</code><br/>
</p>
<p><br/>
本地打包文件，传送到远端<br/>
<code>tar -czf - /etc/ | nc -l 3333</code><br/>
接收端<br/>
<code>nc 192.168.0.1 3333 | pv -b &gt; mybackup.tar.gz</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">端口扫描</h3>
<div class="outline-text-3" id="text-1-3">

<p>扫描端口，并返回相关信息<br/>
<code>nc -z 192.168.0.1 80-90</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">资料</h3>
<div class="outline-text-3" id="text-1-4">

<p><a href="http://www.sans.org/security-resources/sec560/netcat_cheat_sheet_v1.pdf">http://www.sans.org/security-resources/sec560/netcat\_cheat\_sheet\_v1.pdf</a><br/>
<a href="http://www.g-loaded.eu/2006/11/06/netcat-a-couple-of-useful-examples/">http://www.g-loaded.eu/2006/11/06/netcat-a-couple-of-useful-examples/</a><br/>
</p>
<p><br/>
</p></div>
</div>
</div>

]]></content>
  </entry>
  
</feed>
