<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: shell | Emmoblin Blog]]></title>
  <link href="http://emmoblin.github.com/blog/categories/shell/atom.xml" rel="self"/>
  <link href="http://emmoblin.github.com/"/>
  <updated>2013-02-13T01:27:12+08:00</updated>
  <id>http://emmoblin.github.com/</id>
  <author>
    <name><![CDATA[emmoblin]]></name>
    <email><![CDATA[emmoblin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[shell代码片段收集]]></title>
    <link href="http://emmoblin.github.com/blog/2012/12/05/shell-snippet-collect/"/>
    <updated>2012-12-05T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/12/05/shell-snippet-collect</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">shell代码片段收集</a>
<ul>
<li><a href="#sec-1-1">获取磁盘大小</a></li>
<li><a href="#sec-1-2">变为大写</a></li>
<li><a href="#sec-1-3">判断返回值</a></li>
<li><a href="#sec-1-4">提问</a></li>
<li><a href="#sec-1-5">for循环</a></li>
<li><a href="#sec-1-6">while and until</a></li>
<li><a href="#sec-1-7">case</a></li>
<li><a href="#sec-1-8">读取文件</a></li>
<li><a href="#sec-1-9">awk按域搜索的例子</a></li>
</ul>
</li>
</ul>
</div>
</div>




<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.comblog/categories/shell/atom.xml">shell代码片段收集</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">获取磁盘大小</h3>
<div class="outline-text-3" id="text-1-1">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Return the size of the drive in MB</span>
get_drive_size () {
  <span style="color: #ff1493;">ldrive</span>=$<span style="color: #ff1493;">1</span>

  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Make sure you can print disk info using parted</span>
  parted --script /dev/$<span style="color: #ff1493;">ldrive</span> print &gt;/dev/null 2&gt;&amp;1

  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">If unable to read disk, it's likely it needs a disklabel</span>
  <span style="color: #0000ff;">if</span> [  <span style="color: #00bfff;">"$?"</span> != <span style="color: #00bfff;">"0"</span> ]; <span style="color: #0000ff;">then</span>
    <span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">"Creating a new disklabel on $ldrive"</span> &gt;&gt; $<span style="color: #ff1493;">INSTALL_LOG</span>
    <span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">"parted /dev/$ldrive mklabel msdos"</span> &gt;&gt; $<span style="color: #ff1493;">INSTALL_LOG</span>
    <span style="color: #ff1493;">output</span>=$(<span style="color: #ff00ff;">parted</span> -s /dev/$<span style="color: #ff1493;">ldrive</span> mklabel msdos)

    <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Get the drive size from parted</span>
    <span style="color: #ff1493;">lsize</span>=$(<span style="color: #ff00ff;">parted</span> -s /dev/$<span style="color: #ff1493;">ldrive</span> p | grep <span style="color: #00bfff;">"^Disk"</span> | awk <span style="color: #00bfff;">'{ print $3 }'</span>)

    <span style="color: #0000ff;">if</span> [ $(<span style="color: #ff00ff;">echo</span> $<span style="color: #ff1493;">lsize</span> | grep error) ]; <span style="color: #0000ff;">then</span>
      <span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">"Unable to read disk label.  Exiting."</span>
      <span style="color: #0000ff;">exit</span> 1
    <span style="color: #0000ff;">fi</span>
  <span style="color: #0000ff;">fi</span>

  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Get the drive size from parted</span>
  <span style="color: #ff1493;">lsize</span>=$(<span style="color: #ff00ff;">parted</span> -s /dev/$<span style="color: #ff1493;">ldrive</span> p | grep <span style="color: #00bfff;">"^Disk"</span> | awk <span style="color: #00bfff;">'{ print $3 }'</span>)
  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Get the reported units (mB, GB, kB)</span>
  <span style="color: #ff1493;">lmodifier</span>=$(<span style="color: #ff00ff;">echo</span> $<span style="color: #ff1493;">lsize</span> | sed <span style="color: #00bfff;">'s/[0-9\.]//g'</span>)
  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">remove the modifier</span>
  <span style="color: #ff1493;">lsize</span>=$(<span style="color: #ff00ff;">echo</span> $<span style="color: #ff1493;">lsize</span> | sed <span style="color: #00bfff;">'s/[a-z,A-Z]//g'</span>)
  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Remove any fractions</span>
  <span style="color: #ff1493;">lsize</span>=$(<span style="color: #ff00ff;">echo</span> $<span style="color: #ff1493;">lsize</span> | cut -f1 -d<span style="color: #00bfff;">'.'</span>)
  <span style="color: #8c8c8c; font-style: italic;"># </span><span style="color: #8c8c8c; font-style: italic;">Translate our size into mB if not there already</span>
  <span style="color: #0000ff;">if</span> [ $<span style="color: #ff1493;">lmodifier</span> = <span style="color: #00bfff;">"GB"</span> ]; <span style="color: #0000ff;">then</span> 
    <span style="color: #ff1493;">lsize</span>=$(($<span style="color: #ff1493;">lsize</span> * 1000))
  <span style="color: #0000ff;">elif</span> [ $<span style="color: #ff1493;">lmodifier</span> = <span style="color: #00bfff;">"kB"</span> ]; <span style="color: #0000ff;">then</span> 
    <span style="color: #ff1493;">lsize</span>=$(($<span style="color: #ff1493;">lsize</span> / 1000))
  <span style="color: #0000ff;">fi</span>

  <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">lsize</span>
}

</pre>


disk_size=`fdisk -l $CF | grep MB | cut -d":" -f2 | cut -d "," -f1| sed s/MB//g `<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">变为大写</h3>
<div class="outline-text-3" id="text-1-2">


<p><br/>
<pre class="src src-sh">upper_str()
{
        <span style="color: #ff1493;">upper</span>=<span style="color: #ff00ff;">`echo $1 | tr "[a-z]" "[A-Z]"`</span>
        <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">upper</span>
}
</pre>


</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">判断返回值</h3>
<div class="outline-text-3" id="text-1-3">


<p><br/>
<pre class="src src-sh"><span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">TOS_VERSION</span> | grep <span style="color: #00bfff;">"^3.3.016"</span> 
<span style="color: #0000ff;">if</span> [  $? != 0  ]
<span style="color: #0000ff;">then</span> 
        <span style="color: #ff1493;">VERSION_016</span>=<span style="color: #00bfff;">"false"</span>
<span style="color: #0000ff;">else</span>
        <span style="color: #ff1493;">VERSION_016</span>=<span style="color: #00bfff;">"true"</span>
<span style="color: #0000ff;">fi</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">提问</h3>
<div class="outline-text-3" id="text-1-4">


<p><br/>
<pre class="src src-sh">auto_echo <span style="color: #00bfff;">"Are you sure to begin[y/n]:"</span>
<span style="color: #0000ff;">while </span><span style="color: #a52a2a;">read</span> answer
<span style="color: #0000ff;">do</span>
<span style="color: #ff1493;">answer</span>=<span style="color: #ff00ff;">`upper_str $answer`</span>
<span style="color: #0000ff;">if</span> [ <span style="color: #00bfff;">"$answer"</span> = <span style="color: #00bfff;">"Y"</span> ] 
<span style="color: #0000ff;">then</span>
<span style="color: #0000ff;">break</span>
<span style="color: #0000ff;">elif</span> [ <span style="color: #00bfff;">"$answer"</span> = <span style="color: #00bfff;">"N"</span> ] 
<span style="color: #0000ff;">then</span>
write_free
<span style="color: #0000ff;">exit</span>
<span style="color: #0000ff;">fi</span>
auto_echo <span style="color: #00bfff;">"Are you sure to begin[y/n]:"</span>
<span style="color: #0000ff;">done</span>
</pre>

</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">for循环</h3>
<div class="outline-text-3" id="text-1-5">


<p><br/>
<pre class="src src-sh"><span style="color: #0000ff;">for</span> x<span style="color: #0000ff;"> in</span> /var/log/*
<span style="color: #0000ff;">do</span>
    <span style="color: #a52a2a;">echo</span> <span style="color: #ff00ff;">`basename $x`</span> is a file living<span style="color: #0000ff;"> in</span> /var/log
<span style="color: #0000ff;">done</span>
</pre>

</p>
<p> <br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">while and until</h3>
<div class="outline-text-3" id="text-1-6">


<p><br/>
<pre class="src src-sh"><span style="color: #ff1493;">myvar</span>=0
<span style="color: #0000ff;">while</span> [ $<span style="color: #ff1493;">myvar</span> -ne 10 ]
<span style="color: #0000ff;">do</span>
    <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">myvar</span>
    <span style="color: #ff1493;">myvar</span>=$(( $<span style="color: #ff1493;">myvar</span> + 1 ))
<span style="color: #0000ff;">done</span>


<span style="color: #ff1493;">myvar</span>=0
<span style="color: #0000ff;">until</span> [ $<span style="color: #ff1493;">myvar</span> -eq 10 ]
<span style="color: #0000ff;">do</span>
    <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">myvar</span>
    <span style="color: #ff1493;">myvar</span>=$(( $<span style="color: #ff1493;">myvar</span> + 1 ))
<span style="color: #0000ff;">done</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">case</h3>
<div class="outline-text-3" id="text-1-7">

<p>*$x为文件名，只获取文件的后缀，至于是为什么现在不明白? *<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #0000ff;">case</span> <span style="color: #00bfff;">"${x##*.}"</span><span style="color: #0000ff;"> in</span>
     gz)
           gzunpack ${<span style="color: #ff1493;">SROOT</span>}/${<span style="color: #ff1493;">x</span>}
           ;;
     bz2)
           bz2unpack ${<span style="color: #ff1493;">SROOT</span>}/${<span style="color: #ff1493;">x</span>}
           ;;
     *)
           <span style="color: #a52a2a;">echo</span> <span style="color: #00bfff;">"Archive format not recognized."</span>
           <span style="color: #0000ff;">exit</span>
           ;;
<span style="color: #0000ff;">esac</span>
</pre>


</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">读取文件</h3>
<div class="outline-text-3" id="text-1-8">


<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">! /bin/</span><span style="color: #0000ff;">bash</span><span style="color: #8c8c8c; font-style: italic;">  </span>
<span style="color: #0000ff;">while </span><span style="color: #a52a2a;">read</span> LINE
<span style="color: #0000ff;">do</span>
        <span style="color: #a52a2a;">echo</span> $<span style="color: #ff1493;">LINE</span> 
<span style="color: #0000ff;">done</span> &lt; /etc/passwd
</pre>


</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">awk按域搜索的例子</h3>
<div class="outline-text-3" id="text-1-9">


<p><br/>
<pre class="src src-sh"><span style="color: #0000ff;">while </span><span style="color: #a52a2a;">read</span> line; 
        <span style="color: #0000ff;">do</span> cp aaaa $<span style="color: #ff1493;">line</span>;
<span style="color: #0000ff;">done</span> &lt;&lt; (awk <span style="color: #00bfff;">'{for(i=1; i &lt;= NF; ++i){if($i ~/^-l/){gsub("^-l","lib",$i); printf("%s.so\n", $i)}}}'</span> libso.txt  | sort -u)
</pre>

</p></div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[shell命令技巧收集]]></title>
    <link href="http://emmoblin.github.com/blog/2012/11/16/shell-skill/"/>
    <updated>2012-11-16T00:00:00+08:00</updated>
    <id>http://emmoblin.github.com/blog/2012/11/16/shell-skill</id>
    <content type="html"><![CDATA[<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">资料，有空在整理</h3>
<div class="outline-text-3" id="text-1-1">

<p>隆重推荐，one line command<br/>
<a href="http://www.catonmat.net/">http://www.catonmat.net/</a><br/>
</p>
<p><br/>
<a href="http://os.51cto.com/art/201008/222287.htm">http://os.51cto.com/art/201008/222287.htm</a><br/>
<a href="http://os.51cto.com/art/201008/222743.htm">http://os.51cto.com/art/201008/222743.htm</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">添加上一个命令的最后一个参数</h3>
<div class="outline-text-3" id="text-1-2">

<p>Alt .<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">字符串比较，注意要用引号</h3>
<div class="outline-text-3" id="text-1-3">

<p>字符串比较说明<br/>
大多数时候，虽然可以不使用括起字符串和字符串变量的双引号，但这并不是好主意。为什么呢？因为如果环境变量中恰巧有一个空格或制表键，bash 将无法分辨，从而无法正常工作。这里有一个错误的比较示例：<br/>
 if [ $myvar = "foo bar oni" ]<br/>
then <br/>
     echo "yes"<br/>
fi<br/>
</p>
<p><br/>
在上例中，如果 myvar 等于 "foo"，则代码将按预想工作，不进行打印。但是，如果 myvar 等于 "foo bar oni"，则代码将因以下错误失败：<br/>
 [: too many arguments<br/>
</p>
<p><br/>
在这种情况下，"$myvar"（等于 "foo bar oni"）中的空格迷惑了 bash。bash 扩展 "$myvar" 之后，代码如下：<br/>
 [ foo bar oni = "foo bar oni" ]<br/>
</p>
<p><br/>
因为环境变量没放在双引号中，所以 bash 认为方括号中的自变量过多。可以用双引号将字符串自变量括起来消除该问题。请记住，如果养成将所有字符串自变量用双引号括起的习惯，将除去很多类似的编程错误。"foo bar oni" 比较 应该写成：<br/>
if [ "$myvar" = "foo bar oni" ]<br/>
then <br/>
     echo "yes"<br/>
fi<br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">算术表达式 $(( ))</h3>
<div class="outline-text-3" id="text-1-4">

<p> $ myvar="56"<br/>
 $ echo $(( $myvar + 12 ))<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">名字空间，全局性</h3>
<div class="outline-text-3" id="text-1-5">

<p>在 bash 中，每当在函数内部创建环境变量，就将其添加到 全局名称空间。这意味着，该变量将重写函数之外的全局变量，并在函数退出之后继续存在<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">捕获脚本的输出 2&gt;&amp;1 | tee T型管道</h3>
<div class="outline-text-3" id="text-1-6">

<p>当显示正在生成的输出时，捕获每个脚本的输出 <br/>
如果脚本不能自动地将输出发送到文件的话，可以利用 Bash shell 的一些函数来捕获所执行脚本的输出，如：<br/>
./test-bucket-1  -s  2&gt;&amp;1  | tee test-bucket-1.out<br/>
</p>
<p><br/>
让我们来分析上面的命令：<br/>
"2&gt;&amp;1" 命令：<br/>
使用 "2&gt;&amp;1" 将标准错误重定向到标准输出。字符串 "2&gt;&amp;1" 表明任何错误都应送到标准输出，即 UNIX/Linux 下 2 的文件标识代表标准错误，而 1 的文件标识代表标准输出。如果不用此字符串，那么所捕捉到的仅仅是正确的信息，错误信息会被忽略。<br/>
管道 "|" 和 "tee" 命令：<br/>
UNIX/Linux 进程和简单的管道概念很相似。既然这样，可以做一个管道将期望脚本的输出作为管道的输入。下一个要决定的是如何处理管道所输出的内容。在这种情况下，我们会将它捕获到输出文件中，在此示例中将之称为 "test-bucket-1.out"。<br/>
但是，除了要捕获到输出结果外，我们还想监视脚本运行时产生的输出。为达到此目的，我们连接允许两件事同时进行的 "tee" （T- 形管道）：将输出结果放在文件中同时将输出结果显示在屏幕上。 其管道类似于：<br/>
process &ndash;&gt; T &mdash;&gt; output file<br/>
             V<br/>
           screen<br/>
</p>
<p><br/>
如果 只 想捕获输出结果而不想在屏幕上看到输出结果，那可以忽略多余的管道： ./test-bucket-1 -s 2&gt;&amp;1 &gt; test-bucket-1.out<br/>
假若这样，相类似的管道如下：<br/>
process &ndash;&gt; output file<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">产生随机数</h3>
<div class="outline-text-3" id="text-1-7">

<p>dd if=/dev/urandom count=1 2&gt; /dev/null | cksum | cut -f1 -d" " <br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">取得一些文件名称中的一部分名称</h3>
<div class="outline-text-3" id="text-1-8">

<p>interfaces=`ls session_* | sed 's/^session_//g' | sed 's//.log$//g'`<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">如何用bash从文件中读一行</h3>
<div class="outline-text-3" id="text-1-9">

<p>while read line<br/>
  do<br/>
  echo $line<br/>
done &lt; "$filename"<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10">如何用bash发现某些文件中是否没有包含string</h3>
<div class="outline-text-3" id="text-1-10">


<p><br/>
jsps=`find . -name "*.jsp"`<br/>
</p>
<p><br/>
for jsp in $jsps; do<br/>
    havegb=`grep gb2312 $jsp`<br/>
        [ ! -n "$havegb" ] &amp;&amp; echo $jsp<br/>
done<br/>
</p></div>
</div>
</div>

]]></content>
  </entry>
  
</feed>
