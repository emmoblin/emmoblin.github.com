
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Emmoblin Blog</title>
  <meta name="author" content="emmoblin">

  
  <meta name="description" content="">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://emmoblin.github.com/blog/page/5">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/bootstrap/bootstrap.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/bootstrap/responsive.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/syntax/syntax.css" media="screen, projection" rel="stylesheet" type="text/css">
  <style type="text/css">
    body {
      padding-bottom: 40px;
    }
    h1 {
      margin-bottom: 15px;
    }
    img {
      max-width: 100%;
    }
    .sharing, .meta, .pager {
      margin: 20px 0px 20px 0px;
    }
    .page-footer p {
      text-align: center;
    }
  </style>
  <script src="/javascripts/libs/jquery.js"></script>
  <script src="/javascripts/libs/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/bootstrap.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Emmoblin Blog" type="application/atom+xml">
  
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34538597-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><div class="navbar">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>

      <a class="brand" href="/">Emmoblin Blog</a>

      <div class="nav-collapse">
        <ul class="nav">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>


        <ul class="nav pull-right" data-subscription="rss">
          <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
          
        </ul>

        
          <form class="pull-right navbar-search" action="http://google.com/search" method="get">
            <fieldset role="search">
              <input type="hidden" name="q" value="site:emmoblin.github.com" />
              <input class="search-query" type="text" name="q" results="0" placeholder="Search"/>
            </fieldset>
          </form>
        
      </div>
    </div>
  </div>
</div>
</nav>
  <div class="container">
    <div class="row-fluid">
      <div class="span9">
  
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2012/10/16/svn/">Svn使用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-16T00:00:00+08:00" pubdate data-updated="true">2012年10月16日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">svn使用</a>
<ul>
<li><a href="#sec-1-1">svn libneon的问题</a></li>
<li><a href="#sec-1-2">自己编译，真的不容易啊</a></li>
<li><a href="#sec-1-3">分支管理</a></li>
<li><a href="#sec-1-4">svn-commit.tmp</a></li>
<li><a href="#sec-1-5">删除文件</a></li>
<li><a href="#sec-1-6">merge</a>
<ul>
<li><a href="#sec-1-6-1">代码回滚</a></li>
</ul>
</li>
<li><a href="#sec-1-7">cat</a></li>
<li><a href="#sec-1-8">status -u</a></li>
<li><a href="#sec-1-9">ignore</a></li>
<li><a href="#sec-1-10">add * &ndash;force</a></li>
<li><a href="#sec-1-11">svn服务器IP修改后,本地怎么跟新svn同步,svn relocate 操作</a></li>
<li><a href="#sec-1-12">svn -v log</a></li>
<li><a href="#sec-1-13">参考资料</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/10/16/svn/">svn使用</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">svn libneon的问题</h3>
<div class="outline-text-3" id="text-1-1">

<p>ubuntu安装的svn要使用https时，默认使用的libneon-gnutls有点兼容性问题。所以导致的错误是：<br/>
SSL handshake failed: SSL 错误：在证书中检测到违规的密钥用法。<br/>
解决办法：<br/>
<a href="http://www.yeap.de/blog2.0/archives/260-Subversion-Certificate-Problems-with-Ubuntu-Precise-Pangolin.html">http://www.yeap.de/blog2.0/archives/260-Subversion-Certificate-Problems-with-Ubuntu-Precise-Pangolin.html</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">自己编译，真的不容易啊</h3>
<div class="outline-text-3" id="text-1-2">

<p>cd openssl<br/>
由于是64bit系统，所以需要添加fPIC<br/>
./config -fPIC<br/>
但是cropt目录不好添加fPIC，难道生成的.a难道也需要fPIC吗？，所以无奈，只能先安装系统的openssl<br/>
apt-get install openssl-dev openssl<br/>
</p>
<p><br/>
cd subversion<br/>
./configure &ndash;with-ssl=openssl &ndash;with-neon=./neon &ndash;with-openssl=/usr<br/>
出现warnning无用理会直接make<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">分支管理</h3>
<div class="outline-text-3" id="text-1-3">

<p>一般svn版本库目录建议创建trunk、branches和tags三个目录。 <br/>
trunk主干版本要时刻保持干净，即随时可以基于这个版本进行修改并将应用部署上线。<br/>
branches是分支目录，存放并行开发的项目代码，因为分支是主干的廉价拷贝，所以你可以放心建立很多分支版本。<br/>
不过Subversion不支持跨版本库的拷贝，当使用svn copy时你只能在同一个版本库内操作。<br/>
tags目录存放trunk某个的快照。<br/>
</p>
<p><br/>
</p><ol>
<li>svn copy 创建分支<br/>
</li>
</ol>


<p><br/>
<pre class="src src-sh">svn copy -m <span style="color: #00bfff;">"1.7.2 - theme"</span> svn://localhost/www/trunk svn://localhost/www/branches/branch1.7.2-theme
svn co svn://localhost/www/branches/branch1.7.2-theme
</pre>


注意，如果想更换其他用户，可以使用：<br/>
svn &ndash;username john &ndash;password pass<br/>
</p>
<p><br/>
2） 开发了一段实现，要先把trunk版本merge过来<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">branch1.7.2-theme&#26159;&#20998;&#25903;&#30446;&#24405;&#65292;&#27880;&#24847;&#19981;&#21487;&#20197;&#36827;&#21040;&#20998;&#25903;&#23376;&#30446;&#24405;</span>
<span style="color: #a52a2a;">cd</span> branch1.7.2-theme
<span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">&#21069;&#38754;&#30340;12972&#26159;&#24320;&#20998;&#25903;&#20043;&#21069;trunk&#30340;&#29256;&#26412;&#21495;&#65292;&#21518;&#38754;&#30340;12991&#26159;merge&#26102;trunk&#30340;&#29256;&#26412;&#21495;</span>
svn merge -r 12972:12991 svn://localhost/www/trunk
</pre>

解决冲突后，提交<br/>
</p>
<p><br/>
<pre class="src src-sh">svn ci -m <span style="color: #00bfff;">'svn merge -r 12972:12991 svn://localhost/www/trunk'</span>
</pre>


3） 从分支merge到trunk。上线测试完毕，你很幸运，一切都如预期正常，这时就要将分支回归trunk，将trunk更新到最新。<br/>
</p>
<p><br/>
<pre class="src src-sh"><span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">&#20808;&#20174;trunk checkout&#19968;&#20221;&#26032;&#40092;&#30340;&#20195;&#30721;&#65292;&#28982;&#21518;cd&#21040;&#35813;&#29256;&#26412;&#30446;&#24405;&#19979;</span>
svn co svn://localhost/www/trunk
<span style="color: #a52a2a;">cd</span> trunk
<span style="color: #8c8c8c; font-style: italic;">#</span><span style="color: #8c8c8c; font-style: italic;">12973&#26159;&#20998;&#25903;&#24320;&#22987;&#30340;&#29256;&#26412;&#21495;&#65292;13006&#26159;&#20998;&#25903;&#32467;&#26463;&#30340;&#29256;&#26412;&#21495;</span>
svn merge -r 12973:13006 svn://localhost/www/branches/branch1.7.2-theme
</pre>


</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">svn-commit.tmp</h3>
<div class="outline-text-3" id="text-1-4">

<p>看看 svn help commit, 发现有 -F 可以用, 平常都只有用 -m &#8216;message&#8217; 而已.<br/>
-m: 在于只有一行打完, 可以快速 commit 用. <br/>
</p>
<p><br/>
<pre class="example">ex: svn ci -m 'log message'
</pre>

-F: 会把档案内容读进来, 然后直接 commit, 想当然就用 -F 直接取 svn-commit.tmp 来 commit. <br/>
</p>
<p><br/>
<pre class="example">ex: svn ci -F svn-commit.tmp
</pre>


PS: commit 完后, 还是要手动 rm svn-commit.tmp<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">删除文件</h3>
<div class="outline-text-3" id="text-1-5">

<p><code>svn delete path -m “delete test fle“</code><br/>
例如：<br/>
<code>svn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file”</code><br/>
或者直接<br/>
</p>
<p><br/>
<pre class="example">svn delete test.php
svn ci -m ‘delete test file‘
</pre>

推荐使用这种简写：svn (del, remove, rm)<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">merge</h3>
<div class="outline-text-3" id="text-1-6">

<p><code>svn merge -r m:n path</code><br/>
例如：<br/>
<code>svn merge -r 200:205 test.php</code><br/>
（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下）<br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">代码回滚</h4>
<div class="outline-text-4" id="text-1-6-1">

<p>撤销一个已提交的版本,修改有误，不应该提交，需要回滚到上一个版本<br/>
执行命令<br/>
<code>$svn merge -r 20:19 $URL</code><br/>
检查工作拷贝结果<br/>
<code>$svn status</code><br/>
提交拷贝结果<br/>
=$svn ci -m &#8220;undo change commited in r20&#8221;=<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">cat</h3>
<div class="outline-text-3" id="text-1-7">

<p> svn cat -r 2 filename 显示文件指定版本内容<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">status -u</h3>
<div class="outline-text-3" id="text-1-8">

<p>与版本库最新版本比较，*提示文件需要更新<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">ignore</h3>
<div class="outline-text-3" id="text-1-9">

<p>添加ignore<br/>
svn propedit svn:ignore calc<br/>
</p>
<p><br/>
被svn坑了，原来默认是忽略.o,.a，.so之类的。<br/>
svn add &ndash;no-ignore .<br/>
</p>
<p><br/>
查看某次提交忽略的文件：svn status &ndash;no-ignore xxxroot <br/>
设置忽略文件列表svn pe svn:ignore xxxx <br/>
设置全局忽略文件列表<br/>
编辑~/.subversion/config文件，修改此文件中的global-ignores，<br/>
例如，想让subversion忽略vim的交换文件文件，可以这样设置：<br/>
global-ignores = *.o *.swp<br/>
</p>
<p><br/>
<b>root用户的配置是 /etc/subversion/config</b><br/>
</p>
<p><br/>
svn st &ndash;no-ignore 查看所有<br/>
遇到的问题，添加的时候<br/>
svn add &ndash;no-ignore *<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10">add * &ndash;force</h3>
<div class="outline-text-3" id="text-1-10">

<p>并没有把剩余的添加上，只能通过一个一个目录来添加，不知道为什么?<br/>
解决：<br/>
通常情况下，命令svn add *会忽略所有已经在版本控制之下的目录，<br/>
有时候，你会希望添加所有工作拷贝的未版本化文件，包括那些隐藏在深处的文件，可以使用svn add的&ndash;force递归到版本化的目录下：<br/>
<code>$ svn add * --force</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-11" class="outline-3">
<h3 id="sec-1-11">svn服务器IP修改后,本地怎么跟新svn同步,svn relocate 操作</h3>
<div class="outline-text-3" id="text-1-11">

<p>svn switch &ndash;relocate URL1 URL2<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-12" class="outline-3">
<h3 id="sec-1-12">svn -v log</h3>
<div class="outline-text-3" id="text-1-12">

<p>查看每次提交修改的文件列表。<br/>
svn -v log<br/>
svn -v -r 35 log dir/<br/>
</p>
<p><br/>
</p>
<p><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-13" class="outline-3">
<h3 id="sec-1-13">参考资料</h3>
<div class="outline-text-3" id="text-1-13">

<p><a href="http://subversion.apache.org/faq.zh.html">FAQ</a><br/>
</p>
<p><br/>
</p></div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2012/10/16/ckermit/">串口工具ckermit</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-16T00:00:00+08:00" pubdate data-updated="true">2012年10月16日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">串口工具ckermit</a>
<ul>
<li><a href="#sec-1-1">默认配置文件</a></li>
<li><a href="#sec-1-2">操作</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/10/16/ckermit/">串口工具ckermit</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">默认配置文件</h3>
<div class="outline-text-3" id="text-1-1">

<p>/etc/kermit/kermrc<br/>
一般配置一个home下的自己的配置文件就ok了。<br/>
~/.kermrc<br/>
</p>
<p><br/>
<pre class="example">set line /dev/ttyS0
set speed 9600
set carrier-watch off
set handshake none
set flow-control none
robust
set file type bin
set file name lit
set rec pack 1000
set send pack 1000
set window 5
</pre>


</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">操作</h3>
<div class="outline-text-3" id="text-1-2">

<p>C-\ 切换到命令行<br/>
c 打开链接<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2012/10/12/thunderbirdskill/">Thunderbird技巧</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-12T00:00:00+08:00" pubdate data-updated="true">2012年10月12日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">插件</h3>
<div class="outline-text-3" id="text-1-1">


</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">mouseless mutt key</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>像mutt一样操作邮件，非常方便。<br/>
m： write email<br/>
n/p: next,preview<br/>
r: re<br/>
f: forward<br/>
s: 加星<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">Contact Tabs</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>方便查看联系人<br/>
</p></div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">Thunderbird Conversations</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>把显示样式呈现的更友好<br/>
</p>
<p><br/>
</p></div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">实现回复在前面</h3>
<div class="outline-text-3" id="text-1-2">

<p>默认Thunderbird是将回复加在回复邮件的后面，可以通过修改配置项实现回复在前面，<br/>
首选项&ndash;&gt;高级&ndash;&gt;高级配置&ndash;&gt;配置编辑器<br/>
找到配置编辑器，将 mail.identity.default.reply_on_top 这一项由默认的0改为1即可。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">3列显示</h3>
<div class="outline-text-3" id="text-1-3">

<p>在view显示为垂直视图<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2012/10/10/dropbox-under-ubuntu/">Ubuntu使用dropbox</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-10T00:00:00+08:00" pubdate data-updated="true">2012年10月10日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">对ubuntu one有点失望</h3>
<div class="outline-text-3" id="text-1-1">

<p>我本来是用ubuntu one，但是我先在使用ubuntu one来同步我的org笔记，同时我的org笔记又使用hg同步。<br/>
也就是一个文件夹同时使用hg和ubuntu one同步，结果发现ubuntu one同步总是出错，尤其是我使用hg fetch一个版本的时候。<br/>
经常把我一个文件夹的内容同步没了，幸亏我有hg，否则这些文件就丢失啦。<br/>
所以决定还是用dropbox吧，本来我手机使用dropbox来同步照片的，所以又申请了一个帐号，专门用于同步笔记。<br/>
而且最终要的是：<br/>
ubuntu one没有历史版本功能<br/>
而dropbox可以可以回退到以前的历史版本，这个非常好。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">dropbox同步任意文件夹问题</h3>
<div class="outline-text-3" id="text-1-2">

<p>本来还是我是打算用dropbox的，但是发现dropbox只能指定一个主目录，不想ubuntu one可以随便指定文件夹。<br/>
但后来发现，其实只要做一个软链接到Dropbox目录就ok了。<br/>
而且发现dropbox同步的速度非常快。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">dropbox安装</h3>
<div class="outline-text-3" id="text-1-3">

<p>需要使用https链接去登录dropbox主页，下边有如何安装的方式，很简单，就是wget一个压缩包，然后解压就ok了。<br/>
默认是.dropbox_dist目录。<br/>
然后启动dropboxd就ok了<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">ubuntu one的一些命令</h3>
<div class="outline-text-3" id="text-1-4">

<p>查看当前传输字节数<br/>
<code>u1sdtool --current-transfers</code><br/>
显示共享的文件夹<br/>
<code>u1sdtool --list-folders</code><br/>
删除文件夹<br/>
<code>u1sdtool --delete-folder=FOLDER_ID</code><br/>
其他命令使用&ndash;help查看<br/>
</p></div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2012/10/09/ssh-skill/">Ssh的一些技巧</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-09T00:00:00+08:00" pubdate data-updated="true">2012年10月09日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">ssh的一些技巧</a>
<ul>
<li><a href="#sec-1-1">多条连接共享</a></li>
<li><a href="#sec-1-2">长连接</a></li>
<li><a href="#sec-1-3">别再输入密码</a></li>
<li><a href="#sec-1-4">省去用户名</a></li>
<li><a href="#sec-1-5">在服务器间跳转</a></li>
<li><a href="#sec-1-6">穿越Web代理</a></li>
<li><a href="#sec-1-7">shfs</a></li>
<li><a href="#sec-1-8">使用本地App连接远程服务器</a></li>
<li><a href="#sec-1-9">减少延迟</a></li>
<li><a href="#sec-1-10">ssh-agent</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/10/09/ssh-skill/">ssh的一些技巧</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">多条连接共享</h3>
<div class="outline-text-3" id="text-1-1">

<p>如果你需要在多个窗口中打开到同一个服务器的连接，而不想每次都输入用户名，密码，或是等待连接建立，<br/>
那么你可以配置SSH的连接共享选项，在本地打开你的SSH配置文件，通常它们位于~/.ssh/config，然后添加下面2行：<br/>
ControlMaster auto<br/>
ControlPath /tmp/ssh_mux_%h_%p_%r<br/>
现在试试断开你与服务器的连接，并建立一条新连接，然后打开一个新窗口，再创建一条连接，你会发现，第二条连接几乎是在瞬间就建立好了。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">长连接</h3>
<div class="outline-text-3" id="text-1-2">

<p>如果你发现自己每条需要连接同一个服务器无数次，那么长连接选项就是为你准备的：<br/>
ControlPersist 4h<br/>
现在你每次通过SSH与服务器建立连接之后，这条连接将被保持4个小时，即使在你退出服务器之后，这条连接依然可以重用，<br/>
因此，在你下一次（4小时之内）登录服务器时，你会发现连接以闪电般的速度建立完成，<br/>
这个选项对于通过scp拷贝多个文件提速尤其明显，因为你不在需要为每个文件做单独的认证了。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">别再输入密码</h3>
<div class="outline-text-3" id="text-1-3">

<p>如果你还在通过密码方式登录SSH，那么你或许应该试试SSH Keys，首先使用OpenSSH为自己声称一对密钥：<br/>
$ ssh-keygen<br/>
跟随指示，完成之后，你应该可以在你的.ssh目录下看到两个文件，id_rsa就是你的私钥，而id_ras.pub则是你的公钥，<br/>
现在你需要将你的公钥拷贝到服务器上，如果你的系统有ssh-copy-id命令，拷贝会很简单：<br/>
$ ssh-copy-id smylers@compo.example.org<br/>
否则，你需要手动将你的私钥拷贝的服务器上的~/.ssh/authorized_keys文件中：<br/>
$ &lt; ~/.ssh/id_rsa.pub ssh clegg.example.org ‘mkdir -p .ssh; cat &gt;&gt; .ssh/authorized_keys; chmod go-w .ssh .ssh/authorized_keys’<br/>
</p>
<p><br/>
或者 cat ~/.ssh/id_dsa.pub | ssh you@remote &#8216;cat - &gt;&gt; ~/.ssh/authorized_keys&#8217;<br/>
现在试试重新连接到SSH服务器，或是拷贝文件，是不是已经不需要再输入密码了？<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">省去用户名</h3>
<div class="outline-text-3" id="text-1-4">

<p>如果你在远程服务器上的用户名和你本地的用户名不同，你同样可以在SSH配置中进行设置：<br/>
Host www* mail<br/>
HostName %h.example.com<br/>
User simon<br/>
现在就算我的本地用户名是 smylers，我仍然可以这样连接我的服务器：<br/>
$ ssh www2<br/>
SSH会使用simon账户连接你的服务器，同样，Putty可以保存这个信息在你的session中。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">在服务器间跳转</h3>
<div class="outline-text-3" id="text-1-5">

<p>有些时候，你可能没法直接连接到某台服务器，而需要使用一台中间服务器进行中转，这个过程也可以自动化。<br/>
首先确保你已经为服务器配置了公钥访问，并开启了agent forwarding，现在你就可以通过2条命令来连接目标服务器，不会有任何提示输入：<br/>
$ ssh gateway<br/>
gateway $ ssh db<br/>
然后在你的本地SSH配置中，添加下面这条配置：<br/>
Host db<br/>
HostName db.internal.example.com<br/>
ProxyCommand ssh gateway netcat -q 600 %h %p<br/>
现在你就可以通过一条命令来直接连接目标服务器了:<br/>
$ ssh db<br/>
这里你可能会需要等待长一点的时间，因为SSH需要进行两次认证，注意netcat也有可能被写成nc或者ncat或者前面还需要加上g，你需要检查你的中间服务器来确定实际的参数。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">穿越Web代理</h3>
<div class="outline-text-3" id="text-1-6">

<p>有些时候，你所在的网络不止封锁SSH端口，它们有可能更进一步，只让你通过Web代理来访问网络，幸运的是我们有一个叫做Corkscrew的程序可以通过Web代理来发送SSH数据。Corkscrew的使用非常简单，一般我都是在需要时搜索，然后直接下载，跟随网站上的指示，然后就搞定了，一般你需要这样一条配置：<br/>
ProxyCommand corkscrew proxy.example.org 8080 %h %p<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">shfs</h3>
<div class="outline-text-3" id="text-1-7">

<p>另一种让远程GUI程序显示在本地的替代方案就是让本地的GUI程序可以直接操作远程文件，你可以通过SSHFS来实现，只需要创建一个空目录，然后使用SSHFS将一个远程目录mount到这个目录就可以了：<br/>
$ mkdir gallery_src<br/>
$ sshfs dev:projects/gallery/src gallery_src<br/>
$ cd gallery_src<br/>
$ ls<br/>
现在你就可以使用任何你喜欢的本地程序来便捷这个目录中的文件了，它们看起来是在你的本地，但其实时远程服务器上的文件，你可以使用fusermount命令来unmount这些文件，不要担心记不住，它们就在<br/>
sshfs手册的顶上：<br/>
$ cd ..<br/>
$ fusermount -u gallery_src<br/>
SSHFS可以在Linux和OSX上工作，Windows用户我目前还没找到什么好办法。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">使用本地App连接远程服务器</h3>
<div class="outline-text-3" id="text-1-8">

<p>有时可能有些服务，比如数据库或是Web服务器，它们运行在远程服务器上，但是如果有用方式可以直接从本地程序连接它们，那会非常有用，要做到这一点，你需要用到端口转发(port forwarding)，<br/>
举个例子，如果你的服务器运行Postgres（并且只允许本地访问），那么你就可以在你的SSH配置中加入：<br/>
Host db<br/>
LocalForward 5433 localhost:5432<br/>
现在当你连接你的SSH服务器时，它会在你本地电脑打开一个5433端口（我随便挑的），并将所有发送到这个端口的数据转发到服务器的5432端口（Postgres的默认端口），然后，只要你和服务器建立了连接，你就可以通过5433端口来访问服务器的Postgres了。<br/>
$ ssh db<br/>
现在打开另外一个窗口，你就可以通过下面这条命令在本地连接你的Postgres数据库了：<br/>
$ psql -h localhost -p 5443 orders<br/>
如果你想要使用服务器不支持的图形化Postgres客户端时，这条命令会显得尤其有用：<br/>
$ pgadmin3 &amp;<br/>
或者你有一个后台的Web服务器，你不希望直接通过Internet访问它，你也可以通过端口转发来访问它：<br/>
Host api<br/>
LocalForward 8080 localhost:80<br/>
现在连接到服务器：<br/>
$ ssh api<br/>
然后将浏览器指向你选择的端口号：<br/>
$ firefox <a href="http://localhost:8080/">http://localhost:8080/</a><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">减少延迟</h3>
<div class="outline-text-3" id="text-1-9">

<p>如果每次连接服务器都意味着你需要等待几十秒而无所事事，那么你或许应该试试在你的SSH配置中加入下面这条：<br/>
GSSAPIAuthentication no<br/>
如果这条命令有效的话，你应该通知你的系统管理员让他在服务器上禁用这个选项，这样其他人就不用再分别添加这条配置到它们的本地配置了。<br/>
在server端修改：<br/>
/etc/ssh/sshd_config<br/>
添加<br/>
USEDNS no<br/>
service sshd restart<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10">ssh-agent</h3>
<div class="outline-text-3" id="text-1-10">

<p>如果你的密码加了密码，每次使用密钥都需要输入密码，则这时ssh-agent就起到作用了。<br/>
启动ssh-agent后，通过ssh-add ~/.ssh/id_rsa <br/>
把自己的私钥添加到agent后，以后再使用次密钥就不需要输入密码了。<br/>
</p>
<p><br/>
</p></div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2012/10/09/lsof/">A Unix Utility You Should Know About:lsof</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-09T00:00:00+08:00" pubdate data-updated="true">2012年10月09日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">A Unix Utility You Should Know About:lsof</a>
<ul>
<li><a href="#sec-1-1">前言</a></li>
<li><a href="#sec-1-2">如何使用lsof？</a></li>
<li><a href="#sec-1-3">找出谁在使用某个文件</a></li>
<li><a href="#sec-1-4">列出某个用户打开的所有文件</a></li>
<li><a href="#sec-1-5">查找某个程序打开的所有文件</a></li>
<li><a href="#sec-1-6">列出所有由某个用户或某个进程打开的文件</a></li>
<li><a href="#sec-1-7">列出除root用户外的所有用户打开的文件</a></li>
<li><a href="#sec-1-8">列出所有由某个PID对应的进程打开的文件</a></li>
<li><a href="#sec-1-9">列出所有网络连接</a></li>
<li><a href="#sec-1-10">列出所有NFS（网络文件系统）文件</a></li>
<li><a href="#sec-1-11">列出所有UNIX域Socket文件</a></li>
<li><a href="#sec-1-12">列出所有对应某个组id的进程</a></li>
<li><a href="#sec-1-13">列出所有与某个描述符关联的文件</a></li>
<li><a href="#sec-1-14">输出使用某些资源的进程pid</a></li>
<li><a href="#sec-1-15">循环列出文件</a></li>
<li><a href="#sec-1-16">如何安装lsof？</a></li>
<li><a href="#sec-1-17">原文</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/10/09/lsof/">A Unix Utility You Should Know About:lsof</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">前言</h3>
<div class="outline-text-3" id="text-1-1">

<p>这是“你应该知道的Unix和Linux命令”系列的第三篇，在这篇文章中，我会介绍lsof这个工具，如果说netcat是进行网络诊断的瑞士军刀，那么lsof就是Unix调试的瑞士军刀。<br/>
</p>
<p><br/>
Lsof是遵从Unix哲学的典范，它只做一件事情，并且做的相当完美——它可以列出某个进程打开的所有文件信息。<br/>
打开的文件可能是普通的文件，目录，NFS文件，块文件，字符文件，共享库，常规管道，明明管道，符号链接，Socket流，网络Socket，UNIX域Socket，以及其它更多。因为Unix系统中几乎所有东西都是文件，你可以想象lsof该有多有用。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">如何使用lsof？</h3>
<div class="outline-text-3" id="text-1-2">


<p><br/>
这篇文章中我会尽力列举我能想到的所有lsof的用法，让我们先从最简单的开始（或许你已经知道了），然后逐渐增加复杂度：<br/>
</p>
<p><br/>
列出所有打开的文件<br/>
</p>
<p><br/>
<code>lsof</code><br/>
</p>
<p><br/>
不带任何参数运行lsof会列出所有进程打开的所有文件。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">找出谁在使用某个文件</h3>
<div class="outline-text-3" id="text-1-3">


<p><br/>
<code>lsof /path/to/file</code><br/>
</p>
<p><br/>
只需要执行文件的路径，lsof就会列出所有使用这个文件的进程，你也可以列出多个文件，lsof会列出所有使用这些文件的进程。<br/>
</p>
<p><br/>
你也可以一次制定多个文件：<br/>
</p>
<p><br/>
<code>lsof /path/to/file1 /path/to/file2</code><br/>
</p>
<p><br/>
递归查找某个目录中所有打开的文件<br/>
</p>
<p><br/>
<code>lsof +D /usr/lib</code><br/>
</p>
<p><br/>
加上+D参数，lsof会对指定目录进行递归查找，注意这个参数要比grep版本慢：<br/>
</p>
<p><br/>
= lsof | grep &#8216;/usr/lib&#8217; =<br/>
</p>
<p><br/>
之所以慢是因为+D首先查找所有的文件，然后一次性输出。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">列出某个用户打开的所有文件</h3>
<div class="outline-text-3" id="text-1-4">


<p><br/>
<code>lsof -u pkrumins</code><br/>
</p>
<p><br/>
-u选项限定只列出所有被用户pkrumins打开的文件，你可以通过逗号指定多个用户：<br/>
</p>
<p><br/>
<code>lsof -u rms,root</code><br/>
</p>
<p><br/>
这条命令会列出所有rms和root用户打开的文件。<br/>
</p>
<p><br/>
你也可以像下面这样使用多个-u做同样的事情：<br/>
</p>
<p><br/>
<code>lsof -u rms -u root</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">查找某个程序打开的所有文件</h3>
<div class="outline-text-3" id="text-1-5">


<p><br/>
<code>lsof -c apache</code><br/>
</p>
<p><br/>
-c选项限定只列出以apache开头的进程打开的文件：<br/>
</p>
<p><br/>
所以你可以不用像下面这样写：<br/>
</p>
<p><br/>
<code>lsof | grep foo</code><br/>
</p>
<p><br/>
而使用下面这个更简短的版本：<br/>
</p>
<p><br/>
<code>lsof -c foo</code><br/>
</p>
<p><br/>
事实上，你可以只制定进程名称的开头：<br/>
</p>
<p><br/>
<code>lsof -c apa</code><br/>
</p>
<p><br/>
这会列出所有以apa开头的进程打开的文件<br/>
</p>
<p><br/>
你同样可以制定多个-c参数：<br/>
</p>
<p><br/>
<code>lsof -c apache -c python</code><br/>
</p>
<p><br/>
这会列出所有由apache和python打开的文件<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">列出所有由某个用户或某个进程打开的文件</h3>
<div class="outline-text-3" id="text-1-6">


<p><br/>
<code>lsof -u pkrumins -c apache</code><br/>
</p>
<p><br/>
你也可以组合使用多个选项，这些选项默认进行或关联，也就是说上面的命令会输入由pkrumins用户或是apache进程打开的文件。<br/>
</p>
<p><br/>
列出所有由一个用户与某个进程打开的文件<br/>
</p>
<p><br/>
<code>lsof -a -u pkrumins -c bash</code><br/>
</p>
<p><br/>
-a参数可以将多个选项的组合条件由或变为与，上面的命令会显示所有由pkrumins用户以及bash进程打开的文件。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">列出除root用户外的所有用户打开的文件</h3>
<div class="outline-text-3" id="text-1-7">


<p><br/>
<code>lsof -u ^root</code><br/>
</p>
<p><br/>
注意root前面的^符号，它执行取反操作，因此lsof会列出所有root用户之外的用户打开的文件。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8">列出所有由某个PID对应的进程打开的文件</h3>
<div class="outline-text-3" id="text-1-8">


<p><br/>
<code>lsof -p 1</code><br/>
</p>
<p><br/>
-p选项让你可以使用进程id来过滤输出。<br/>
</p>
<p><br/>
记住你也可以用都好来分离多个pid。<br/>
</p>
<p><br/>
<code>lsof -p 450,980,333</code><br/>
</p>
<p><br/>
列出所有进程打开的文件除了某个pid的<br/>
</p>
<p><br/>
<code>lsof -p ^1</code><br/>
</p>
<p><br/>
同前面的用户一样，你也可以对-p选项使用^来进行取反。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9">列出所有网络连接</h3>
<div class="outline-text-3" id="text-1-9">


<p><br/>
<code>lsof -i</code><br/>
</p>
<p><br/>
lsof的-i选项可以列出所有打开了网络套接字（TCP和UDP）的进程。<br/>
</p>
<p><br/>
列出所有TCP网络连接<br/>
</p>
<p><br/>
<code>lsof -i tcp</code><br/>
</p>
<p><br/>
也可以为-i选项加上参数，比如tcp，tcp选项会强制lsof只列出打开TCP sockets的进程。<br/>
</p>
<p><br/>
列出所有UDP网络连接<br/>
</p>
<p><br/>
<code>lsof -i udp</code><br/>
</p>
<p><br/>
同样udp让lsof只列出使用UDP socket的进程。<br/>
</p>
<p><br/>
找到使用某个端口的进程<br/>
</p>
<p><br/>
<code>lsof -i :25</code><br/>
</p>
<p><br/>
:25和-i选项组合可以让lsof列出占用TCP或UDP的25端口的进程。<br/>
</p>
<p><br/>
你也可以使用/etc/services中制定的端口名称来代替端口号，比如：<br/>
</p>
<p><br/>
<code>lsof -i :smtp</code><br/>
</p>
<p><br/>
找到使用某个udp端口号的进程<br/>
</p>
<p><br/>
<code>lsof -i udp:53</code><br/>
</p>
<p><br/>
同样的，也可以找到使用某个tcp端口的进程：<br/>
</p>
<p><br/>
<code>lsof -i tcp:80</code><br/>
</p>
<p><br/>
找到某个用户的所有网络连接<br/>
</p>
<p><br/>
<code>lsof -a -u hacker -i</code><br/>
</p>
<p><br/>
使用-a将-u和-i选项组合可以让lsof列出某个用户的所有网络行为。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10">列出所有NFS（网络文件系统）文件</h3>
<div class="outline-text-3" id="text-1-10">


<p><br/>
<code>lsof -N</code><br/>
</p>
<p><br/>
这个参数很好记，-N就对应NFS。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-11" class="outline-3">
<h3 id="sec-1-11">列出所有UNIX域Socket文件</h3>
<div class="outline-text-3" id="text-1-11">


<p><br/>
<code>lsof -U</code><br/>
</p>
<p><br/>
这个选项也很好记，-U就对应UNIX。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-12" class="outline-3">
<h3 id="sec-1-12">列出所有对应某个组id的进程</h3>
<div class="outline-text-3" id="text-1-12">


<p><br/>
<code>lsof -g 1234</code><br/>
</p>
<p><br/>
进程组用来来逻辑上对进程进行分组，这个例子查找所有PGID为1234的进程打开的文件。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-13" class="outline-3">
<h3 id="sec-1-13">列出所有与某个描述符关联的文件</h3>
<div class="outline-text-3" id="text-1-13">


<p><br/>
<code>lsof -d 2</code><br/>
</p>
<p><br/>
这个命令会列出所有以描述符2打开的文件。<br/>
</p>
<p><br/>
你也可以为描述符指定一个范围：<br/>
</p>
<p><br/>
<code>lsof -d 0-2</code><br/>
</p>
<p><br/>
这会列出所有描述符为0，1，2的文件。<br/>
</p>
<p><br/>
-d选项还支持其它很多特殊值，下面的命令列出所有内存映射文件：<br/>
</p>
<p><br/>
<code>lsof -d mem</code><br/>
</p>
<p><br/>
txt则列出所有加载在内存中并正在执行的进程：<br/>
</p>
<p><br/>
<code>lsof -d txt</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-14" class="outline-3">
<h3 id="sec-1-14">输出使用某些资源的进程pid</h3>
<div class="outline-text-3" id="text-1-14">


<p><br/>
<code>lsof -t -i</code><br/>
</p>
<p><br/>
-t选项输出进程的PID，你可以将它和-i选项组合输出使用某个端口的进程的PID，下面的命令将会杀掉所有使用网络的进程：<br/>
</p>
<p><br/>
<code>kill -9 `lsof -t -i`</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-15" class="outline-3">
<h3 id="sec-1-15">循环列出文件</h3>
<div class="outline-text-3" id="text-1-15">


<p><br/>
<code>lsof -r 1</code><br/>
</p>
<p><br/>
-r选项让lsof可以循环列出文件直到被中断，参数1的意思是每秒钟重复打印一次，这个选项最好同某个范围比较小的查询组合使用，比如用来监测网络活动：<br/>
</p>
<p><br/>
<code>lsof -r 1 -u john -i -a</code><br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-16" class="outline-3">
<h3 id="sec-1-16">如何安装lsof？</h3>
<div class="outline-text-3" id="text-1-16">


<p><br/>
许多Unix系统都内置了lsof，如果你的系统没有安装，你可以从这里直接下载源代码。<br/>
</p>
<p><br/>
BSD系统有一个类似的工具可以做同样的事情，叫做fstat。<br/>
</p>
<p><br/>
你可以通过man lsof来了解关于lsof的完整文档，或者通过lsof -h查看。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-17" class="outline-3">
<h3 id="sec-1-17">原文</h3>
<div class="outline-text-3" id="text-1-17">

<p><a href="http://www.catonmat.net/blog/unix-utilities-lsof/">http://www.catonmat.net/blog/unix-utilities-lsof/</a><br/>
还有pipe view和netcat，以后再总结<br/>
翻译：<br/>
<a href="http://heikezhi.com/2011/06/19/swiss-army-knife-of-unix-debugging-lsof/">http://heikezhi.com/2011/06/19/swiss-army-knife-of-unix-debugging-lsof/</a><br/>
</p></div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2012/09/11/functional-programming-is-hard-thats-why-its-good/">Functional-programming-is-hard-thats-why-its-good</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-09-11T00:00:00+08:00" pubdate data-updated="true">2012年09月11日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">functional-programming-is-hard-thats-why-its-good</a>
<ul>
<li><a href="#sec-1-1">函数式编程很难，这正是你要学习它的原因</a>
<ul>
<li><a href="#sec-1-1-1">它给你的初次印象不友善</a></li>
<li><a href="#sec-1-1-2">新奇事物</a></li>
<li><a href="#sec-1-1-3">眼见为实</a></li>
<li><a href="#sec-1-1-4">各有所求</a></li>
<li><a href="#sec-1-1-5">补充</a></li>
<li><a href="#sec-1-1-6">转载自: http://www.aqee.net/functional-programming-is-hard-thats-why-its-good/</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/09/11/functional-programming-is-hard-thats-why-its-good/">functional-programming-is-hard-thats-why-its-good</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">函数式编程很难，这正是你要学习它的原因</h3>
<div class="outline-text-3" id="text-1-1">

<p>很奇怪不是，很少有人每天都使用函数式编程语言。如果你用Scala，Haskell，Erlang，F#或某个Lisp方言来编程，很可能没有公司会花钱聘你。这个行业里的绝大部分人都是使用像Python，Ruby，Java或C#等面向对象的编程语言——它们用起来很顺手。不错，你也许会偶然用到一两个“函数式语言特征”，例如“block”，但人们不会去做函数式编程。<br/>
</p>
<p><br/>
然而，很多年来，我们一直被教导说函数式编程语言很好很棒。我仍然记得当我第一次阅读ESR的著名的关于学习Lisp语言的论文时的困惑。也许大多数的人对Paul Graham 的《Beating The Averages》这篇文章更加熟悉：<br/>
</p>
<p><br/>
使用Lisp开发使我们的开发周期迭代的如此之快，以至于有时当竞争对手在新闻发布会上推出他们的新功能一两天后，我们就能复制出同样的功能。当报道产品发布的新闻记者打电话给我们时，我们的产品已经拥有了同样的功能特征。<br/>
</p>
<p><br/>
那些皈依函数式编程的人中，一直常见的考虑是：学习这种新的、函数式的语言“对你有好处”；就像是某些人建议说每天30分钟的健身房活动会“让你的身体健康”一样。但这也同时暗示了这样做的难度和需要的付出。Lisp语言跟Haskell、Ocaml和Scala语言不同，被认为是出了名的难学，可以说是臭名昭著。文雅的人说这是Lisp语言的“深度&amp;广度”的体现。不文雅的人说这是“意淫”或“玩弄学术”或简单的“没必要”。我认为，它的难度跟你对它熟不熟悉有关，而且，这种难度是一种重要指标显示：学习这样的一种语言会让你编程更有效率、能力更强。<br/>
</p>
<p><br/>
</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2012/09/11/functional-programming-is-hard-thats-why-its-good/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header class="page-header">
    
      <h1 class="entry-title"><a href="/blog/2012/09/11/can-your-programming-language-do-this/">Can Your Programming Language Do This</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-09-11T00:00:00+08:00" pubdate data-updated="true">2012年09月11日</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">can your programming language do this</a>
<ul>
<li><a href="#sec-1-1">你的编程语言能这样做吗？</a></li>
<li><a href="#sec-1-2">转载自</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><a href="http://emmoblin.github.com/blog/2012/09/11/can-your-programming-language-do-this/">can your programming language do this</a></h2>
<div class="outline-text-2" id="text-1">


<p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">你的编程语言能这样做吗？</h3>
<div class="outline-text-3" id="text-1-1">

<p>一日，你查看你的程序代码，你有两大块代码看起来几乎完全的一样。事实上它们就是完全一样，除了一个代码里说的是“Spaghetti(意大利面条)”，另一个代码里说的是“Chocolate Moose(巧克力慕丝)”。<br/>
</p>
<p><br/>
<pre class="example">// 一个小例子：

alert("I'd like some Spaghetti!");
alert("I'd like some Chocolate Moose!");
</pre>

这个例子恰好是用Javascript写的，但即使是你不懂Javascript，你也应该能看懂我说的。<br/>
</p>
<p><br/>
当然，重复的代码看起来不太好。所以你决定写一个函数：<br/>
</p>
<p><br/>
<pre class="example">function SwedishChef( food )
{
    alert("I'd like some " + food + "!");
}

SwedishChef("Spaghetti");
SwedishChef("Chocolate Moose");
</pre>


没错，这个例子很简单，但你可以想出一些更有实际价值的例子。这样做是更好一些，有很多理由，这些理由估计你都听说过一万遍了。可维护性，可读性，抽象 = 好！<br/>
</p>
<p><br/>
</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2012/09/11/can-your-programming-language-do-this/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <ul class="pager">
    
    <li class="previous"><a href="/blog/page/6/">&larr; Older</a></li>
    
    <li><a href="/blog/archives">Blog Archives</a></li>
    
    <li class="next"><a href="/blog/page/4/">Newer &rarr;</a></li>
    
  </ul>
</div>
<aside class="sidebar-nav span3">
  
    <section>
  <h1>About Me</h1>
  <p><img src="/images/my_avatar.jpg"></p>
  <p>网络工程师，喜欢折腾linux，emacs。</p>
  <p>坚持理想，相信一定会实现。</p>
  <p><a href="mailto:emmoblin@gmail.com"><img src="/images/my_email.png" alt="emmoblin@gmail.com"></a></p>
</section>
<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/blog/categories/bodybuilding'>bodybuilding (1)</a></li><li><a href='/blog/categories/emacs'>emacs (3)</a></li><li><a href='/blog/categories/git'>git (2)</a></li><li><a href='/blog/categories/ipv6'>ipv6 (1)</a></li><li><a href='/blog/categories/kernel'>kernel (1)</a></li><li><a href='/blog/categories/ksplice'>ksplice (1)</a></li><li><a href='/blog/categories/linux'>linux (1)</a></li><li><a href='/blog/categories/linuxcmd'>linuxcmd (1)</a></li><li><a href='/blog/categories/lisp'>lisp (2)</a></li><li><a href='/blog/categories/lua'>lua (4)</a></li><li><a href='/blog/categories/markdown'>markdown (3)</a></li><li><a href='/blog/categories/nat'>nat (1)</a></li><li><a href='/blog/categories/netfilter'>netfilter (1)</a></li><li><a href='/blog/categories/octopress'>octopress (3)</a></li><li><a href='/blog/categories/open-sources'>open sources (1)</a></li><li><a href='/blog/categories/orgmode'>orgmode (1)</a></li><li><a href='/blog/categories/scm'>scm (2)</a></li><li><a href='/blog/categories/service'>service (3)</a></li><li><a href='/blog/categories/shell'>shell (4)</a></li><li><a href='/blog/categories/skill'>skill (1)</a></li><li><a href='/blog/categories/ssh'>ssh (2)</a></li><li><a href='/blog/categories/storage'>storage (3)</a></li><li><a href='/blog/categories/svn'>svn (2)</a></li><li><a href='/blog/categories/test'>test (1)</a></li><li><a href='/blog/categories/testunit'>testunit (3)</a></li><li><a href='/blog/categories/tools'>tools (11)</a></li><li><a href='/blog/categories/ubuntu'>ubuntu (4)</a></li><li><a href='/blog/categories/unittest'>unittest (3)</a></li></ul>
</section>

<section>
<h1>新浪微博</h1>
<ul id="weibo">
<li>
<iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" 
src="http://widget.weibo.com/weiboshow/index.php?
language=&
width=0&
height=550&
fansRow=2&
ptype=1&
speed=0&
skin=5&
isTitle=1&
noborder=1&
isWeibo=1&
isFans=0&
uid=1905507693&
verifier=e659651a&
dpc=1"></iframe>
</li>
</ul>
</section>

<section>
  <h1>近期评论</h1>
<script type="text/javascript" src="http://emmoblin.disqus.com/combination_widget.js?num_items=5&hide_mods=0&color=blue&default_tab=recent&excerpt_length=200"></script><a href="http://disqus.com/">Powered by Disqus</a>
</section>
<section class="well">
  <ul id="recent_posts" class="nav nav-list">
    <li class="nav-header">Recent Posts</li>
    
      <li class="post">
        <a href="/blog/2013/03/19/emacs-desktop/">emacs的desktop保存</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/17/expect/">expect自动ssh登录</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/12/nfs-server/">NFS server</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/11/xclip/">xlicp在命令行下使用剪切板</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/10/zsh/">zsh</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo" class="page-footer"><hr>
<p>
  Copyright &copy; 2013 - emmoblin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <br> <script src="http://s25.cnzz.com/stat.php?id=5063649&web_id=5063649&online=1&show=line" language="JavaScript"></script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'emmoblin';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
