---
title: svn与cvs的区别
layout: post
filename: difference svn and cvs
on: 2013-03-06 21:17:28
toc: off
comments: true
categories: [scm,svn]
CATEGORY: svn与cvs的区别
---

<div><div><p><br/>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">版本编号方面</h3>
<div class="outline-text-3" id="text-1-1">

<p>在SVN中，新版本的版本号不是针对某个特定文件的，而是针对整个库而言的。<br/>
而cvs是对文件的版本编号。<br/>
svn的版本类似是对整个库的快照。<br/>
SVN的全局性版本编号为SVN带来了诸多的优势：如对目录或文件执行拷贝，无论涉及多少文件，SVN不需要对单个文件依次执行拷贝命令，仅仅需要建立一个指向相应的全局版本号的一个指针即可。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">目录的版本控制</h3>
<div class="outline-text-3" id="text-1-2">

<p>CVS只能对文件进行版本控制，不能对目录进行版本控制。<br/>
SVN将目录作为一类特殊的文件来处理。当目录中的子目录/文件被删除、重命名、或新的子目录/文件被创建时，目 录的内容将发生改变。因此，SVN象记录普通文件的修改历史一样记录对目录的修改历史，当发生文件/目录的移动、重命名或拷贝操作时，SVN能够准确记录 操作前后的历史联系。同样，像对文件的不同历史版本进行比较一样，SVN支持对目录的不同历史版本的比较，清晰展现目录的变化历史。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">原子性提交</h3>
<div class="outline-text-3" id="text-1-3">

<p>SVN提交文件，只有当全部文件修改都成功入库，该提交才变得有效。一旦中断，SVN将会自动执行“回滚”（rollback）操作。SVN 这种机制保证所有的修改要么全部入库生效，要么一个也不入库。由于SVN的原子性提交特性和全局版本编号方式，当提交成功完成时，一个唯一的、新的全局版 本编号产生，而提交时用户提供的日志信息与该新的版本编号关联，只进行一次存储（区别于CVS的按文件重复存储）。<br/>
而CVS则采用线性、串行的批量提交，即依次地，一个接一个地执行提交，每成功提交一个文件，该文件的一个新的版本即被记录到版本库中。但当任 何原因造成批量操作的中断时，版本库往往处于一个不一致的状态。另外，CVS即使在批量提交不发生中断时也会造成不一致：假设用户A启动一个需要较长时间 才能完成的批量提交；与此同时，用户B执行cvsupdate操作。此时，用户B很有可能得到一个不一致的更新，即用户B通过“更新”操作，得到用户A的 部分修改文件。<br/>
</p>
<p><br/>
</p></div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">差异化的二进制文件处理</h3>
<div class="outline-text-3" id="text-1-4">

<p>SVN每次提交后版本库中只存储相对于先前版本的差异，从而可以节省大量的存储空间。更为重要的是，当客户端需要获取新的版本 时，SVN只传输版本的差异，从而大大减少对网络带宽的消耗。<br/>
</p></div>
</div>
</div>
